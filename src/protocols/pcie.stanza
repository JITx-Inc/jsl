#use-added-syntax(jitx)
defpackage jsl/protocols/pcie:
  import core
  import jitx
  import jitx/commands

  import jsl/bundles
  import jsl/errors
  import jsl/si/helpers
  import jsl/si/couplers
  import jsl/pin-assignment

  import jsl/examples/si/pcie-example ; need to refer to the example file here?

doc: \<DOC>
PCI-E Bundle
PCI-E is a serial communication supporting high speed data links
@see https://en.wikipedia.org/wiki/PCI_Express
<DOC>

public defenum PCIeVersion:
  PCIE-V1
  PCIE-V2
  PCIE-V3
  PCIE-V4
  PCIE-V5
  PCIE-V6
  PCIE-V7

defn ensure-valid (lanes) -> True|False:
  val res = switch(lanes) :
    1  : true
    2  : true
    4  : true 
    8  : true
    16 : true
    32 : true
    else : throw $ Exception("Invalid Lane Configuration for PCIe Bundle")
  res

public defn pcie (-- lanes:Int = 4) :
  ; This still throws
  ensure-valid(lanes)
  pcb-bundle pcie_b :
    name = "PCI-E"
    description = "PCI-E Serial Communications Link"
    port control : pcie-control
    port data : pcie-data(lanes)
  pcie_b

doc: \<DOC>
PCI-E Data Bundle
The Data Bundle consists of a number (1 or more) of RX and TX pairs (count = lanes)
and it also includes a refclk (100MHz) pair
@see https://en.wikipedia.org/wiki/PCI_Express
<DOC>

public pcb-bundle pcie-data (lanes:Int) :
  name = "PCI-E Data"
  description = "PCI-E Serial Communications Link Data"
  port rx : diff-pair[lanes] 
  port tx : diff-pair[lanes] 
  port refclk : diff-pair

doc: \<DOC>
PCI-E Control Bundle
PCI-E is a serial communication supporting high speed data links
@see https://en.wikipedia.org/wiki/PCI_Express
<DOC>

public pcb-bundle pcie-control :
  name = "PCI-E Control"
  description = "PCI-E Serial Communications Link Control"
  pin PEWAKE#
  pin PRSNT#          ; hot plug detection
  pin PERST#          ; PCI-E Reset signal
  pin CLKREQ#         ; clock request


doc: \<DOC>
The connect-pci-e() function connects two equivalent pcie bundles together by
connecting the tx pairs on the first bundle to the rx pairs on the second bundle and 
vice versa. It also connects the control sub-bundle together without constraints.
For the data lines, the constraints on intra-pair skew, max loss and trace impedance
need to be verified by the user. Some defaults in the table are derived from the references
listed below. The function also inserts two TX blocking caps in series to the connection between 
the TX and RX pairs. The particular blocking cap to be used needs to be passed into this 
function.
<DOC>

public defn connect-pci-e (gen:jsl/protocols/pcie/PCIeVersion, cap:Instantiable, x:JITXObject, y:JITXObject) : 
  inside pcb-module :
    defn constraint (gen:PCIeVersion, half:True|False, a:JITXObject, b:JITXObject) :
      ; some references for the data in the following table:
      ; https://pcisig.com/pci-express%C2%AE-50-architecture-channel-insertion-loss-budget-0
      ; 

      ; there are also very loose lane to lane skew spec:
      ; the following lane-to-lane (inter pair) skews are tolerable for different lane rates:
      ; Parameter	       2.5 GT/s	5.0 GT/s	8.0 GT/s	16.0 GT/s Unit
      ; Lane to Lane Skew	20	     8	        6	          5 ns
      ;
      ; tpd 170ps/in to 147 ps/in -> 170fs/mil to 147 fs/mil
      ; @  5 mils that is a intra-pair skew of 850 fs to 750 fs
      ; @ 10 mils that is a intra-pair skew of 1.70ps to 1.50ps
      ; for system board skew match: https://docs.broadcom.com/doc/pcie-pcb-layout-review page 2
      ; 
      ; https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/powerquicc/2284/1/AN307_TP_HARDWARE_DESIGN_PCI_SMGIII.pdf
      ; P/N swapping is ok per pair
      ; all lanes being swapped is ok as well
      ; this will be handled in the component level I think
      ; 
      val [sw, ml, ti] = 
        switch(gen) :
          PCIE-V1 : [0.0 +/-  1.0e-12,  12.0, 100.0 +/- (5 %)]  ;   2.5 GT/s
          PCIE-V2 : [0.0 +/-  1.0e-12,  12.0, 100.0 +/- (5 %)]  ;   5.0 GT/s
          PCIE-V3 : [0.0 +/-  1.0e-12,  10.3,  85.0 +/- (5 %)]  ;   8.0 GT/s
          PCIE-V4 : [0.0 +/- 0.850e-12, 13.5,  85.0 +/- (5 %)]  ;  16.0 GT/s
          PCIE-V5 : [0.0 +/- 0.850e-12, 16.0,  85.0 +/- (5 %)]  ;  32.0 GT/s
          PCIE-V6 : [0.0 +/- 0.850e-12, 16.0,  85.0 +/- (5 %)]  ;  64.0 GT/s
          PCIE-V7 : [0.0 +/- 0.850e-12, 16.0,  85.0 +/- (5 %)]  ; 128.0 GT/s

      ; NOTE: user land code to provide the correct routing structure to us
      ; given that we don't know the stack-up at this point
      ; an example of this function is available in jsl/examples/si/pcie-example.stanza
      val rs = diff-imped-func(gen, ti)
      topo-net(a => b)
      diff-structure(rs, a => b)
      val swf = sw * if (half): typ(0.50) else: typ(1.00)
      val mlf = ml * if (half): 0.50 else: 1.00
      skew-window(swf, a => b)
      max-loss(mlf, a => b)

    for i in indices(x.data.tx) do : 
      inst bl-x-y-cap : dp-coupler(cap)
      require tx1 : dual-pair from bl-x-y-cap
      constraint(gen, true, x.data.tx[i], tx1.A)
      constraint(gen, true, tx1.B, y.data.rx[i])

    for i in indices(y.data.tx) do : 
      inst bl-y-x-cap : dp-coupler(cap)
      require tx1 : dual-pair from bl-y-x-cap
      constraint(gen, true, y.data.tx[i], tx1.A)
      constraint(gen, true, tx1.B, x.data.rx[i])

    constraint(gen, false, x.data.refclk, y.data.refclk)

    net (x.control y.control)

