#use-added-syntax(jitx)
defpackage jsl/symbols/BoxSymbol:
  import core
  import collections
  import pcre
  import jitx
  ;import jitx/api
  import jitx/commands
  import jitx/utils/got
  import jitx/schematic/analysis
  import jsl/ensure

  import jsl/symbols/utils
  import jsl/symbols/SymbolDefn
  import jsl/symbols/SymbolNode
  import jsl/geometry/box
  import math

val DEF_LINE_WIDTH = 0.05
val DEF_PIN_LEN = 1.0
val DEF_PAD_REF_SIZE = 0.25
val DEF_PIN_NAME_SIZE = 0.25
; length between pins
val DEF_PIN_PITCH = 0.5
; min length of rows/columns
val DEF_COL_WIDTH = 2
val DEF_ROW_WIDTH = 0
; padding for top and bottom of a cell
val DEF_CELL_TOP_MARGIN = 0.5
val DEF_CELL_BOTTOM_MARGIN = 0.5
; length between groups/singleton pins
val DEF_INTER_PIN_GROUP_MARGIN = 0.5
val LR_DEF_ALIGN = S
val UD_DEF_ALIGN = E

public :
  val ROW_PROP = `row
  val COL_PROP = `column
  val ALIGN_PROP = `alignment
  val SIDE_PROP = `side
  val GROUP_PROP = `group

val SIDES = [Left, Right, Up, Down]
val SYM_PROPS = [ROW_PROP, COL_PROP, ALIGN_PROP, SIDE_PROP, GROUP_PROP]

val LR_ANCHORS = [N, C, S]
val UD_ANCHORS = [E, C, W]

defn anchors (s: Dir) :
  match(s) :
    (lr: Left|Right) : LR_ANCHORS
    (ud: Up|Down) : UD_ANCHORS

defn top-anchor (s: Dir) :
  match(s) :
    (lr: Left|Right) : N
    (ud: Up|Down) : E

defn bottom-anchor (s: Dir) :
  match(s) :
    (lr: Left|Right) : S
    (ud: Up|Down) : W

deftype BoxSymbolError <: Exception
defmulti message (e: BoxSymbolError) -> ?

defstruct BoxSymbolApiError <: BoxSymbolError :
  message: ? with : (as-method => true)

defstruct BoxSymbolParamError <: BoxSymbolError :
  message: ? with : (as-method => true)

defmethod print (o:OutputStream, e:BoxSymbolApiError) :
  print(o, "BoxSymbol API error: %_" % [message(e)])

defmethod print (o:OutputStream, e:BoxSymbolParamError) :
  print(o, "BoxSymbol invalid param: %_" % [message(e)])

defn check-port-type (objs: Seqable<JITXObject>) -> Vector<JITXObject> :
  val non-ports = Vector<JITXObject>()
  val ports = Vector<JITXObject>()
  for o in objs do :
    match(o) :
      (s:Self) : add(non-ports, s)
      (ns) :
        match(port-type(ns)) :
          (p:PortType) : add(ports, o)
          (f): add(non-ports, o)
  if length(non-ports) > 0 :
    throw $ BoxSymbolApiError("Object(s) %_ are not of expected PortType"
      % [non-ports])
  ports

public defn to-pins (objs:Seqable<JITXObject>) -> Tuple<Pin> :
  to-tuple $ for o in objs seq : Pin(local(o))

public defn to-pin (obj:JITXObject) -> Pin :
  Pin(local(obj))

defn check-non-neg (prop:Symbol, arg:Int) :
  if arg < 0 :
    throw $ BoxSymbolParamError("negative val %_ for prop '%_'" % [arg, prop])

defn check-valid-anchor (side:Dir, anchor:Anchor) :
  val valid-anchors = anchors(side)
  if not contains?(valid-anchors, anchor) :
    throw $ BoxSymbolParamError("anchor %_ not compatible with side %_. Expect one of %_",
      % [anchor, side, valid-anchors])

doc: \<DOC>
Parameters for Box Symbol Glyph Construction

This type contains various parmaeters that we may
want to apply to all box symbols. We provide default
values for a sane consistent default look.
<DOC>
public defstruct BoxSymbolParams <: Equalable :
  min-col-width:Int with: (
    ensure => ensure-non-negative!
    updater => sub-min-col-width
  )
  min-row-width:Int with: (
    ensure => ensure-non-negative!
    updater => sub-min-row-width
  )
  line-width:Double with: (
    ensure => ensure-positive!
    updater => sub-line-width
  )
  pin-length:Double with: (
    ensure => ensure-positive!
    updater => sub-pin-length
  )
  doc: \<DOC>
  Font size for pad names that appear on the symbol.
  <DOC>
  pad-ref-size:Double with: (
    ensure => ensure-positive!
    updater => sub-pad-ref-size
  )
  doc: \<DOC>
  Spacing between input pins.
  This value is in symbol grid units. The best values are
  whole numbers or half-numbers (0.5, 1.5, etc).
  <DOC>
  pin-pitch:Double with: (
    updater => sub-pin-pitch,
    ensure => ensure-positive!
  )
  doc: \<DOC>
  Font size for pin names that appear on the symbol.
  <DOC>
  pin-name-size:Double with: (
    ensure => ensure-positive!
  )
  ; Others here like:
  ; Default Head & Foot Padding
  ;    Example: for components that only have pins on the
  ;      left and right side - we may want to add additional
  ;      rectangle height so that there is more body above the first
  ;      pin and/or below the last pin.
  ; For the future:
  ;  Color - stroke, fill, etc.
  ;
with:
  constructor => #BoxSymbolParams
  equalable => true
  printer => true

doc: \<DOC>
Main Type for building Box Symbols.
<DOC>
public defn BoxSymbolParams (
  --
  col-width:Int = DEF_COL_WIDTH
  row-width:Int = DEF_ROW_WIDTH
  line-width:Double = DEF_LINE_WIDTH
  pin-length:Double = DEF_PIN_LEN
  pad-ref-size:Double = DEF_PAD_REF_SIZE
  pin-pitch:Double = DEF_PIN_PITCH
  pin-name-size:Double = DEF_PIN_NAME_SIZE
  ) -> BoxSymbolParams:
  #BoxSymbolParams(
    col-width
    row-width
    line-width
    pin-length
    pad-ref-size
    pin-pitch
    pin-name-size
  )

; Stores the default box symbols parameters so that they can
;  be overridden by the user.
var DEF_BOXSYMB_PARAMS = BoxSymbolParams()

public defn get-default-box-symbol-params () -> BoxSymbolParams :
  DEF_BOXSYMB_PARAMS

public defn set-default-box-symbol-params (v:BoxSymbolParams) -> False :
  DEF_BOXSYMB_PARAMS = v

public defn reset-default-box-symbol-params () -> False :
  DEF_BOXSYMB_PARAMS = BoxSymbolParams()

doc: \<DOC>
<DOC>
public defstruct BoxSymbol <: SymbolDefn :
  doc: \<DOC>
  This is the component from which we are building this symbol
  This component object will provide the pins and pin properties
  needed to construct the box symbol.
  <DOC>
  obj:Instantiable|Self

  doc: \<DOC>
  Optional Explicit Parameters for this Box Symbol

  This is useful for testing or explicitly overriding the defaults without
  changing them for the rest of the schematic.
  <DOC>
  params:Maybe<BoxSymbolParams>
    with: (default => None())

  ; For internal data tracking
  box-info:BoxSymbolInfo
    with: (default => BoxSymbolInfo())
  ; TODO - support banks
  banks:HashTable<Int|Ref,BoxSymbolInfo>
    with: (default => HashTable<Int|Ref,BoxSymbolInfo>())
with:
  constructor => #BoxSymbol
  printer => true

public defn BoxSymbol (
  obj:Instantiable|Self
  --
  params:BoxSymbolParams = ?
  ) -> BoxSymbol:
  #BoxSymbol(obj, params)

defstruct BoxSymbolInfo :
  grid:[Int, Int]
    with: (default => [1,1], setter => set-grid)
  ; whether the user has explicitly set a grid or not
  active-grid?:True|False
    with: (default => false, setter => set-active-grid?)
  ; since `self` can change when generating the symbol data,
  ; pin-info is all the relevant pin property information
  ; copied out from self before symbol generation
  pin-info:Table<Ref,Table<Symbol,?>>
    with: (
      default => HashTable<Ref,Table<Symbol,?>>()
      setter => set-pin-info
    )
  ; maintain the order of pins since copying to a table
  ; will lose that information
  pin-order:Tuple<Ref>
    with: (
      default => [], setter => set-pin-order
    )

  decorator-by-pin:HashTable<Ref, Vector<PinDecorator>>
    with: (default => HashTable<Ref,Vector<PinDecorator>>())

; ============== Helper Functions ================
;
defn get-params (x:BoxSymbol) -> BoxSymbolParams :
  match(params(x)):
    (_:None): get-default-box-symbol-params()
    (v:One<BoxSymbolParams>): value(v)

; save all relevant pin property information
; explicitly since eventuallly we will lose the reference to self
defn save-pin-info (x:BoxSymbol) :
  val pin-infos = HashTable<Ref, HashTable<Symbol, ?>>()
  val pin-order = Vector<Ref>()
  for p in sort-by-row-index(pins(obj(x))) do :
    val props = HashTable<Symbol, ?>()
    for pr in SYM_PROPS do :
      match(get-property?(p, pr)) :
        (one: One) :
          props[pr] = value(one)
        (none: None) :
          false
    pin-infos[ref(p)] = props
    add(pin-order, ref(p))
  set-pin-info(box-info(x), pin-infos)
  set-pin-order(box-info(x), to-tuple $ pin-order)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SymbolDefn Interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public defmethod name (x:BoxSymbol) -> String :
  to-string("Box-%_" % [obj(x)])

; Need an override here because `self` will get
; clobbered inside the nested contexts so
; all the pin property data needed for
; rendering the symbol correctly has to be copied out
public defmethod create-symbol (
  x:BoxSymbol,
  --
  pose:Pose = loc(0.0, 0.0),
  scale:Double = UNIT-TO-MM
  description:String = ""
) -> SchematicSymbol :
  ; save properties before losing 'self'
  save-pin-info(x)

  pcb-symbol sym :
    name = name(x)
    description = description
    make-all(x, pose = pose, scale = scale)
  sym

; ===== Helpers for build-pins =======
;
; contains pin data for one side of a single grid cell
defstruct CellPinInfo :
  ; Each element in a "pin-group" is either a group name
  ; (String) or a singleton pin (Ref)
  ; The individual pin refs for a group name can be
  ; looked up through the pin-groups table
  pin-groups-by-align: HashTable<Anchor, Vector<Ref|String>>
  pin-groups: HashTable<String,Vector<Ref>>
  side: Dir
with :
  printer => true

; contains min sizing data for a single grid cell
; this may not be the final size because cells in the same row
; or column may require larger sizing
defstruct CellSizeInfo :
  ; size of eacha alignment group
  min-align-group-size: HashTable<Anchor, Double>
  min-total-size: Double
with :
  printer => true

; struct for passing around row/col/side data
defstruct RCS <: Equalable & Hashable :
  row:Int
  col:Int
  side:Dir
with :
  printer => true
  equalable => true
  hashable => true

public defmethod build-pins (bs:BoxSymbol, node:SymbolNode) :
  val params = get-params(bs)
  val ppitch = pin-pitch(params)
  val num-rows = get-rows(bs)
  val num-cols = get-columns(bs)
  val pin-info-bs = pin-info(box-info(bs))
  val pin-order-bs = pin-order(box-info(bs))

  val pins-by-rcs = HashTable<RCS,Vector<Ref>>()
  val pin-info-by-rcs = HashTable<RCS, CellPinInfo>()
  val size-info-by-rcs = HashTable<RCS, CellSizeInfo>()
  val actual-size-by-rcs = HashTable<RCS, Double>()

  ; determine row/col for a specific pin given properties for that pin
  ; 'Top' gets row = 0
  ; 'Bottom' gets row = num-rows
  ; 'Left' gets col = 0
  ; 'Right' gets col = num-cols
  ; Defaults :
  ;   side = 'Left', row = 0, col = 0
  defn calc-rcs (props: Table<Symbol,?>) -> RCS:
    val side = get?(props, SIDE_PROP, Left)
    val has-row? = key?(props, ROW_PROP)
    val has-col? = key?(props, COL_PROP)

    val row =
      if side == Top : 0
      else if side == Bottom : num-rows - 1
      else :
        if has-row? :
          val row = props[ROW_PROP]
          if row < 0 : 0
          else if row >= num-rows : num-rows - 1
          else : row
        else : 0
    val col =
      if side == Left : 0
      else if side == Right : num-cols - 1
      else :
        if has-col? :
          val col = props[COL_PROP]
          if col < 0 : 0
          else if col >= num-cols : num-cols - 1
          else : col
        else : 0
    RCS(row, col, side)

  ; calculate the minimum length of a given cell
  defn calc-min-cell-dimension (c:CellPinInfo) -> CellSizeInfo :
    defn calc-pin-to-pin-length (pin-group: Vector<Ref|String>) -> Double :
      var total = 0.0
      for p in pin-group do :
        match(p) :
          (single: Ref) : false
          (group: String) :
            total = total + ppitch * to-double(length(pin-groups(c)[group]) - 1)
      total = total + DEF_INTER_PIN_GROUP_MARGIN * to-double(length(pin-group) - 1)
      total

    ; for a given alignment group, get the dimension of the group
    val align-to-size = HashTable<Anchor,Double>()
    for a in anchors(side(c)) do :
      match(get?(pin-groups-by-align(c), a)) :
        (pins: Vector<Ref|String>) : align-to-size[a] = calc-pin-to-pin-length(pins)
        (f) : false

    val edge-padding =
      match(side(c)) :
        (lr: Left|Right): DEF_CELL_TOP_MARGIN + DEF_CELL_BOTTOM_MARGIN
        (ud: Up|Down): DEF_CELL_TOP_MARGIN + DEF_CELL_BOTTOM_MARGIN

    ; count padding between align groups
    val num-align-groups = to-double(length(to-tuple $ keys(pin-groups-by-align(c))))
    val align-group-padding = (num-align-groups - 1.0)
      * (DEF_CELL_TOP_MARGIN + DEF_CELL_BOTTOM_MARGIN)

    val total = sum(values(align-to-size)) + align-group-padding + edge-padding
    val min-size = edge-padding +
      match(side(c)) :
        (lr: Left|Right):
          to-double(min-row-width(params))
        (ud: Up|Down):
          to-double(min-col-width(params))
    CellSizeInfo(align-to-size, max(total, min-size))

  defn build-cell-info (rcs:RCS, pins:Vector<Ref>) :
    val aligned-pin-groups = HashTable<Anchor,Vector<Ref|String>>()
    val pin-groups = HashTable<String,Vector<Ref>>()

    ; representative anchor for group
    val group-anchors = HashTable<String,Anchor>()
    ; prevent groups from being added twice to aligned-pin-groups
    val seen-groups = HashSet<String>()

    val side = side(rcs)
    val default-anchor =
      match(side) :
        (lr:Left|Right) : LR_DEF_ALIGN
        (ud:Up|Down) : UD_DEF_ALIGN

    ; multiple alignments in a group are not allowed
    defn check-group-align (group:String, align:Anchor|False) :
      match(get?(group-anchors, group)) :
        (a: Anchor) :
          if align != a :
            throw $ BoxSymbolParamError("multiple alignments found in same group:
              group:%_ [%_ %_]" % [group, align, a])
        (f) : false

    ; go through all the pins in a cell, bookkeeping the following :
    ;   * grouping pins by group
    ;   * bucketing pins and groups of pins by alignment
    ;     - if one or more pins in a group has a specific alignment
    ;       that alignment is used for the whole group
    ;     - multiple alignments in a group not allowed
    ;
    ; need two passes, first pass is to validate and assign explicitly
    ; specified alignments to groups. second pass is to assign pins that were
    ; unspecified or added to a group after the user assigned an alignment to a group
    ; (since we don't keep a data structure explicitly tracking group info)
    for p in pins do :
      match(get?(pin-info-bs[p], GROUP_PROP)) :
        (g: String) :
          add-to-vector-table(pin-groups, g, p)
          match(get?(pin-info-bs[p], ALIGN_PROP)) :
            (a: Anchor) :
              check-valid-anchor(side, a)
              check-group-align(g, a)
              group-anchors[g] = a
            (f) : false
        (f) : false

    ; Since not all pins in a group may have the alignment specified, we need to rebuild the table
    ; as a group may have been bucketed to more than one anchor
    ;   * default alignment for L/R pins is S, U/D pins is E
    for p in pins do :
      match(get?(pin-info-bs[p], GROUP_PROP)) :
        (g: String) :
          if add(seen-groups, g) :
            val a = get?(group-anchors, g, default-anchor)
            add-to-vector-table(aligned-pin-groups, a, g)
        (f) :
          val a = get?(pin-info-bs[p], ALIGN_PROP, default-anchor)
          add-to-vector-table(aligned-pin-groups, a, p)

    pin-info-by-rcs[rcs] = CellPinInfo(aligned-pin-groups, pin-groups, side)
    size-info-by-rcs[rcs] = calc-min-cell-dimension(pin-info-by-rcs[rcs])

  defn calc-width-height () -> [Double, Double] :
    defn calc-side (side:Left|Up, len:Int) -> Double :
      var total-size = 0.0
      val min-cell-size =
        match(side) :
          (l:Left) : to-double(min-row-width(params))
          (u:Up) : to-double(min-col-width(params))
      for i in 0 to len do :
        val [start-edge, end-edge] =
          match(side) :
            (l:Left) : [RCS(i,0,Left),RCS(i,(num-cols - 1),Right)]
            (u:Up) : [RCS(0,i,Up),RCS(len,i,Down)]
        val cell-size =
          match(
            get?(size-info-by-rcs, start-edge)
            get?(size-info-by-rcs, end-edge)
          ):
            (f: False, g: CellSizeInfo) : min-total-size(g)
            (g: CellSizeInfo, f: False) : min-total-size(g)
            (g1: CellSizeInfo, g2:CellSizeInfo): max(min-total-size(g1), min-total-size(g2))
            (f1,f2) : min-cell-size
        actual-size-by-rcs[start-edge] = cell-size
        actual-size-by-rcs[end-edge] = cell-size
        total-size = total-size + cell-size
      total-size
    [calc-side(Up, num-cols), calc-side(Left, num-rows)]

  ; =========== Start processing ============
  ;
  ; group pins by cell and side
  for p-ref in pin-order-bs do :
    val p-info = pin-info-bs[p-ref]
    val rcs = calc-rcs(p-info)
    add-to-vector-table(pins-by-rcs, rcs, p-ref)

  ; build cell-info for each grid cell
  for rcs+pins in pins-by-rcs do :
    build-cell-info(key(rcs+pins), value(rcs+pins))

  defn calc-snap-grid-buffer (dim: Double) -> Double :
    ceil(dim / 0.5) * 0.5 - (dim)

  ; calculate and draw rectangle
  val [width, height] = calc-width-height()
  val top = height / 2.0
  val top-buffer = calc-snap-grid-buffer(top)
  val top-snap-grid = top + top-buffer
  val left = (- 1.0) * (width / 2.0)
  val side-buffer = calc-snap-grid-buffer(left)
  val left-snap-grid = left + side-buffer
  val top-left = Point(left-snap-grid, top-snap-grid)

  val box-pose = loc(side-buffer, top-buffer)
  rectangle(node, width, height, pose = box-pose)
  println("Rectangle w%_, h%_, pose %_" % [width, height, box-pose])

  defn build-pin-group (
    pins:Vector<Ref>|Tuple<Ref>,
    start:Point
    side:Dir
  ) -> Double :
    defn create-default-vpin-params () -> VirtualPinParams :
      VirtualPinParams(
        direction = side,
        pin-length = pin-length(params),
        pad-ref-size = pad-ref-size(params),
        pin-name-size = pin-name-size(params)
      )
    val positions =
      match(side) :
        (lr:Left|Right) :
          for i in 0 to length(pins) seq : Point(x(start), y(start) - to-double(i) * ppitch)
        (ud:Up|Down) :
          for i in 0 to length(pins) seq : Point(x(start) + to-double(i) * ppitch, y(start))
    for (p in pins, pos in positions) do :
      val decs = get?(decorator-by-pin(box-info(bs)), p, [])
      val dec-offset =
        if length(decs) == 0 : pos
        else :
          match(side) :
            (l:Left) : loc(0.6 0.0) * pos
            (r:Right) : loc((-1.0), 0.0) * pos
            (u:Up) : pos
            (d:Down) : pos

      val custom-params =
        if length(decs) == 0 :
          create-default-vpin-params()
        else :
          VirtualPinParams(
            direction = side,
            pin-length = pin-length(params),
            pad-ref-size = pad-ref-size(params)
          )

      val vpin = add-pin(node, p, pos, params = custom-params)
      if length(decs) > 0 :
        text(node, dec-offset, to-string(p), font-size = 2)
      for d in decs do :
        add-decorator(vpin, d)

    to-double(length(pins)) * ppitch

  defn build-cell (row:Int, col:Int, side:Dir, start:Point) :
    println("Building cell at: r%_c%_s%_" % [row, col, side])
    val rcs = RCS(row, col, side)
    within pin-info = got?(pin-info-by-rcs, rcs) :
      defn calc-start (base:Point, offset:Double) -> Point :
        match(side) :
          (lr: Left|Right) : Point(x(base), y(base) - offset)
          (ud: Up|Down) : Point(x(base) + offset, y(base))

      ; push alignment group to the top
      defn build-edge-align-group (align:N|E|W|S, align-start:Point) :
        match(get?(pin-groups-by-align(pin-info), align)):
          (groups: Vector<Ref|String>) :
            var offset = 0.0
            println("alignment group %_ starts %_"
                % [align, align-start])
            for (pin-or-group in groups) do :
              val pins =
                match(pin-or-group) :
                  (single: Ref) : [single]
                  (group: String) : pin-groups(pin-info)[group]
              val pins-start = calc-start(align-start, offset)
              println("Building pins %_ at %_" % [pins, pins-start])
              offset = offset + build-pin-group(pins, pins-start, side)
            println("alignment group ends at %_" % [calc-start(align-start, offset)])
            offset
          (f) : 0.0

      defn build-center-align-group (top-start:Point, top-size:Double, bottom-start:Point,
        top:Point, cell-size:Double) :
        within pin-order = got?(pin-groups-by-align(pin-info), C) :
          var above-center = 0.0
          var below-center = 0.0
          val center-pin-group = length(pin-order) / 2
          val mod2 = length(pin-order) % 2
          ; odd number of groups/pins, need to split center group
          if (mod2 != 0) :
            val group-length =
              match(pin-order[center-pin-group]) :
                (g: String) : length(pin-groups(pin-info)[g])
                (p: Ref) : 1
            val edge-to-center = to-double((group-length / 2) - ((group-length - 1) % 2)) * ppitch
            above-center = above-center + edge-to-center
            below-center = below-center + edge-to-center

          ; calculate size of chunk above center pin
          for i in 0 to center-pin-group do :
            match(pin-order[i]) :
              (g: String) : above-center = above-center + ppitch * to-double(length(pin-groups(pin-info)[g]) - 1)
              (r: Ref)  : false
          ; add in the pin-group margins
          above-center = above-center + DEF_INTER_PIN_GROUP_MARGIN * to-double(center-pin-group)

          ; calculate size of chunk below center pin
          for i in (center-pin-group + mod2) to length(pin-order) do :
            match(pin-order[i]) :
              (g: String) : above-center = above-center + ppitch * to-double(length(pin-groups(pin-info)[g]) - 1)
              (r: Ref)  : false
          below-center = below-center + DEF_INTER_PIN_GROUP_MARGIN * to-double(center-pin-group)

          println("above-center %_, below-center %_" % [above-center, below-center])
          val center-start = calc-start(top-start, top-size)
          val true-center = calc-start(top, floor((cell-size / 2.0) / 0.5) * 0.5)
          ; val center = y(center-start) - ((y(center-start) - y(bottom-start)) / 2.0)
          ; if (center + c1) <= y(center-start) and center - c2 >= y(bottom-start) :
          var offset = 0.0
          for (pin-or-group in pin-order, i in 0 to false) do :
            val pins =
              match(pin-or-group) :
                (single: Ref) : [single]
                (group: String) : pin-groups(pin-info)[group]
            val new-start = calc-start(true-center, offset)
            println("[fake2] Building pins %_ at %_" % [pins, new-start])
            build-pin-group(pins, new-start, side)
            offset = offset + to-double(length(pins)) * ppitch

      val actual-size = actual-size-by-rcs[rcs]
      val size-info = size-info-by-rcs[rcs]
      println("RCS%_\n%_\n%_\nactual-size %_" % [rcs, pin-info, size-info, actual-size])
      val top-start = calc-start(start, DEF_CELL_TOP_MARGIN)
      val top-size = build-edge-align-group(top-anchor(side), top-start)
      val bottom-start = calc-start(start, actual-size - DEF_CELL_BOTTOM_MARGIN -
        get?(min-align-group-size(size-info), bottom-anchor(side), 0.0))

      build-center-align-group(top-start, top-size, bottom-start, start, actual-size)
      build-edge-align-group(bottom-anchor(side), bottom-start)

  ; finally build pins in each cell
  defn calc-start (base:Point, x-off:Double, y-off:Double) :
    Point(x(base) + x-off, y(base) - y-off)

  var row-offset = 0.0
  for i in 0 to num-rows do :
    val cols =
      if i == 0 or i == num-rows - 1 : 0 to num-cols
      else : [0, num-cols - 1]
    var col-offset = 0.0
    val down = actual-size-by-rcs[RCS(i,0,Left)] + row-offset
    for j in cols do :
      val right = actual-size-by-rcs[RCS(0,j,Up)] + col-offset
      if i == 0 :
        build-cell(i, j, Up, calc-start(top-left, col-offset, row-offset))
      if i == num-rows - 1 :
        build-cell(i, j, Down, calc-start(top-left, col-offset, down))
      if j == 0 :
        build-cell(i, j, Left, calc-start(top-left, col-offset, row-offset))
      if j == num-cols - 1 :
        build-cell(i, j, Right, calc-start(top-left, right, row-offset))
      col-offset = right
    row-offset = down
public defmethod build-artwork (x:BoxSymbol, node:SymbolNode) :
  false

public defmethod build-params (x:BoxSymbol, sn:SymbolNode) :
  val b = glyph-bounds(sn)
  text(sn, [left(b), up(b) + 0.5], ">REF", anchor = SW, font-size = 8)
  text(sn, [left(b), down(b) - 0.5], ">VALUE", anchor = NW, font-size = 8)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

doc: \<DOC>
Find a set of pins that match a particular query

@param b Box Symbol object

@param pattern Glob pattern used to find specific pins by the string variant of the pin reference.
For example, if the there is a pin `D.p[0]`, `D.p[1]`, `D.p[2]`, `M.p[0]`, `M.p[1]` and `M.p[2]`
The user could use a glob pattern `D.p[*]` to select `D.p[0]`, `D.p[1]`, `D.p[2]`

@param bank Optional bank selector so that will limit query to selecting only pins from this particular bank (symbol unit).
@param row Optional row selector that will limit query to selecting only pins from this particular row of the
  box grid.
@param column Optional column selector that will limit query to selecting only pins from this particular column of the box grid.

@return Tuple of Pins that match the given criteria.
<DOC>
defn check-prop (prop: ?, filter: ?) -> True|False :
    match(prop, filter) :
      (n: None, f: One<?>) :
        false
      (n, f: None) :
        true
      (v: One<Int|Ref>, p) :
        value(v) == p
      (n, f) :
        throw $ BoxSymbolApiError("Unsupported args to check-prop %_ %_"
          % [prop, filter])

public defn find-pins-by-regex (
  b:BoxSymbol, pattern:String
  --
  bank:Int|Ref = ?
  row:Int|Ref = ?
  column:Int|Ref = ?
  ) -> Vector<JITXObject> :

  val matches = Vector<Pin>()

  for p in pins(obj(b)) do :
    if (
      check-prop(property?(p.bank), bank)
      and check-prop(property?(p.row), row)
      and check-prop(property?(p.column), column)
      and not empty?(regex-match(pattern, to-string(ref(p))))
    ) :
      add(matches, Pin(local(p)))
  matches

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pin Grid Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

doc: \<DOC>
Check for an active grid

Components like resistors, capacitors, etc might not have an active grid.

@param b Box Symbol object
@return Indicates of a grid is present on this symbol or not.
<DOC>
public defn has-grid? (b:BoxSymbol) -> True|False :
  active-grid?(box-info(b))

doc: \<DOC>
Set the grid for a component

@param b Box Symbol object
@param grid Tuple of [row,column] where row & column must be greater than zero.
@param bank bank ID for multi-symbol unit BoxSymbols.
<DOC>
public defn set-grid (b:BoxSymbol, grid:[Int, Int]) :
  if not has-grid?(b) :
    set-grid(box-info(b), grid)
    set-active-grid?(box-info(b), true)
      ; default unspecified pins to 0, 0
    for p in pins(obj(b)) do :
      if not has-property?(p.row) :
        set-property(p, ROW_PROP, 0)
      if not has-property?(p.col) :
        set-property(p, COL_PROP, 0)
  else :
    throw $ BoxSymbolApiError("Active grid already set to %_" % [/grid(box-info(b))])
  false

public defn set-grid (b:BoxSymbol -- grid:[Int, Int], bank:Int|Ref) :
  within bi = got?(banks(b), bank) :
    set-grid(bi, grid)
    set-active-grid?(bi, true)
    ; default unspecified pins to 0, 0
    for p in pins(obj(b)) do :
      if not has-property?(p.row) :
        set-property(p, ROW_PROP, 0)
      if not has-property?(p.col) :
        set-property(p, COL_PROP, 0)
  false

doc: \<DOC>
Get the total number of rows in the pin grid.

This function is for components with only one symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of rows in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-rows (b:BoxSymbol) -> Int:
  grid(box-info(b))[0]

doc: \<DOC>
Get the total number of rows in the pin grid of a particular symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of rows in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-rows (b:BoxSymbol, bank:Int|Ref) -> Int:
  match(get?(banks(b), bank)) :
    (bi: BoxSymbolInfo) :
      grid(bi)[0]
    (f) : 1

doc: \<DOC>
Get the total number of columns in the pin grid.

This function is for components that have only one symbol unit.

@param b Box Symbol object
@return number of columns in the pin grid of component symbol. If no
pin grid is active, this function returns 0.
<DOC>
public defn get-columns (b:BoxSymbol) -> Int:
  grid(box-info(b))[1]

doc: \<DOC>
Get the total number of columns in the pin grid of a particular symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of columns in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-columns (b:BoxSymbol, bank:Int|Ref) -> Int:
  match(get?(banks(b), bank)) :
    (bi: BoxSymbolInfo) :
      grid(bi)[1]
    (f) : 1

doc: \<DOC>
Set the pin grid position for a pin or set of pins.

If the grid doesn't exist yet - this is an error and this function
should throw an exception.

There are only a limited set of valid row/column combinations based on the
edges of the box symbol.

@param pin-set One Pin or a Tuple of Pins present on `obj` that will be added to a group.
@param row Row index into the pin grid.
@param column Column index into the pin grid.
@throws IndexError If either the `row` or `column` are outside the active grid cells
<DOC>
public defn set-grid-edge (row:Int, col:Int, pins: JITXObject ...) :
  set-row(row, pins)
  set-column(col, pins)

doc: \<DOC>
Set the Row assignment for these pins

Typically this would be used when the `side` parameter had already
been set on these pins to `Left` or `Right`. The `side` parameter would
then drive the column assignment to either `0` or `N-1` where N is the number of columns .
<DOC>
public defn set-row (row:Int, pins: JITXObject ...) :
  set-row(row, pins)

public defn set-row (row:Int, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
  check-non-neg(ROW_PROP, row)
  for p in valid-pins do :
    set-property(p, ROW_PROP, row)

doc: \<DOC>
Set the Column assignment for these pins

Typically this would be used when the `side` parameter had already
been set on these pins to `Up` or `Down`. The `side` parameter would
then drive the row assignment to `0` or `M-1` where M is the number of rows.
<DOC>
public defn set-column (col:Int, pins: JITXObject ...) :
  set-column(col, pins)

public defn set-column (col:Int, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
    check-non-neg(COL_PROP, col)
    for p in valid-pins do :
      set-property(p, ROW_PROP, col)

; defn get-row (p:Pin) -> Maybe<Int>:
;   One(0)

; defn get-row! (p:Pin) -> Int:
;   0

; defn get-column (p:Pin) -> Maybe<Int>:
;   One(0)

; defn get-column! (p:Pin) -> Int:
;   0

doc: \<DOC>
Set a horizontal line separator on the edge of a row

@param b Box Symbol object
@param row Row Index into the pin grid.
@param pos Used to select which side of the row (N/S) to draw the separator line. Default value is S
@param bank Optional bank (symbol unit) identifier
@param line-width Width of the separator in symbol grid units
<DOC>
defn set-horz-separator (b:BoxSymbol, row:Int -- pos:Anchor = S , bank:Int|Ref = ?, line-width:Double = 0.05) :
  false

doc: \<DOC>
Set a vertical line separator on the edge of a column

@param b Box Symbol object
@param column Column Index into the pin grid.
@param pos Used to select which side of the column (E/W) to draw the separator line. Default value is E
@param bank Optional bank (symbol unit) identifier
@param line-width Width of the separator in symbol grid units
<DOC>
defn set-vert-separator (b:BoxSymbol, column:Int -- pos:Anchor = E , bank:Int|Ref = ?) :
  false

doc: \<DOC>
Set the side of the box symbol to assign to a pin or set of pins

This function will set the direction and side of the passed pins.

If a `grid` exists - then the appropriate column/row will be selected. For example,
The `Top` side would be given row 0. The `Left` side would be given column 0.
A `Right` side would be given column N-1 where N is the number of columns.

If the `grid` does not exist, then adding a side parameter for a set of pins would begin
constructing the grid. For example, Adding a set of pins on the `Right` and `Left` would
construct a grid of 1 row and 2 columns. Subsequent operations might increase the number of
rows if `Top` and `Bottom` pin sets were added. In this case, the row & column indices for the first group
of `Right` and `Left` pins would need to be modified. They would move from row index 0 to row index 1. The `Right`
side pins would move to column index 2. The `Top` side pins would be in row index 0 and column index 1.

NOTE: If this is too complex - we can add the constraint that the user must add the `grid` first, but in order to
match the existing functionality, I think we would need to support this.

@param pin-set One Pin or a Tuple of Pins present on `obj` that will be added to a side.
@param side Selects the edge of a box symbol on to which the pins will be drawn
<DOC>
public defn set-side (side:Dir, pins: JITXObject ...)  :
  set-side(side, pins)

public defn set-side (side:Dir, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, SIDE_PROP, side)

; defn get-side (p:Pin) -> Maybe<Dir> :
;   One(Left)

; defn get-side! (p:Pin) -> Dir :
;   Left

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Alignment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public defn pins-in-group (b:BoxSymbol, group:String) -> Tuple<Pin> :
  to-tuple $ for p in pins(obj(b)) seq? :
    match(get-property?(p, GROUP_PROP)) :
      (one:One)   :
        if value(one) == group :
          One(to-pin(p))
        else :
          None()
      (none:None) :
        None()

public defn set-alignment (pos:Anchor, pins: JITXObject ...)  :
  set-alignment(pos, pins)

public defn set-alignment (pos:Anchor, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
    for p in valid-pins do :
      set-property(p, ALIGN_PROP, pos)

; defn get-alignment (p:Pin) -> Maybe<Anchor> :
;   One(C)

; defn get-alignment! (p:Pin) -> Anchor :
;   C

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Group
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public defn set-group (group:String, pins: JITXObject ...)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, GROUP_PROP, group)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Margin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defn set-margin (pin-set:Tuple<Pin>|Pin, margin:Double) :
  false

defn set-top-margin (pin-set:Tuple<Pin>|Pin, margin:Double) :
  false

defn set-bottom-margin (pin-set:Tuple<Pin>|Pin, margin:Double) :
  false

defn set-left-margin (pin-set:Tuple<Pin>|Pin, margin:Double) :
  false

defn set-right-margin (pin-set:Tuple<Pin>|Pin, margin:Double) :
  false


defn set-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-top-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-bottom-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-left-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-right-margin (b:BoxSymbol, group:String, margin:Double) :
  false


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Decorators
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


doc: \<DOC>
Add a particular decorator[s] to the passed pins.

@param b Box Symbol Object
@param pin-set Pin or Set of Pins to add the decorator to.
@param decorators One or More decorators to add to these pins.

NOTE: Multiple decorators may not stack well yet - WIP.
<DOC>
public defn add-decorator (b:BoxSymbol, pin-set:Tuple<Pin>, decorators:Seqable<PinDecorator>) :
  for p in pin-set do :
    add-to-vector-table(decorator-by-pin(box-info(b)), ref(p), decorators)

public defn add-decorator (b:BoxSymbol, p:Pin, decorator:PinDecorator) :
  add-decorator(b, [p], [decorator])

;Sort the given pins by their .pin-properties-row-index field.
defn sort-by-row-index (pins:Tuple<JITXObject>) -> Tuple<JITXObject> :
  ;Compare pin[i0] versus pin[i1].
  ;Indices are used, instead of the pin directly, in order to perform a
  ;stable sort.
  ;All pins without a .pin-properties-row-index are put in the beginning.
  defn compare-index (i0:Int, i1:Int) :
    val ai = value?(property?(pins[i0].pin-properties-row-index))
    val bi = value?(property?(pins[i1].pin-properties-row-index))
    match(ai, bi) :
      (ai:Int, bi:Int) : compare(ai, bi)
      (ai:Int, bi) : 1
      (ai, bi:Int) : -1
      (ai, bi) : compare(i0,i1)
  val indices = qsort(0 to length(pins), compare-index)
  map({pins[_]}, indices)