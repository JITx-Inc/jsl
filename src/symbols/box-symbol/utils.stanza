#use-added-syntax(jitx)
defpackage jsl/symbols/box-symbol/utils:
  import algorithm/utils
  import core
  import collections
  import lang-utils
  import pcre
  import jitx
  import jitx/commands
  import jitx/utils/got
  import jitx/schematic/analysis
  import jsl/ensure
  import jsl/symbols/utils
  import jsl/geometry/box
  import math

; TODO(azhu): most of this is lifted from previous ocdb implementation.
; Could use a facelift.
;
public defn assign-schematic-symbols (banks: Tuple<KeyValue<Int|Ref,SchematicSymbol>>) :
  defn ensure-non-empty-banks! () :
    if empty?(banks) :
      throw(EmptyBanks(""))
  defn ensure-unique-bank-arguments! () :
    val seen-banks = HashSet<Int|Ref>()
    val duplicate-banks = Vector<Int|Ref>()
    for bank-kv in banks do :
      val bank = key(bank-kv)
      if not add(seen-banks, bank) :
        add(duplicate-banks, bank)
    if not empty?(duplicate-banks) :
      throw(DuplicateBanks(to-tuple(duplicate-banks)))
  defn ensure-banks-exist! (pin-banks:Tuple<Maybe>) :
    val banks* = map(key, banks)
    val pin-banks* = unique-banks(pin-banks)
    val extra-banks = difference(banks*, pin-banks*)
    if not empty?(extra-banks) :
      throw(MissingRequestedBanks(qsort(extra-banks)))
    val missing-banks = difference(pin-banks*, banks*)
    if not empty?(missing-banks) :
      throw(MissingBankArguments(qsort(missing-banks)))
  defn ensure-symbol-pins! (pins:Tuple<JITXObject>, pin-banks:Tuple<Maybe>) :
    val bad-matches = to-tuple $
      for bank in banks seq? :
        val symbol-pins = to-hashset(ref, /pins(value(bank)))
        val mismatched-pins = to-tuple $
          for (p in pins, b in pin-banks) seq? :
            val pin-ref = ref(p)
            if value!(b) == bank and not symbol-pins[pin-ref] :
              One(pin-ref)
            else :
              None()
        if not empty?(mismatched-pins) :
          One(name(value(bank)) => to-tuple(mismatched-pins))
        else :
          None()
    if not empty?(bad-matches) :
      throw(MissingSymbolPins(bad-matches))

  ensure-non-empty-banks!()
  ensure-unique-bank-arguments!()
  inside pcb-component :
    val pins = sort-by-row-index(pins(self))
    val pin-sides0 = map({property?(_.side)}, pins)
    val pin-banks = map({property?(_.bank)}, pins)
    val pin-sides = ensure-good-sides!(pins, pin-sides0)
    ensure-good-banks!(pins, pin-banks, true)
    ensure-banks-exist!(pin-banks)
    ensure-symbol-pins!(pins, pin-banks)
    val wrapped-banks =
      for [bank, symbol] in kvs(banks) seq :
        val pin-mappings = for (p in pins, b in pin-banks) seq? :
          if value!(b) == bank :
            One(p => dot(symbol, ref(p)))
          else :
            None()
        StandardBank(symbol, to-tuple(pin-mappings))
    make-box-symbol(wrapped-banks)

; Sort the given pins by their .pin-properties-row-index field.
public defn sort-by-row-index (pins:Tuple<JITXObject>) -> Tuple<JITXObject> :
  ;Compare pin[i0] versus pin[i1].
  ;Indices are used, instead of the pin directly, in order to perform a
  ;stable sort.
  ;All pins without a .pin-properties-row-index are put in the beginning.
  defn compare-index (i0:Int, i1:Int) :
    val ai = value?(property?(pins[i0].pin-properties-row-index))
    val bi = value?(property?(pins[i1].pin-properties-row-index))
    match(ai, bi) :
      (ai:Int, bi:Int) : compare(ai, bi)
      (ai:Int, bi) : 1
      (ai, bi:Int) : -1
      (ai, bi) : compare(i0,i1)
  val indices = qsort(0 to length(pins), compare-index)
  map({pins[_]}, indices)

defstruct StandardBank :
  symbol: SchematicSymbol
  pin-mappings: Tuple<KeyValue<JITXObject, JITXObject>>

public defn make-box-symbol (banks:Seqable<StandardBank>) :
  inside pcb-component :
    symbol :
      for (bank in banks, u in 0 to false) do :
        val [sym, mapping] = [symbol(bank), pin-mappings(bank)]
        unit(u) = sym(
          for e in mapping do :
            key(e) => value(e))

public defstruct MissingBankProperty <: BoxSymbolError :
  pins: Tuple<Ref>

defmethod print (o:OutputStream, e:MissingBankProperty) :
  print(o, "Pins %, do not have a .bank property." % [pins(e)])

public defstruct MissingBankArguments <: BoxSymbolError :
  banks: Tuple<Int|Ref>

defmethod print (o:OutputStream, e:MissingBankArguments) :
  print(o, "Banks %, are not found in `make-box-symbol` arguments." % [banks(e)])

public defstruct MissingRequestedBanks <: BoxSymbolError :
  banks: Tuple<Int|Ref>

defmethod print (o:OutputStream, e:MissingRequestedBanks) :
  print(o, "Banks %, are not found in any .bank properties." % [banks(e)])

public defstruct EmptyBanks <: BoxSymbolError :
  e: ?

defmethod print (o:OutputStream, e:EmptyBanks) :
  print(o, "`make-box-symbol` bank arguments cannot be empty.")

public defstruct DuplicateBanks <: BoxSymbolError :
  banks: Tuple<Int|Ref>

defmethod print (o:OutputStream, e:DuplicateBanks) :
  print(o, "Banks %, are duplicate in `make-box-symbol` arguments." % [banks(e)])

public defstruct MissingSymbolPins <: BoxSymbolError :
  missing: Tuple<KeyValue<String, Tuple<Ref>>>

defmethod print (o:OutputStream, e:MissingSymbolPins) :
  defn format (kv:KeyValue<String, Tuple<Ref>>) -> Printable :
    "pcb-symbol %~ is missing pin(s) %," % [key(kv), value(kv)]
  val error-str = \<S>`make-box-symbol` requires component pin names to match symbol pin names:
%n<S> % [map(Indented{format(_)}, missing(e))]
  print(o, error-str)

defn ensure-good-banks! (pins:Tuple<JITXObject>,
                         banks:Tuple<Maybe>,
                         require-banks?:True|False) :
  ;Check that all pins.banks are either Int|Ref or not given.
  for (p in pins, b in banks) do :
    ;[TODO] Why is `false` allowed?
    if value?(b) is-not Int|Ref|False :
      throw(InvalidBankType(ref(p), object-type(value?(b))))
  ;Check that all banks given or no banks given (if not required).
  if none?(empty?, banks) :
    false
  else :
    val ps = to-tuple $ for (p in pins, b in banks) seq? :
      if empty?(b) : One(ref(p))
      else : None()
    if require-banks? and empty?(ps) :
      throw(MissingBankProperty(ps))

defn ensure-good-sides! (pins:Tuple<JITXObject>, sides:Tuple<Maybe>) -> Tuple<Dir> :
  ;Check that all pins.side is either Dir or not given.
  for (p in pins, s in sides) do :
    ;[TODO] Why is `false` allowed?
    if value?(s) is-not Dir|False :
      throw(InvalidSideType(ref(p), object-type(value?(s))))
  ;Default side is Right
  if all?(empty?, sides) :
    map({Right}, pins)
  else if none?(empty?, sides) :
    map(value!, sides)
  else :
    val ps = for (p in pins, s in sides) seq? :
      if empty?(s) : One(ref(p))
      else : None()
    throw(MissingSideProperty(to-tuple(ps)))

defn flatten-pin-entries (es:Seqable<KeyValue<Dir,JITXObject|Seqable<JITXObject>>>) -> Vector<KeyValue<Dir,Pin>> :
  val entries = Vector<KeyValue<Dir,Pin>>()
  for e in es do :
    match(value(e)) :
      (p:Pin) : add(entries, key(e) => p)
      (ps:Seqable<Pin>) : do(add{entries, key(e) => _}, ps)
  entries

;============================================================
;====================== Errors ==============================
;============================================================
public deftype BoxSymbolError <: Exception
defmulti message (e: BoxSymbolError) -> ?

public defstruct GenericBoxSymbolError <: BoxSymbolError :
  message: ? with : (as-method => true)

public defstruct InvalidPortObject <: BoxSymbolError :
  message: ? with : (as-method => true)

public defstruct NegativeValueProperty <: BoxSymbolError :
  message: ? with : (as-method => true)

public defstruct InvalidAlignProperty <: BoxSymbolError :
  message: ? with : (as-method => true)

public defstruct InvalidGridDimension <: BoxSymbolError :
  message: ? with : (as-method => true)

public defstruct MultiAlignGroup <: BoxSymbolError :
  message: ? with : (as-method => true)

public defstruct InvalidSideType <: BoxSymbolError :
  pin: Ref
  actual-type: String

defmethod print (o:OutputStream, e:InvalidSideType) :
  print(o, "Property %_.side is expected to be a Dir object but is instead of type %_." % [
    pin(e), actual-type(e)])


public defstruct MissingSideProperty <: BoxSymbolError :
  pins: Tuple<Ref>

defmethod print (o:OutputStream, e:MissingSideProperty) :
  print(o, "Pins %, do not have a .side property." % [pins(e)])

public defstruct InvalidBankType <: BoxSymbolError :
  pin: Ref
  actual-type: String

defmethod print (o:OutputStream, e:InvalidBankType) :
  print(o, "Property %_.bank is expected to be a Int|Ref object but is instead of type %_." % [
    pin(e), actual-type(e)])

defn unique-banks (banks:Tuple<Maybe>) :
  val banks* = to-vector<Int|Ref> $ to-hashset<Int|Ref> $
    for b in banks seq :
      match(b) :
        (o:One) : value(o)
        (n:None) : throw $ Exception("One or more pins found with no banks")
  defn compare-bank (x:Int|Ref, y:Int|Ref) -> Int :
    defn rank (x:Int|Ref) :
      match(x) :
        (x:Int) : 0
        (x:Ref) : 1
    val c = compare(rank(x), rank(y))
    if c == 0 : compare(x, y)
    else : c
  qsort!(banks*, compare-bank)
  banks*

