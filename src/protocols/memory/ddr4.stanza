doc: \<DOC>
@brief Double Data Rate 4 Memory Standard (DDR4)

DDR4 is a high speed memory protocol
@see https://en.wikipedia.org/wiki/DDR4_SDRAM

This functions and definitions in this file support defining DDR4
connections between microprocessors and memories in a board design.

This file contains curated values for skew and loss of DDR4 channel
It specifies the bounds on the intra-pair
skew timing and maximum loss as expected by this particular standard. The values
returned are a toleranced value with upper/lower limits for the
intra-pair skew and the maximum loss as a double representing dB. Some defaults in the
table are derived from the references listed below.

1. Skew match between A[17] A[13:0] and CK.P is 0.0 +/- 20e-12 (20 ps) Intel or -50ps, -34ps AMD
2. Skew match between RAS_n, CAS_n, WE_n, and CK.P is 0.0 +/- 20e-12 (20 ps) Intel or -50ps, -34ps AMD
3. Skew match between BA[1:0], BG[1:0] and CK.P is 0.0 +/- 20e-12 (20 ps) Intel or -50ps, -34ps AMD
4. Skew match between ACT_n, CKE, CS_n, ODT, PAR and CK.P is 0.0 +/- 20e-12 (20 ps) Intel or -50ps, -34ps AMD
5. Skew match between CMD/ADDR/CTRL within a channel is 0.0 +/- 20e-12 (20 ps) Intel
6. Skew match of CK is 0.0 +/- 1.0e-12 (1 ps) Intel or 0.0 +/- 2.0e-12 (2 ps) AMD
7. Skew match of DQS is 0.0 +/- 1.0e-12 (1 ps) Intel or 0.0 +/- 2.0e-12 (2 ps) AMD
8. Skew match between DQ and DQS.P within a byte lane is 0.0 +/- 3.5e-12 (3.5 ps) Intel or 0.0 +/- 100.0e-12 (100 ps) AMD 
9. Skew match between CK.P and DQS.P is -85 ps to 935 ps Intel or -149 ps to +1796 ps AMD

Intel specs derived from:
https://www.intel.com/content/www/us/en/docs/programmable/683216/23-2-2-7-1/skew-matching-guidelines-for-ddr4-discrete.html
AMD specs derived from:
https://docs.amd.com/r/en-US/ug863-versal-pcb-design/Timing-Constraint-Rules-for-DDR4-Signals
for the DDR4 component table

Calculating the distance to time correspondence depends on the board material.
Example:
  tpd 147 ps/in 170 ps/in -> 147 fs/mil to 170 fs/mil
  @  5 mils spec'ed that is a intra-pair skew of 735 fs to 850 fs depending on the material characteristics
  @ 10 mils spec'ed that is a intra-pair skew of 1.47 ps to 1.70 ps depending on the material characteristics

<DOC>

#use-added-syntax(jitx)
defpackage jsl/protocols/memory/ddr4:
  import core
  import jitx
  import jitx/commands

  import jsl/bundles
  import jsl/errors
  import jsl/ensure
  import jsl/si
  import jsl/pin-assignment

doc: \<DOC>
@brief DDR4 width enums
This is a fixed list of possible lane widths for DDR4 memory channels
@member DDR4-x4   4 bit width
@member DDR4-x8   8 bit width
@member DDR4-x16 16 bit width
@member DDR4-x72 72 bit width
<DOC>
public pcb-enum jsl/protocols/memory/ddr4/DDR4-width:
  DDR4-x4
  DDR4-x8
  DDR4-x16
  DDR4-x72

doc: \<DOC>
@brief DDR4 Width enum conversion to integers
This converts possible lane widths for ddr4 memory channels into the corresponding integer
<DOC>
public defn width-to-int (en:DDR4-width) -> Int:
  switch(en) :
    DDR4-x4  :  4
    DDR4-x8  :  8
    DDR4-x16 : 16
    DDR4-x72 : 72

doc: \<DOC>
@brief DDR4 Width enum conversion to lane count
This converts possible lane widths for ddr4 memory channels
into the corresponding integer number of 8-bit lanes which
determines the number of DQS pairs required.
<DOC>
public defn width-to-lane (en:DDR4-width) -> Int:
  switch(en) :
    DDR4-x4  : 1 ; degenerate case
    DDR4-x8  : 1
    DDR4-x16 : 2
    DDR4-x72 : 9

doc: \<DOC>
@brief ddr4 topology
This is a fixed list of possible topologies for ddr4 memories
@member FlyBy
@member ClamShell
<DOC>
public pcb-enum jsl/protocols/memory/ddr4/DDR4-topology:
  FlyBy
  ClamShell

doc: \<DOC>
@brief DDR4 rank Options
This is a fixed list of possible rank options for ddr4 implementations
@member SingleRank
@member DualRank
@member QuadRank
<DOC>
public pcb-enum jsl/protocols/memory/ddr4/DDR4-rank:
  SingleRank
  DualRank
  QuadRank

doc: \<DOC>
@brief DDR4 rank enum conversion to integers
This converts possible rank options for ddr4 memory channels into a corresponding integer
which determines the number of CS_n signals needed to control the memories
<DOC>
public defn rank-to-int (en:DDR4-rank) -> Int:
  switch(en) :
    SingleRank : 1
    DualRank   : 2
    QuadRank   : 4

doc: \<DOC>
@brief ddr4 Bundle
One ddr4 bundle consists of the connections between an integrated memory controller and
one or more ddr4 memory chips/DIMMs.
@member data Data channel(s) for ddr4 depending on the width
@member ctl Control channel for ddr4
@member rank Rank configuration of the DDR4 memory (SingleRank, DualRank, or QuadRank)
@member topology Topology of the DDR4 connection (FlyBy or ClamShell)
<DOC>

public defn ddr4 (width:DDR4-width -- rank:DDR4-rank = SingleRank topology:DDR4-topology = FlyBy) :
  if width == DDR4-x4 and rank != SingleRank:
    fatal("DDR4-x4 is only supported in SingleRank configuration")
  if width == DDR4-x16 and rank == QuadRank:
    fatal("DDR4-x16 is not supported in QuadRank configuration")
  ddr4-b(width, rank, topology)

public pcb-bundle ddr4-b (width:DDR4-width rank:DDR4-rank topology:DDR4-topology) :
  name = "DDR4"
  description = "DDR4 Dynamic Random-Access Memory protocol"
  port data    : ddr4-data-channel(width) ;
  port ctl     : ddr4-ctl-channel(rank) ; covers all CMD/CTRL/ADDR

public pcb-bundle ddr4-data-channel (width:DDR4-width):
  port DQ    : pin[width-to-int(width)] ; will vary from 3:0 to 7:0 to 15:0 to 71:0 as appropriate
  port DQS   : diff-pair[width-to-lane(width)] ; will either be 0 or 1:0 to 8:0
  port DM_n  : pin[width-to-lane(width)] ; data mask per 8b lane

public pcb-bundle ddr4-ctl-channel (rank:DDR4-rank):
  ; how do I use rank here? Needs some work...
  port CK      : diff-pair
  port CKE     : pin
  port A       : pin[[0 to 17]]
  port ACT_n   : pin
  port BG      : pin[2] ; not fully present?
  port BA      : pin[2] ; not fully present?
  port CS_n    : pin[rank-to-int(rank)]
  port RESET_n : pin
  port ODT     : pin
  port PAR     : pin
  ; port TEN     : pin
  port ALERT_n : pin
  ; port ZQ      : pin[width-to-lane(width)]

  ; port RAS_n   : pin ; aka A[16]
  ; port CAS_n   : pin ; aka A[15]
  ; port WE_n    : pin ; aka A[14]


doc: \<DOC>
@brief Differential impedance specified by the DDR4 standard
This is a helper function that returns the expected differential
trace impedance for the standard.

@return Upper/lower limits for the impedance.
<DOC>
public defn ddr4-get-default-trace-impedance () -> [Toleranced, Toleranced, Toleranced, Toleranced] :
  [ 90.0 +/- (5 %) ; CLK
   100.0 +/- (5 %) ; DQS
    50.0 +/- (5 %) ; DQ
    45.0 +/- (5 %)]; CMD/CTRL/ALERT


doc: \<DOC>
DDR4 SI Constraint Type

This derives from the whole data lane constraint as most of the dq signals 
are single-ended but referenced to the dqs pairs. The remainder of the signals are
constrained to the CK pair. The constraints are:

    0.0 +/-    1.0e-12   ; Intra-pair skew match of CK is +/- 1 ps
    0.0 +/-    1.0e-12   ; Intra-pair skew match of DQS is +/- 1 ps
  -85.0e-12 +935.0e-12   ; Skew match between CK.P and DQS.P -85 ps to 935 ps
    0.0 +/-    3.5e-12   ; Skew match between DQ and DQS.P within a byte lane is +/- 3.5 ps
    0.0 +/-   20.0e-12   ; Skew match between A[17] A[13:0] and CK.P +/- 20 ps
    0.0 +/-   20.0e-12   ; Skew match between RAS_n, CAS_n, WE_n, and CK.P is +/- 20 ps
    0.0 +/-   20.0e-12   ; Skew match between BA[1:0], BG[1:0] and CK.P is +/- 20 ps
    0.0 +/-   20.0e-12   ; Skew match between CMD/ADDR/CTRL within a channel is +/- 20 ps
    0.0 +/-   20.0e-12   ; Skew match between ACT_n, CKE, CS_n, ODT, PAR and CK.P is +/- 20 ps

The `constrain` function for this type expects two compatible `ddr4-b` types.
    ck-rs:DifferentialRoutingStructure
    dqs-rs:DifferentialRoutingStructure
    dq-rs:RoutingStructure
    rs:RoutingStructure ) -> DDR4-Constraint:

<DOC>
public defstruct DDR4-Constraint <: SI-Constraint :
  doc: \<DOC>
  Channel Bit Width
  <DOC>
  width:DDR4-width
  doc: \<DOC>
  Topology of memory channel
  <DOC>
  topology:DDR4-topology
  doc: \<DOC>
  Channel Rank
  <DOC>
  rank:DDR4-rank
    doc: \<DOC>
  CK Intra-pair Timing Skew Constraint in Seconds
  <DOC>
  skew-ck:Toleranced with :
    default => 0.0 +/- 1.00e-12
  doc: \<DOC>
  DQS Intra-pair Timing Skew Constraint in Seconds
  <DOC>
  skew-dqs:Toleranced with :
    default => 0.0 +/- 1.00e-12
  doc: \<DOC>
  CK.P to DQS.P Inter-signal Timing Skew Constraint in Seconds
  <DOC>
  skew-ck-dqs:Toleranced with :
    default => min-max(-85.0e-12 935.0e-12)
  doc: \<DOC>
  DQ to DQS Inter-pair Timing Skew Constraint in Seconds
  <DOC>
  skew-dq-dqs:Toleranced with :
    default => 0.0 +/- 3.50e-12
  doc: \<DOC>
  DM_n to DQS.P Timing Skew Constraint in Seconds
  <DOC>
  skew-dm-dqs:Toleranced with:
    default => 0.0 +/- 3.50e-12 ; Same as DQ timing
  doc: \<DOC>
  CMD/ADDR/CTRL to CK Inter-pair Timing Skew Constraint in Seconds
  <DOC>
  skew-cmd-addr-ctrl-ck:Toleranced with :
    default => 0.0 +/- 20.0e-12
  doc: \<DOC>
  CMD, ADDR, CTRL (w/o CK) Intra-group Timing Skew Constraint in Seconds
  <DOC>
  skew-cmd-addr-ctrl:Toleranced  with:
    default =>  0.0 +/- 10.0e-12
  doc: \<DOC>
  Diff-Pair Max Loss Limit Constraint in dB
  <DOC>
  loss:Double with:
    ensure => ensure-positive!,
    default => 5.0
  doc: \<DOC>
  Differential Routing Structure for CK  [90.0 +/- (5 %)]
  <DOC>
  diff-ck-rs:DifferentialRoutingStructure
  doc: \<DOC>
  Differential Routing Structure for DQS [100.0 +/- (5 %)]
  <DOC>
  diff-dqs-rs:DifferentialRoutingStructure
  doc: \<DOC>
  Single-Ended Routing Structure for each DQ signal [50.0 +/- (5 %)]
  <DOC>
  se-dq-rs:RoutingStructure
  doc: \<DOC>
  Single-Ended Routing Structure for all other SE signal [45.0 +/- (5 %)]
  <DOC>
  se-rs:RoutingStructure

with:
  keyword-constructor => true
  constructor => #DDR4-Constraint


doc: \<DOC>
Constructor for the DDR4 Link Constraint
@param ck-rs Differential Routing Structure constraints for CK signals
@param dqs-rs Differential Routing Structure constraints for DQS signals
@param dq-rs Routing Structure constraints for DQ signals
@param rs Routing Structure constraints for remaining signals (CMD/CTRL/ADDR)
<DOC>
public defn DDR4-Constraint (
    width:DDR4-width
    topology:DDR4-topology
    rank:DDR4-rank
    diff-ck-rs:DifferentialRoutingStructure
    diff-dqs-rs:DifferentialRoutingStructure
    se-dq-rs:RoutingStructure
    se-rs:RoutingStructure ) -> DDR4-Constraint:
  DDR4-Constraint(
    width = width
    topology = topology
    rank = rank
    diff-ck-rs = diff-ck-rs
    diff-dqs-rs = diff-dqs-rs
    se-dq-rs = se-dq-rs
    se-rs = se-rs
  )

doc: \<DOC>
Constrain a DDR4 Link assuming that it is a discrete link (not DIMM)

@param cst Constraint Object
@param src Source End Point - must be of `ddr4-b` type
@param dst Destination End Point - must be of `ddr4-b` type and match
the parameterization of `src`, including width.
<DOC>
public defmethod constrain (cst:DDR4-Constraint, src:JITXObject, dst:JITXObject) -> False :
  inside pcb-module:

    ; val iwidth = width-to-int(width(cst))
    val ilane  = width-to-lane(width(cst))
    val irank  = rank-to-int(rank(cst))
    ; val topo   = topology(cst) ; not sure how to use this atm

    val cst-ck  = DiffPair-Constraint(skew = skew-ck(cst)  loss = loss(cst) route-struct = diff-ck-rs(cst))
    val cst-dqs = DiffPair-Constraint(skew = skew-dqs(cst) loss = loss(cst) route-struct = diff-dqs-rs(cst))

    val guide-ck  = src.ctl.CK.P => dst.ctl.CK.P
    diffpair-constrain(cst-ck, src.ctl.CK, dst.ctl.CK)

    ; ex. for x8,  i goes from 0 to 1, so all of the byte lanes are individually constrained
    ; ex. for x16, i goes from 0 to 2, so all of the byte lanes are individually constrained
    ; ex. for x72, i goes from 0 to 9, so all of the byte lanes are individually constrained
    for i in 0 to ilane do :
      val guide-dqs = src.data.DQS[i].P => dst.data.DQS[i].P
      diffpair-constrain(cst-dqs, src.data.DQS[i], dst.data.DQS[i])
      ; constrain DQS with respect to CK
      timing-window(skew-ck-dqs(cst), guide-ck, guide-dqs)
      ; constrain DQ with respect to DQS
      val bs = i * 8
      val be = bs + 8
      for j in bs to be do :
        val target-dq = src.data.DQ[j] => dst.data.DQ[j]
        timing-window(skew-dq-dqs(cst), guide-dqs, target-dq)
        structure(target-dq) = se-dq-rs(cst)
        max-loss(loss(cst), target-dq)

      ; Add DM_n constraints
      val target-dm = src.data.DM_n[i] => dst.data.DM_n[i]
      timing-window(skew-dm-dqs(cst), guide-dqs, target-dm)
      structure(target-dm) = se-dq-rs(cst)
      max-loss(loss(cst), target-dm)

    ; now constrain addr/cmd/ctrl signals (1x per bus)
    ; there are two constraints to be applied:
    ; First is versus CK and is +/- 20 ps
    ; Second is versus the other signals in the same group and is +/- 10 ps
    ; let's pick an arbitrary signal to serve as the guide for the overall CMD/ADDR/CTL group
    val guide-cac-group = src.ctl.CKE => dst.ctl.CKE
    ; now back to our regularly scheduled program
    val target-cke = src.ctl.CKE => dst.ctl.CKE
    timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-cke)
    ; no need for timing-window for the CKE signal versus guide-cac-group as it's defining the group timing constraint
    structure(target-cke) = se-rs(cst)
    max-loss(loss(cst), target-cke)
    for j in 0 to 17 do :
      val target-addr = src.ctl.A[j] => dst.ctl.A[j]
      timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-addr)
      timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-addr)
      structure(target-addr) = se-rs(cst)
      max-loss(loss(cst), target-addr)

    val target-act = src.ctl.ACT_n => dst.ctl.ACT_n
    timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-act)
    timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-act)
    structure(target-act) = se-rs(cst)
    max-loss(loss(cst), target-act)
    for j in 0 to 2 do :
      val target-bg = src.ctl.BG[j] => dst.ctl.BG[j]
      timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-bg)
      timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-bg)
      structure(target-bg) = se-rs(cst)
      max-loss(loss(cst), target-bg)
      val target-ba = src.ctl.BA[j] => dst.ctl.BA[j]
      timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-ba)
      timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, guide-ba)
      structure(target-ba) = se-rs(cst)
      max-loss(loss(cst), target-ba)
    for j in 0 to irank do:
      val target-cs = src.ctl.CS_n[j] => dst.ctl.CS_n[j]
      timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-cs)
      timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-cs)
      structure(target-cs) = se-rs(cst)
      max-loss(loss(cst), target-cs)
    val target-reset = src.ctl.RESET_n => dst.ctl.RESET_n
    timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-reset)
    timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-reset)
    structure(target-reset) = se-rs(cst)
    max-loss(loss(cst), target-reset)
    val target-odt = src.ctl.ODT => dst.ctl.ODT
    timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-odt)
    timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-odt)
    structure(target-odt) = se-rs(cst)
    max-loss(loss(cst), target-odt)
    val target-par = src.ctl.PAR => dst.ctl.PAR
    timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-par)
    timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-par)
    structure(target-par) = se-rs(cst)
    max-loss(loss(cst), target-par)
    val target-alert = src.ctl.ALERT_n => dst.ctl.ALERT_n
    timing-window(skew-cmd-addr-ctrl-ck(cst), guide-ck, target-alert)
    timing-window(skew-cmd-addr-ctrl(cst), guide-cac-group, target-alert)
    structure(target-alert) = se-rs(cst)
    max-loss(loss(cst), target-alert)


public defn connect-DDR4 (src:JITXObject dst:JITXObject -- width:DDR4-width = DDR4-x16 topology:DDR4-topology = FlyBy rank:DDR4-rank = SingleRank diff-ck-rs:DifferentialRoutingStructure diff-dqs-rs:DifferentialRoutingStructure dq-rs:RoutingStructure rs:RoutingStructure) :
  inside pcb-module :
    val ddr4-cst = DDR4-Constraint(width = width, topology = topology, rank = rank, diff-ck-rs = diff-ck-rs, diff-dqs-rs = diff-dqs-rs, se-dq-rs = dq-rs, se-rs = rs)
    constrain-topology(src, dst, ddr4-cst)

doc: \<DOC>
@brief Returns address mapping depending on the topology for each address pin that can be permuted
Memory Controller Pin	| DRAM Pin (Non-Mirrored)	| DRAM Pin (Mirrored)
A3	| A3	| A4
A4	| A4	| A3
A5	| A5	| A6
A6	| A6	| A5
A7	| A7	| A8
A8	| A8	| A7
A11	| A11 | A13
A13	| A13 | A11
BA0	| BA0 | BA1
BA1	| BA1 | BA0 ; this is optional depending on the memory size/rank
BG0 | BG0 | BG1
BG1 | BG1 | BG0 ; this is optional depending on the memory size/rank
<DOC>
; public defn DDR4-Topology-address-map (a:JITXObject topo:DDR4-topology) -> JITXObject:
;   switch(a) :
;      A[3] : if topo == ClamShell  : A[4] else :  A[3]
;      A[4] : if topo == ClamShell  : A[3] else :  A[4]
;      A[5] : if topo == ClamShell  : A[6] else :  A[5]
;      A[6] : if topo == ClamShell  : A[5] else :  A[6]
;      A[7] : if topo == ClamShell  : A[8] else :  A[7]
;      A[8] : if topo == ClamShell  : A[7] else :  A[8]
;     A[11] : if topo == ClamShell : A[13] else : A[11]
;     A[13] : if topo == ClamShell : A[11] else : A[13]
;     BA[0] : if topo == ClamShell : BA[1] else : BA[0]
;     BA[1] : if topo == ClamShell : BA[0] else : BA[1]
;     BG[0] : if topo == ClamShell : BG[1] else : BG[0]
;     BG[1] : if topo == ClamShell : BG[0] else : BG[1]
;     else :
;       println("Attempting to use unknown address (%_) for mapping" % [a])
;       false

