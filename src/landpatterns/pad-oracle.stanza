doc: \<DOC>
@title Pad Oracle
@brief How & Where to Place Pads
@desc

When building complex landpatterns, we are often faced with
cases where the package for a particular component does
something out of the ordinary. You will often run into this
when looking at BGA packages where some subset of the balls
in a grid may be depopulated. Sometimes this is pretty
straight forward like for a thermally enhanced BGA pattern:

TODO - Figure here showing a thermally enhanced BGA

Other times, it can be more off the beaten path:

TODO - Figure here showing the Dialog chip with offset
  sub-grid of balls.

Regardless, we need tools to instructs the JITX environment
how to place the pads we need for a particular component. This
is where the "Pad Oracle" comes in.

We're not talking about [Soothsayers](https://en.wikipedia.org/wiki/Fortune-telling) - we're
talking about a piece of code that tells the land pattern generator:

1.  Whether or not to place a pad at a particular location.
2.  What shape of pad to place at a particular location.

In order for the Oracle to provide good guidance, we have to
have a common understanding between the generator and the oracle:

1.  The pads for a landpattern are generally going to be in a grid of some sort.
  1.  BGA packages have an obvious 2D grid.
  2.  Quad Packages (QFP, QFN, etc) also have a 2D grid but it isn't quite as obvious.
  3.  The Pad Oracle makes the assumption that the pads of a component are arranged in
  a 2D grid with rows and columns.
  4.  The Pad Oracle assumes that pin 1 is always column=0, row=0.
2.  A common shape characteristic
  1.  Many landpatterns use Rectangles for the shape of their pads.
  2.  Sometimes we might want to use `RoundedRectangles` or `Capsule`.
  3.  The Pad Oracle makes the assumption that each pad's geometry will be described
  by a {@link Dims} object. This means that a if we want to provide different shapes,
  we have to shim them into accepting a `Dims` object.
  4.  Shape Orientation - The Pad Oracle doesn't actually care about this but the
  shapes generated by it need to align with the package's needs. The Pad Oracles
  shapes will be aligned with the Dims object. The Package's land pattern generator
  is responsible for making sure that the `x` dimension of the shape corresponds with
  the `lead-length` direction, andn the `y` dimension corresponds with the `lead-width` direction.

<DOC>
#use-added-syntax(jitx)
defpackage jsl/landpatterns/pad-oracle:
  import core
  import jitx

doc: \<DOC>
Pad Oracle Base Type

This defines the interface for a Pad Oracle. The Pad Oracle
is consulted by the landpattern generator when determing
what pads to create and what shape those pads should have.
<DOC>
public deftype PadOracle

doc: \<DOC>
Check if this package grid location is active.

In this context, `active` means that there should be a copper
pad at this location. `inactive` means that no copper pad should be
placed at this location.

@param x Pad Oracle (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Pad Grid location is Active.
<DOC>
public defmulti active? (x:PadOracle, row:Int, column:Int) -> True|False

doc: \<DOC>
Retrieve the Shape Generator for this Position

@param x Pad Oracle (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Shape Generator function with declared signature. This function
will accept the following arguments:

-  Dims - Size of the generated pad

This function will return a `Shape` object with those properties. Note that
the shape should have its own internal `Pose` object so that this method
could add a custom offset if needed.
<DOC>
public defmulti shape-generator (x:PadOracle, row:Int, column:Int) -> (Dims -> Shape)|False

doc: \<DOC>
Pad Oracle that always returns a Shape Converter

This is a default implementation of the PadOracle interface
for swapping a particular shape for all pads in a landpattern.

This is useful for when you don't want to use `Rectangle`
(the typical default) and you want to replace it with
say `RoundedRectangle`.
<DOC>
public defstruct ShapeOracle <: PadOracle :
  shaper:(Dims -> Shape)

public defmethod active? (x:ShapeOracle, row:Int, column:Int) -> True|False :
  true

public defmethod shape-generator (x:ShapeOracle, row:Int, column:Int) -> (Dims -> Shape)|False:
  if active?(x, row, column): shaper(x)
  else: false

public val rect-shaper:(Dims -> Shape) = Rectangle ;  {Rectangle(_0)}

public val RectangleOracle = ShapeOracle(rect-shaper)

public defn round-rect-shaper (radius:Double) -> (Dims -> Shape) :
  {RoundedRectangle(x(_0), y(_0), radius)}

public defn RoundedRectangleOracle (radius:Double) -> ShapeOracle :
  ShapeOracle( round-rect-shaper(radius) )

; TODO ChamferredRectangle
; TODO Capsule

public defstruct Pin1-Oracle <: PadOracle :
  pin1-shaper:(Dims -> Shape)
  shaper:(Dims -> Shape)

public defmethod active? (x:Pin1-Oracle, row:Int, column:Int) -> True|False :
  true

public defmethod shape-generator (x:Pin1-Oracle, row:Int, column:Int) -> (Dims -> Shape)|False:
  if active?(x, row, column):
    if column == 0 and row == 0: pin1-shaper(x)
    else: shaper(x)
  else: false

; TODO - Corner Pin Shapers
;  Make different pad shapes (possibly with pose offsets)
;  in the corner pads of say a QFN or QFP
