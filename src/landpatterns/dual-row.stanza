#use-added-syntax(jitx)
defpackage jsl/landpatterns/dual-row:
  import core
  import jitx
  import jitx/commands

  import jsl/design/settings
  import jsl/landpatterns/helpers
  import jsl/landpatterns/packages
  import jsl/landpatterns/numbering
  import jsl/landpatterns/pads
  import jsl/landpatterns/pad-planner
  import jsl/landpatterns/leads
  import jsl/landpatterns/IPC
  import jsl/landpatterns/VirtualLP

val DUAL-ROW-COLS = 2

; TODO - Refactor this as a separate generator
public defn draw-pol-marker (locs:Tuple<Pose>,
                             part-sz:Dims,
                             pad-sz:Dims,
                             ) :
  inside pcb-landpattern :
    ; TODO - this is used differently - no current-rules call
    val mask-reg        = clearance(SolderMaskRegistration)
    val silk-mask-space = clearance(MinSilkSolderMaskSpace)
    val min-silk        = clearance(MinSilkscreenWidth)

    val pad-loc = center(locs[0])
    val pol-x = min(-0.5 * x(part-sz), x(pad-loc) - 0.5 * x(pad-sz))
    val pol-y = max( 0.5 * y(part-sz), y(pad-loc) + 0.5 * y(pad-sz))
    val line-length = 2.0 * min-silk

    val dist = mask-reg + silk-mask-space + min-silk * 0.5 + 0.01
    val line = Line(min-silk, [Point(-0.5 * line-length, 0.0), Point(0.5 * line-length, 0.0)])
    layer(Silkscreen("pol", Top)) = loc(pol-x, pol-y + dist) * line


doc: \<DOC>
Generator for a dual-row SMD Landpattern

This generator supports components like SOIC, SOP, SOT-23,
DFN/SON, etc.

@param num-leads Number of leads
@param pitch
@param lead
@param lead-span
@param pkg-body
@param pose
@param pad-planner
@param num-scheme
@param density-level

<DOC>
public defn build-dual-row-smd-landpattern (
  vp:VirtualLP,
  num-leads:Int,
  pitch:Double,
  lead:SMT-Lead,
  lead-span:Toleranced,
  pkg-body:PackageBody,
  --
  pad-planner:PadPlanner         = RectanglePadPlanner,
  num-scheme:Numbering           = Std-IC-Numbering(num-leads),
  density-level:DensityLevel     = DENSITY-LEVEL,
  with-pol-marker?:True|False    = true,
  thermal-lead?:False|Shape      = false
):
  ensure-even-positive!("dual-row:num-leads", num-leads),
  ensure-positive!("dual-row:pitch", pitch),
  ensure-positive!("dual-row:lead-span", lead-span),

  val ipc = pad-constraints(lead, lead-span, density-level = density-level)
  val pad-size = pad-size(ipc)

  val rows = num-leads / DUAL-ROW-COLS

  defn gen-pad-info () -> Seq<VirtualPad> :
    val delta = Dims(Gmin(ipc) + x(pad-size), pitch)
    val grid = to-seq $ grid-locs(rows, DUAL-ROW-COLS, x(delta), y(delta), false)
    for c in 0 to DUAL-ROW-COLS seq-cat:
      for (r in 0 to rows, pos in grid) seq?:
        val pad-id = to-pad-id(num-scheme, r, c)
        val pad-gen? = pad-generator(pad-planner, r, c)
        match(pad-gen?):
          (_:False): None()
          (pad-gen):
            val cls = [
              "pad",
              to-string("col-%_" % [c]),
              to-string("row-%_" % [r])
            ]
            One $ VirtualPad(pad-id, pad-gen(pad-size), pos, class = cls)

  append-all(vp, gen-pad-info())
  match(thermal-lead?:Shape):
    append(vp, VirtualPad(num-leads + 1, smd-pad(thermal-lead?), loc(0.0, 0.0), class = ["pad", "thermal"]))




