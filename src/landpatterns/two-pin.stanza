doc: \<DOC>
@title Two-Pin Landpatterns
@brief Generators & Landpatterns for Two-Pin Components
@desc
  This package contains generators and `pcb-landpattern` definitions for
generic two-pin components like resistors, capacitors, etc.

Entities in this package are typically defined in matching pairs:
1.  `make-*-landpattern` - This is a generator that can be run from within a `pcb-landpattern` definition
2.  `*-landpattern` - A landpattern definition that makes use of the associated generator `make-*-landpattern`.

All units for the functions in this package are in millimeters.

## Component Case Sizes

The IPC two-pin SMT component landpatterns can be specified using
a case name. Below are the available case names:

TODO - table with 3 columns:
  Imperial
  Metric
  Wide Variants


<DOC>
#use-added-syntax(jitx)
defpackage jsl/landpatterns/two-pin:
  import core
  import math

  import jitx
  import jitx/commands

  import jsl/design/settings
  import jsl/landpatterns/helpers
  import jsl/landpatterns/pads
  import jsl/landpatterns/IPC
  import jsl/landpatterns/leads
  import jsl/geometry/LineRectangle
  import jsl/errors
  import jsl/landpatterns/leads
  import jsl/landpatterns/two-pin-table

  ; Start of Forwards
  forward jsl/landpatterns/two-pin/SMT


; TODO - Used in `db-parts.stanza` and `symbols.stanza`
public pcb-landpattern dummy-landpattern (n:Int, courtyard:[Double, Double]) :
  val r = (max(courtyard[0], courtyard[1]) - 0.2) / 2.0
  for i in 0 to n do :
    var theta = (2.0 * PI / to-double(n)) * to-double(i) + PI
    pad p[i + 1] : smd-pad(Circle(to-radius $ 0.05)) at loc(r * cos(theta), r * sin(theta))

  layer(Courtyard(Top)) = Rectangle(courtyard[0], courtyard[1])
  layer(Silkscreen("f-silk", Top)) = LineRectangle(courtyard[0], courtyard[1])
  ref-label()
  name = to-string("DUMMY-%_" % [n])


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Through-Hole Landpatterns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Helper function to compute the pad and hole size of through hoel components
defn pth-pad-sizes (lead-diameter:Toleranced, density-level:DensityLevel) :
  val min-outer-layer-pad-size = MIN-OUTER-LAYER-PAD-SIZE
  val max-hole-size-tolerance  = MAX-HOLE-SIZE-TOLERANCE
  val min-hole-size-tolerance  = MIN-HOLE-SIZE-TOLERANCE
  val hole-position-tolerance  = HOLE-POSITION-TOLERANCE

  ; Lookup the max/min hole to lead diameter
  ; TODO - where do these numbers come from ?
  val [max-h2l, min-h2l] = switch(density-level) :
    DensityLevelA: [0.70, 0.25]
    DensityLevelB: [0.70, 0.20]
    DensityLevelC: [0.60, 0.15]

  ; Compute the hole size. This will be the average of the maximum
  ; and minimum possible hole sizes given the design rules.
  val max-hole-diam = min-value(lead-diameter) - max-hole-size-tolerance + max-h2l
  val min-hole-diam = max-value(lead-diameter) + min-hole-size-tolerance + min-h2l
  val hole-diameter = 0.5 * (max-hole-diam + min-hole-diam)

  ; Compute the pad diameter
  val pad-diameter = hole-diameter + maximum([
      max-hole-size-tolerance + 0.5,
      max-hole-size-tolerance + hole-position-tolerance + 50.0e-6
      min-outer-layer-pad-size,
  ])
  [pad-diameter, hole-diameter]

; Helper function for two-pin through-hole components, to place the polarity marker
; TODO - why does this not use `PlusSymbol`
defn two-pin-th-polarity-marker (cmp-sz:Dims, pad-diameter:Double, lead-spacing:Double) :
  inside pcb-landpattern:
    val min-silk-width = clearance(current-rules(), MinSilkscreenWidth)
    val min-silk-solder-mask-space = clearance(current-rules(), MinSilkSolderMaskSpace)
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)

    val line-length = 3.0 * min-silk-width
    val line = Line(min-silk-width, [Point(0.0, 0.0),
                                     Point(line-length, 0.0)])
    val dist = solder-mask-registration + min-silk-solder-mask-space + min-silk-width * 0.5 + 0.01
    val pad-x = -0.5 * pad-diameter
    val pad-y =  0.5 * pad-diameter + 0.5 * lead-spacing
    val cmp-x = -0.5 * x(cmp-sz)
    val cmp-y =  0.5 * y(cmp-sz)

    val pol-x = min(pad-x, cmp-x)
    val pol-y = max(pad-y, cmp-y) + dist
    layer(Silkscreen("pol", Top)) = loc(pol-x, pol-y) * line
    val pol-x-2 = pol-x - line-length * 0.5 + 1.5 * min-silk-width
    layer(Silkscreen("pol", Top)) = loc(pol-x-2, pol-y, -90.0) * line


; Generate a land pattern for a two-pin radial through hole component
; TODO - Length and Width here are reversed from the SMT variant according
;   to the comment.
; TODO - why does this not have a `height` ? Even just an envelop height ?
;    ideally a diameter so that we can create a 3D model ?
; TODO - Why no 3d model here ?
doc: \<DOC>
Generator for creating two-pin Radial Landpatterns
TODO - Create Mechanical Drawing for the dimensions as an SVG
@param length
@param width
@param lead-spacing Center-To-Center distance between the leads of the component.
@param lead-diameter Diameter of the electrical leads of the device.
Both leads are assumed to be the same size.
@param density-level Board Density Level Setting for this component. By default, the
design level {@link DENSITY-LEVEL} value is used.
@param polarized? Draw polarity markings and use the `a/c` pin
nomenclature instead of `p[1 through 2]`. By default this is false.
<DOC>
public defn make-two-pin-radial-landpattern (
  length:Toleranced, ; the length of the component (x direction)
  width:Toleranced,  ; the width of the component (y direction)
  lead-spacing:Double,
  lead-diameter:Toleranced,
  --
  density-level:DensityLevel = DENSITY-LEVEL
  polarized?:True|False = false,
  ) :
  inside pcb-landpattern:
    ;------------------------------------------------------------
    ; Compute the pad definition
    val [pad-diameter, hole-diameter] = pth-pad-sizes(lead-diameter, density-level)
    val pad-def = pth-pad(hole-diameter, pad-diameter)

    ;------------------------------------------------------------
    ; Place the pads
    ; TODO - Use square pad for positive pad in a polarized
    ;   component (capacitor)
    place-pads(polarized?, lead-spacing, pad-def)

    ;------------------------------------------------------------
    ; Compute the courtyard
    val courtyard-excess = 0.75
    val max-envelope = Dims(max-value(length), max-value(width))
    val cy-sz = enlarge{_, courtyard-excess} $ max-envelope

    layer(Courtyard(Top))    = Rectangle(cy-sz)
    layer(Courtyard(Bottom)) = Rectangle(cy-sz)
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)
    ref-label(loc(0.5 * x(cy-sz) + min-silkscreen-text-height, 0.0, 270.0))

    ; place the polarity marker, if necessary
    if polarized?:
      two-pin-th-polarity-marker(max-envelope, pad-diameter, lead-spacing)

doc: \<DOC>
Generate a land pattern for a two-pin radial through-hole component
TODO - Create Mechanical Drawing for the dimensions as an SVG
@param diameter Diameter of a radially-symmetric component body.
@param lead-spacing Center-To-Center distance between the leads of the component.
@param lead-diameter Diameter of the electrical leads of the device.
Both leads are assumed to be the same size.
@param density-level Board Density Level Setting for this component. By default, the
design level {@link DENSITY-LEVEL} value is used.
@param polarized? Draw polarity markings and use the `a/c` pin
nomenclature instead of `p[1 through 2]`. By default this is false.
<DOC>
public defn make-two-pin-radial-landpattern (
  diameter:Toleranced,
  lead-spacing:Double,
  lead-diameter:Toleranced,
  --
  density-level:DensityLevel = DENSITY-LEVEL
  polarized?:True|False = false,
  ) :
  make-two-pin-radial-landpattern(
    diameter, diameter,
    lead-spacing, lead-diameter,
    polarized? = polarized?
    density-level = density-level
  )

doc: \<DOC>
Two-pin Radial Landpattern Definition
TODO - Create Mechanical Drawing for the dimensions as an SVG
@param length
@param width
@param lead-spacing Center-To-Center distance between the leads of the component.
@param lead-diameter Diameter of the electrical leads of the device.
Both leads are assumed to be the same size.
@param density-level Board Density Level Setting for this component. By default, the
design level {@link DENSITY-LEVEL} value is used.
@param polarized? Draw polarity markings and use the `a/c` pin
nomenclature instead of `p[1 through 2]`. By default this is false.
<DOC>
public pcb-landpattern two-pin-radial-landpattern (
  length:Toleranced,
  width:Toleranced,
  lead-length:Toleranced,
  lead-diameter:Toleranced,
  --
  density-level:DensityLevel = DENSITY-LEVEL,
  polarized?:True|False = false
  ):
  name = to-string("RADIAL-L%_-W%_-P%_" % [typ-value(length), typ-value(width), typ-value(lead-length)])

  make-two-pin-radial-landpattern(
    length, width,
    lead-length, lead-diameter,
    density-level = density-level,
    polarized? = polarized?,
  )

doc: \<DOC>
Two-pin radial landpattern definition
TODO - Create Mechanical Drawing for the dimensions as an SVG
@param diameter Diameter of a radially-symmetric component body.
@param lead-spacing Center-To-Center distance between the leads of the component.
@param lead-diameter Diameter of the electrical leads of the device.
Both leads are assumed to be the same size.
@param density-level Board Density Level Setting for this component. By default, the
design level {@link DENSITY-LEVEL} value is used.
@param polarized? Draw polarity markings and use the `a/c` pin
nomenclature instead of `p[1 through 2]`. By default this is false.
<DOC>
public pcb-landpattern two-pin-radial-landpattern (
  diameter:Toleranced,
  lead-length:Toleranced,
  lead-diameter:Toleranced,
  --
  density-level:DensityLevel = DENSITY-LEVEL,
  polarized?:True|False = false
  ):
  name = to-string("RADIAL-L%_-W%_-P%_" % [typ-value(length), typ-value(width), typ-value(lead-length)])

  make-two-pin-radial-landpattern(
    diameter,
    lead-length, lead-diameter,
    density-level = density-level,
    polarized? = polarized?,
  )

doc: \<DOC>
@see IPC-A-610 Section 7.1.2, Table 7-1 Lead Bend Radius
<DOC>
defn compute-default-bend-radius (lead-diameter:Toleranced) -> Double:
  val diam = typ-value(lead-diameter)
  if diam < 0.8:
    diam
  else if diam < 1.2:
    1.5 * diam
  else:
    2.0 * diam

; Default Weld Bead Offset on Axial Lead Components.
;   I'm assuming that most components don't have this by default.
val DEF-WELD-OFFSET = 0.0
; Default Bend Length - this the distance from either the
;   component body or the weld bead where the bend will start.
val DEF-BEND-LENGTH = 1.0 ; mm

doc: \<DOC>
Generate a horizontal land pattern for a two-pin axial through-hole component
TODO - Create Mechanical Drawing for the dimensions as an SVG
TODO - We need to differentiate between horizontal and the perpendicular method of placing
   axial components. (See IPC2221 Figure 8-26)
@param body-length Length of the axial component's body (ie, not including the leads)
@param body-diameter Diameter of the axial component's body.
@param lead-diameter Diameter of the electrical leads on either side of the body.
@param weld Distance from the component body to the weld-bead on the electrical lead.
  By default, this value is 0.0 and assumes that the component does not have a weld-bead.
@param bend-length Length from the body or weld-bead where the bend will be started.
@param bend-radius Radius of curvature applied to the lead. The default value is computed
  according to IPC-A-610, Section 7.1.2. Value is in mm
@param density-level Board Density Level Setting for this component. By default, the
design level {@link DENSITY-LEVEL} value is used.
@param polarized? Draw polarity markings and use the `a/c` pin
nomenclature instead of `p[1 through 2]`. By default this is false.
<DOC>
public defn make-two-pin-axial-landpattern (
  body-length:Toleranced,   ; The length of the component
  body-diameter:Toleranced, ; The diameter of the component
  lead-diameter:Toleranced, ; the diameter of the leads of the component
  weld-offset:Double = DEF-WELD-OFFSET,     ; the distance away from the body the leads are bent
  bend-length:Double = DEF-BEND-LENGTH, ; the length of the bend in the leads
  bend-radius:Double = compute-default-bend-radius(lead-diameter), ; the radius of the bend in the leads (mm, not %)
  --
  density-level:DensityLevel = DENSITY-LEVEL
  polarized?:True|False = false,
  ) :
  inside pcb-landpattern:
    ;------------------------------------------------------------
    ; Compute the pad definition
    val [pad-diameter, hole-diameter] = pth-pad-sizes(lead-diameter, density-level)
      val pad-def = pth-pad(hole-diameter, pad-diameter)
    val lead-spacing = typ-value(body-length) + 2.0 * (weld-offset + bend-length + bend-radius)

    ;------------------------------------------------------------
    ; Place the pads
    place-pads(polarized?, lead-spacing, pad-def)

    ;------------------------------------------------------------
    ; Compute the courtyard
    val courtyard-excess = 0.75
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)

    val max-x-dim = max(
      max-value(body-diameter),
      pad-diameter + 2.0 * solder-mask-registration
    )
    val max-y-dim = max(
      max-value(body-length)
      pad-diameter + 2.0 * solder-mask-registration + lead-spacing
    )
    val max-dims = Dims(max-x-dim, max-y-dim)
    val cy-sz = enlarge(max-dims, courtyard-excess)
    layer(Courtyard(Top))    = Rectangle(cy-sz)
    layer(Courtyard(Bottom)) = Rectangle(cy-sz)
    ref-label(loc(0.5 * x(cy-sz) + min-silkscreen-text-height, 0.0, 270.0))

    ; place the polarity label, if necessary
    if polarized?:
      two-pin-th-polarity-marker(Dims(max-value(body-diameter), max-value(body-length)),
                                 pad-diameter, lead-spacing)

doc: \<DOC>
Two-pin Axial Landpattern Definition
TODO - Create Mechanical Drawing for the dimensions as an SVG
TODO - We need to differentiate between horizontal and the perpendicular method of placing
   axial components. (See IPC2221 Figure 8-26)
@param body-length Length of the axial component's body (ie, not including the leads)
@param body-diameter Diameter of the axial component's body.
@param lead-diameter Diameter of the electrical leads on either side of the body.
@param weld Distance from the component body to the weld-bead on the electrical lead.
  By default, this value is 0.0 and assumes that the component does not have a weld-bead.
@param bend-length Length from the body or weld-bead where the bend will be started.
@param bend-radius Radius of curvature applied to the lead. The default value is computed
  according to IPC-A-610, Section 7.1.2. Value is in mm
@param density-level Board Density Level Setting for this component. By default, the
design level {@link DENSITY-LEVEL} value is used.
@param polarized? Draw polarity markings and use the `c,a` pin
nomenclature instead of `p[1 through 2]`. By default this is false.
<DOC>
public pcb-landpattern two-pin-axial-landpattern (
  body-length:Toleranced,
  body-diameter:Toleranced,
  lead-diameter:Toleranced,
  weld-offset:Double = DEF-WELD-OFFSET,
  bend-length:Double = DEF-BEND-LENGTH,
  bend-radius:Double = compute-default-bend-radius(lead-diameter),
  --
  density-level:DensityLevel = DENSITY-LEVEL
  polarized?:True|False = false,
  ) :
  name = to-string("AXIAL-L%_-D%_-P%_" % [typ-value(body-length), typ-value(body-diameter), typ-value(lead-length)])

  make-two-pin-axial-landpattern(
    body-length, body-diameter,
    lead-diameter, weld-offset,
    bend-length, bend-radius,
    density-level = density-level,
    polarized? = polarized?
  )