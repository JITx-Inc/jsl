#use-added-syntax(jitx)
defpackage jsl/landpatterns/silkscreen:
  import core
  import math
  import jitx
  import jitx/commands

  import jsl/design/settings
  import jsl/errors
  import jsl/geometry/box
  import jsl/geometry/LineRectangle
  import jsl/landpatterns/framework

public defn default-silk-width () -> Double :
  clearance(current-rules(), MinSilkscreenWidth)

public defn default-mask-clearance () -> Double :
  clearance(current-rules(), MinSilkSolderMaskSpace)

doc: \<DOC>
Compute the closest corner of the passed Box to the Pin1 position.

This tool is used to determine what to place pin 1
markers in a component's silkscreen.

@param pin-1-pos Position of the Pin 1 pad.
@param outline-box Box that represents the silkscreen
outline of the component.
<DOC>
public defn compute-closest-corner (
  pin-1-pos:Point,
  outline-box:Box
  ):
  val corners = corners(outline-box)

  defn compute-dist (x:Point) -> Double:
    l2-norm(x - pin-1-pos)

  minimum(compute-dist, corners)

doc: \<DOC>
Compute the Corner Anchor Position.

Given a point on the outline box that is closest
to pin 1 - compute the anchor position. For example,
if pin 1 is in the top left and the closest corner is
in the top-left, this would be the `NW` anchor position.
@param closest Closest point on the outline
<DOC>
public defn compute-corner (closest:Point) -> Anchor :
  val angle = atan2(y(closest), x(closest))
  if angle > (PI / 2.0): NW
  else if angle < (- PI / 2.0): SW
  else if angle < 0.0: SE
  else: NE

doc: \<DOC>
Compute the rotation of the shape pattern for a particular anchor

We typically position the triangle marker or pin 1 dot
marker by transforming its base configuration. This means
translating and rotating it to fit in one of the outline
corners.

This method takes the corner anchor position and converts
it to rotation angle for a shape pattern.
<DOC>
public defn corner-to-rotation (corner:Anchor) -> Double :
  switch(corner):
    NW: 0.0
    SW: 90.0
    SE: 180.0
    NE: -90.0

doc: \<DOC>
Create a shape for the triangle corner marker

This is often used in a rectangular outlines for marking the
the pin-1 indication in one of the corners of the outline.

This function creates a shape that is a solid, isosceles right triangle (polygon)
in the lower right quadrant of the XY plane. It is then offset
from the X and Y axis (toward the lower right quandrant) by
half the line-width
<DOC>
public defn create-corner-marker-shape (line-width:Double, marker-height:Double) -> Shape :
  val st-offset = line-width / 2.0
  loc(st-offset, (- st-offset)) * Polygon([
    Point(0.0, 0.0),
    Point(marker-height, 0.0),
    Point(0.0, (- marker-height))
    ])


doc: \<DOC>
Compute the Triangle Marker Shape for Pin-1 outline

@param pin-1-pos Position of the pin 1 pad
@param outline-box Silkscreen outline as a 2D box.
@param line-width Silkscreen line width - primarily
used for positioning and not for drawing lines.
@param max-height Max triangle marker height. This
function attempts to compute a reasonable marker size
based on the component's scale. This is a limiter to
prevent unnecessarily large triangle marker features.
<DOC>
public defn compute-triangle-marker (
  pin-1-pos:Point,
  outline-box:Box,
  line-width:Double,
  max-height:Double = 1.25
  ) -> Shape:

  val closest = compute-closest-corner(pin-1-pos, outline-box)

  ; Compute the Marker Shape & Size
  val marker-size = if contains?(outline-box, pin-1-pos):
    ; Pad is inside the outline - so we need to
    ;  take care that the triangle marker doesn't
    ;  overlap the internal pad
    val diff = closest - pin-1-pos
    abs $ y(diff)
  else:
    val marker-ratio = (15 %)
    val opt1 = y(dims(outline-box)) * marker-ratio
    min(opt1, x(dims(outline-box)))
  val marker-height = min(marker-size, max-height)

  val marker-shape = create-corner-marker-shape(line-width, marker-height)

  ; Compute the angle of the marker depending on
  ;  what corner of the outline the marker is in.
  val corner = compute-corner(closest)
  val rot = corner-to-rotation(corner)

  ; Place the marker in the closest corner.
  val marker-pose = loc(closest, rot)
  marker-pose * marker-shape

doc: \<DOC>
Create a triangle shaped marker in the outline on the silkscreen

This function looks for the outline shape in the virtual artwork
of this VirtualLP node and then attempts to find the corner
of that outline closest to the `pin-1-id` pad of the land pattern.

It then construct a triangle shaped marker and places it in that
corner for a heavy indication of the pin 1 location. This corner
marker will be placed in the silkscreen layer on the same side
of the board as the outline is found.

@param vp Land Pattern scene graph node we will search for the outline
@param pin-1-id This argument accepts either an `Int` or a `Ref` for
identifying the "Pin 1" of the component. If this is an `Int` it will
map to the conventional `p[N]` ref syntax used for land patterns. The
default value is `1`.
@throws ValueError If we find more than one `outline` in the silkscreen,
or if we fail to find the `pin-1-id` pad.

<DOC>
public defn build-outline-pin-1-triangle (
  vp:VirtualLP
  --
  pin-1-id:Int|Ref = 1
  ):

  val outline = get-silkscreen-outline!(vp)
  val o-side = side $ (layer-spec(outline) as Silkscreen)
  val o-sh = shape(outline)

  val pin-1-pad = get-pad-by-ref!(vp, pin-1-id)
  ; Find the corner of the outline nearest to pad 1

  ; The Outline is typically a line rectangle which creates a
  ;  single line. We use this to determine the line width
  ;  so that we can place the marker in the mid-line
  val line-width = match(o-sh):
    (x:Line): width(x)
    (_): default-silk-width()

  val o-box = bounds $ o-sh

  val pin-1-pos = center $ pose(pin-1-pad)

  val marker = compute-triangle-marker(pin-1-pos, o-box, line-width)

  add-artwork(
    vp, Silkscreen("pin-1-marker", o-side),
    marker,
    name = "pin-1-triangle",
    class = "pin-1-marker"
    )


doc: \<DOC>
Create a Pin 1 indicator as a round dot next to the pad

This creates a small circle in the silkscreen directly
above (+Y) the "pin 1" pad of a land pattern.

This function assumes that the space directly above the
pin 1 pad is available to place this circle.
@param vp Virtual Landpattern that will store artwork and
be inspected for pads that match `pin-1-id`. Note that the
pads must already have been added to the land pattern for
this function to work.
@param pin-1-id Indicates which pad by Int or Ref will be
used as the "Pin 1" of the land pattern.
@param dir Direction where to place the dot with respect
to the pin 1 pad. Default value is `Up` (+Y)
@param line-width Used for the radius of the created Circle. By
default this is the minimum silk width from the design rules.
@param mask-clearance Mask clearance rule used to place
the dot sufficiently far away the Pin 1 Pad. Default is
the minimum silk to soldermask clearance pulled from the design rules.
@param side Indicates whether the marker will be drawn on the top
or bottom side of the board. Default is `Top`.
<DOC>
public defn build-smd-pin-1-dot (
  vp:VirtualLP,
  --
  pin-1-id:Int|Ref = 1,
  dir:Dir = Up,
  margin:Double = 0.0,
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
  ):
  ; Draw a circle dot inside the rectangle above pin 1
  val pin-1-pad = get-pad-by-ref!(vp, pin-1-id)

  val pad-loc = pose(pin-1-pad)
  val pad-center = center(pad-loc)

  val smasks = get-layer(pin-1-pad, SolderMask(side))
  if length(smasks) == 0:
    ; This is a very strange error - it means
    ;  that pad 1 of this component doesn't have a soldermask
    ;  opening.
    ; This could happen if the user passed an erroneous `side` argument
    throw $ ValueError("Pin-1 - No Soldermask Opening for Pad on Side: %_" % [side])
  val smask = smasks[0]

  ; Apply the transform so that I can get the
  ;   true "height" of the pad regardless of rotation.
  val smask* = pad-loc * smask
  val height = y $ dims(smask*)
  val y-pos = (height / 2.0) + mask-clearance + line-width + margin
  val width = x $ dims(smask*)
  val x-pos = (width / 2.0) + mask-clearance + line-width + margin

  val offset = switch(dir):
    Up: Point(0.0, y-pos)
    Down: Point(0.0, (- y-pos))
    Right: Point(x-pos, 0.0)
    Left: Point((- x-pos), 0.0)

  val marker-pos = pad-center + offset

  ; TODO - Check that the marker will be visible and not blocked by the package
  ;   body.
  ;
  ; TODO - Check that the marker will not overlap with any existing silkscreen
  ;   that will prevent it from being easily visible.

  add-artwork(vp, Silkscreen("pin-1-marker", side), Circle(marker-pos, line-width), name = "pin-1-dot", class = "pin-1-marker")

doc: \<DOC>
Construct the projected shape of the package body on the board.

@param vp Virtual LP scene graph node - outline will be created here.
@param pkg-body 3D body model for the component
@param density-level Indicates whether we will use MMC, NMC, or LMC
@param line-width width of the line to draw.
@param mask-clearance clearance between soldermask openings and the outline.
<DOC>
public defn construct-pkg-outline (
  vp:VirtualLP, pkg-body:PackageBody
  --
  density-level:DensityLevel = DENSITY-LEVEL
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance()
  ) -> Shape:
  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level)
  val pkg-outline* = fatten(line-width / 2.0, pkg-outline)
  LineRectangle(pkg-outline*, line-width = line-width)

doc: \<DOC>
Construct a silkscreen outline of a component based on the Package Body

@param vp Virtual LP scene graph node - outline will be created here.
@param pkg-body 3D body model for the component
@param density-level Indicates whether we will use MMC, NMC, or LMC
@param line-width width of the line to draw.
@param mask-clearance clearance between soldermask openings and the outline.
@param side Side of the board. Default is `Top`.
<DOC>
public defn create-silkscreen-outline (
  vp:VirtualLP, pkg-body:PackageBody
  --
  density-level:DensityLevel = DENSITY-LEVEL
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance()
  side:Side = Top
  ) -> False :

  val outline-geom = construct-pkg-outline(
    vp, pkg-body,
    density-level = density-level
    line-width = line-width
    mask-clearance = mask-clearance
  )
  ; TODO - I want to use `Difference` here will all of the soldermask openings
  ;  defined by the pads.

  add-silkscreen-outline(vp, outline-geom, side = side)


doc: \<DOC>
Construct the projected shape of the Package Body and Soldermask Pad Openings

The user must create all of the pads associated with this landpattern before
invoking this function.

This function takes the union of the pads and the package body outline
and constructs and overall outline encompassing this shape.

@param vp Virtual LP scene graph node - outline will be created here.
@param pkg-body 3D body model for the component
@param density-level Indicates whether we will use MMC, NMC, or LMC
@param line-width width of the line to draw.
@param mask-clearance clearance between soldermask openings and the outline.
@return `LineRectangle` Shape for the union of the package body and the
pad openings.
<DOC>

public defn construct-overall-outline (
  vp:VirtualLP, pkg-body:PackageBody
  --
  density-level:DensityLevel = DENSITY-LEVEL
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance()
  side:Side = Top
  ) -> Shape:
  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level)
  val pad-outline = bounds(get-pads(vp), layer-spec = SolderMask(side))

  val overall = union(pkg-outline, pad-outline)
  val overall* = fatten(mask-clearance + (line-width / 2.0), overall)

  LineRectangle(overall*, line-width = line-width)


doc: \<DOC>
Construct a silkscreen outline based on the Package Body and Soldermask Pad Openings

The user must create all of the pads associated with this landpattern before
invoking this function.

@param vp Virtual LP scene graph node - outline will be created here.
@param pkg-body 3D body model for the component
@param density-level Indicates whether we will use MMC, NMC, or LMC
@param line-width width of the line to draw.
@param mask-clearance clearance between soldermask openings and the outline.
<DOC>
public defn create-silkscreen-overall-outline (
  vp:VirtualLP, pkg-body:PackageBody
  --
  density-level:DensityLevel = DENSITY-LEVEL
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance()
  side:Side = Top
  ) -> False :

  val outline-geom = construct-overall-outline(
    vp, pkg-body,
    density-level = density-level
    line-width = line-width
    mask-clearance = mask-clearance
    side = side
    )

  add-silkscreen-outline(vp, outline-geom, side = side)


doc: \<DOC>
Determine the dimensions of the package body with Y extension

This function is used to create the minimal package body
outline that we will use to create the horizontal lines
at the extremes on the package body.

This function attempts to make a conservative size box
by accounting for both the package body length and the
location of the soldermask opening of the pads.

This function is typically only useful for dual-row
packages like SOP, SON, SOT, etc.

@param vp Virtual Land Pattern Scene Graph
@param pkg-body Package Body for the IC
@param density-level Density Level for the Package
@param line-width Silkscreen min line width as defined by pcb-rules.
@param mask-clearance Minimum soldermask clearance to silkscreen as defined
by the pcb-rules.
@param side Which side of the board this outline will be created on. It
filters for which pads of the landpattern to inspect.
<DOC>
public defn get-extended-pkg-outline (
  vp:VirtualLP
  pkg-body:PackageBody
  density-level:DensityLevel
  line-width:Double
  mask-clearance:Double
  side:Side
  ) -> Box :
  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level)
  val pkg-outline* = fatten(line-width / 2.0, pkg-outline)

  ; Check to make sure that the pads aren't going to be
  ;  too close to the outline. If so - we adjust them out a
  ;  bit so that we don't violate the minimum clearance rules.
  val pad-outline = bounds(get-pads(vp), layer-spec = SolderMask(side))
  val pad-outline* = fatten(mask-clearance + (line-width / 2.0), pad-outline)

  val diff = dims(pad-outline*) - dims(pkg-outline*)

  ; If we find that the pad outline is larger in Y
  ;   then we expand the box, but only on the dimension
  ;   so that the line is still only the width of the body.
  if y(diff) > 0.0:
    fatten(Point(0.0, y(diff) / 2.0), pkg-outline*)
  else:
    pkg-outline*


public defn construct-pkg-extrema-lines (
  vp:VirtualLP, pkg-body:PackageBody
  --
  density-level:DensityLevel = DENSITY-LEVEL
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance()
  side:Side = Top
  ) -> Shape:
  val pkg-outline = get-extended-pkg-outline(vp, pkg-body, density-level, line-width, mask-clearance, side)
  ; Just take the top and bottom lines - not the sides
  val [sw, se, ne, nw] = corners(pkg-outline)

  Union([
    Line(line-width, [nw, ne])
    Line(line-width, [sw, se])
  ])

public defn create-silkscreen-pkg-extrema-outline (
  vp:VirtualLP, pkg-body:PackageBody
  --
  density-level:DensityLevel = DENSITY-LEVEL
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance()
  side:Side = Top
  ) -> False :
  val outline-geom = construct-pkg-extrema-lines(
    vp, pkg-body,
    density-level = density-level
    line-width = line-width
    mask-clearance = mask-clearance
    side = side
    )
  add-silkscreen-outline(vp, outline-geom, side = side)


doc: \<DOC>
Construct an outline shape of the package body by avoiding overlaps with pads

This function takes an outline (like the outline of the package body)
and computes the set of shapes that can maximally fill that outline
but not overlap with any of the pads in a package.

This function will also obey clearance requirements to prevent DRC
issues.

This function is primarily for supporting dual-row land patterns
like SON, SOP, etc.

@param vp Virtual Land Pattern Scene Graph
@param pkg-body Package Body for the IC
@param density-level Density Level for the Package
@param line-width Silkscreen min line width as defined by pcb-rules.
@param mask-clearance Minimum soldermask clearance to silkscreen as defined
by the pcb-rules.
@param side Which side of the board this outline will be created on. It
filters for which pads of the landpattern to inspect.
@return LineRectangle shape that could be drawn in the silkscreen.
<DOC>
public defn compute-pkg-internal-box (
  vp:VirtualLP,
  pkg-body:PackageBody,
  --
  density-level:DensityLevel = DENSITY-LEVEL
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
  ) -> Shape :

  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level)
  val courtyard? = get-courtyard-boundary(vp, side = side)

  ; Check for overlap between the pad soldermask and the
  ;  current proposed outline. We will then shrink the
  ;  proposed outline until there is at least `mask-clearance`
  ;  on either side.
  val h-shrink = let:
    val col-0-pads = seq{as-VirtualPad, _} $ find-by-class(vp, "col-0")
    val col-1-pads = seq{as-VirtualPad, _} $ find-by-class(vp, "col-1")

    val col-0-outline = bounds(col-0-pads, layer-spec = SolderMask(side))
    val col-1-outline = bounds(col-1-pads, layer-spec = SolderMask(side))

    val interstitial = Box(
      Point(right(col-0-outline), down(col-0-outline)),
      Point(left(col-1-outline), up(col-1-outline))
    )

    val iW = x(dims(interstitial)) - ((2.0 * mask-clearance) + line-width)
    val iP = x(dims(pkg-outline))

    ; Compute the shrinkage that will be applid to
    ;   both sides (if any)
    val diff = (iW - iP) / 2.0
    if diff < 0.0 :
      ; We need to shrink the package outline
      fatten(Point(diff, 0.0), pkg-outline)
    else:
      pkg-outline

  LineRectangle(h-shrink, line-width = line-width)
