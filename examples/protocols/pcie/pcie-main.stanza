#use-added-syntax(jitx)
defpackage jsl/examples/protocols/pcie/main:
  import core
  import collections
  import jitx
  import jitx/commands


  import jsl

  import jsl/examples/protocols/common/example-board
  import jsl/examples/protocols/common/example-components
  import jsl/examples/protocols/pcie/pcie-src


pcb-module pcie-example :

  inst dut1 : jsl/examples/protocols/pcie/pcie-src/module
  inst dut2 : jsl/examples/protocols/pcie/pcie-src/module

  val version = PCIE-V4
  val trace-imped = pcie-get-trace-impedance(version)
  val cst = PCIe-Constraint(version, diff(trace-imped))

  val b-cap = block-cap(220.0e-9)

  ; Setup an example of an active to active connection between
  ;  two ICs (ie not to a connector). In this case, we need
  ;  a null-modem style connection and blocking caps on both rx and
  ;  tx.
  require src-IC : pcie-with-hotplug(1) from dut1
  require dst-IC : pcie-with-hotplug(1) from dut2

  ; TODO - the routing structure is not applying through the node here.

  within [src, dst] = constrain-topology(src-IC, dst-IC, cst):
    for i in indices(src.data.lane) do:
      ;  We reverse the Tx/Rx in a null-modem style for active->active connection.
      val lane-Rx = dst.data.lane[i].TX
      val lane-Tx = dst.data.lane[i].RX

      inst tx-coupler : dp-coupler(b-cap)
      topo-pair(src.data.lane[i].TX => tx-coupler => lane-Tx)
      inst rx-coupler : dp-coupler(b-cap)
      topo-pair(src.data.lane[i].RX => rx-coupler => lane-Rx)

    topo-net(src.data.refclk => dst.data.refclk)
    net (src.control, dst.control)

set-current-design("pcie-example")
setup-board()
; Set the schematic sheet size
set-paper(ANSI-A)

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(pcie-example)

; View the results
view-board()
; view-schematic()
view-design-explorer()
; view-bom(BOM-STD)
