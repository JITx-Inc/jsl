#use-added-syntax(jitx)
defpackage jsl/landpatterns/dual-row:
  import core
  import jitx
  import jitx/commands

  import jsl/design/settings
  import jsl/landpatterns/helpers
  import jsl/landpatterns/packages
  import jsl/landpatterns/numbering
  import jsl/landpatterns/pads
  import jsl/landpatterns/pad-planner
  import jsl/landpatterns/leads
  import jsl/landpatterns/IPC

val DUAL-ROW-COLS = 2

; TODO - Refactor this as a separate generator
public defn draw-pol-marker (locs:Tuple<Pose>,
                             part-sz:Dims,
                             pad-sz:Dims,
                             ) :
  inside pcb-landpattern :
    ; TODO - this is used differently - no current-rules call
    val mask-reg        = clearance(SolderMaskRegistration)
    val silk-mask-space = clearance(MinSilkSolderMaskSpace)
    val min-silk        = clearance(MinSilkscreenWidth)

    val pad-loc = center(locs[0])
    val pol-x = min(-0.5 * x(part-sz), x(pad-loc) - 0.5 * x(pad-sz))
    val pol-y = max( 0.5 * y(part-sz), y(pad-loc) + 0.5 * y(pad-sz))
    val line-length = 2.0 * min-silk

    val dist = mask-reg + silk-mask-space + min-silk * 0.5 + 0.01
    val line = Line(min-silk, [Point(-0.5 * line-length, 0.0), Point(0.5 * line-length, 0.0)])
    layer(Silkscreen("pol", Top)) = loc(pol-x, pol-y + dist) * line


defstruct PadInfo :
  pad-id:Int|Ref
  pad-def:Pad
  loc:Pose

doc: \<DOC>
Generator for a dual-row SMD Landpattern

This generator supports components like SOIC, SOP, SOT-23,
DFN/SON, etc.

@param num-leads Number of leads

<DOC>
public defn make-dual-row-smd-landpattern (
  num-leads:Int,
  pitch:Double,
  lead:SMT-Lead,
  lead-span:Toleranced,
  pkg-body:PackageBody,
  --
  pad-planner:PadPlanner           = RectanglePadPlanner
  num-scheme:Numbering           = Std-IC-Numbering(num-leads),
  density-level:DensityLevel     = DENSITY-LEVEL,
  with-pol-marker?:True|False    = true,
  thermal-lead?:False|Shape      = false
):
  ensure-even-positive!("dual-row:num-leads", num-leads),
  ensure-positive!("dual-row:pitch", pitch),
  ensure-positive!("dual-row:lead-span", lead-span),

  val ipc = pad-constraints(lead, lead-span, density-level = density-level)
  val pad-size = pad-size(ipc)

  val rows = num-leads / DUAL-ROW-COLS

  defn gen-pad-info () -> Seq<PadInfo> :
    val delta = Dims(Gmin(ipc) + x(pad-size), pitch)
    val grid = to-seq $ grid-locs(rows, DUAL-ROW-COLS, x(delta), y(delta), false)
    for c in 0 to DUAL-ROW-COLS seq-cat:
      for (r in 0 to rows, pos in grid) seq?:
        val pad-id = to-pad-id(num-scheme, r, c)
        val pad-gen? = pad-generator(pad-planner, r, c)
        match(pad-gen?):
          (_:False): None()
          (pad-gen):
            One $ PadInfo(pad-id, pad-gen(pad-size), pos)

  inside pcb-landpattern :

    for p in gen-pad-info() do:
      match(pad-id(p)):
        (i:Int):
          pad p[i] : pad-def(p) at loc(p)
        (x:Ref):
          pad x : pad-def(p) at loc(p)

    ; TODO Move this to a different function so that this can be composable?
    ;  - `make-courtyard`
    ;  - Can we be called or overridden more easily.
    ;
    ; I feel like there is an easier way that this:
    ;   Union all of the shapes of all of the pads
    ;   Dims on max union size
    ;   enlarge
    ;   You still need to take max of pkg body envelope and pad union dims.
    ; val [max-y, min-y] = fork-on-seq(seq(y{center(_)}, locs), maximum, minimum)
    ; val lp-sz = enlarge(Dims(Zmax(ipc), y(pad-sz) + max-y - min-y), 2.0 * clearance(SolderMaskRegistration))
    val part-sz = envelope(pkg-body)

    ; val cy-sz = enlarge(max(lp-sz, part-sz), 2.0 * courtyard-excess(fillets))
    ; layer(Courtyard(Top)) = Rectangle(cy-sz)

    ; TODO - move to a separate method - make this composable.
    ; if with-pol-marker? :
    ;   draw-pol-marker(locs, part-sz, pad-size)

    make-thermal-pad(thermal-lead?, num-leads + 1)



