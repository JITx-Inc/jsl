#use-added-syntax(jitx)
defpackage jsl/symbols/box-symbol:
  import algorithm/utils
  import core
  import collections
  import lang-utils
  import pcre

  import jitx
  import jitx/commands
  import jitx/utils/got

  import jsl/ensure
  import jsl/design/Classable
  import jsl/symbols/decorators
  import jsl/symbols/utils
  import jsl/symbols/SymbolDefn
  import jsl/symbols/SymbolNode
  import jsl/symbols/box-symbol/utils
  import jsl/symbols/box-symbol/errors
  import jsl/geometry/box
  import jsl/geometry/LineRectangle
  import math

val DEF_LINE_WIDTH = 0.05
val DEF_PIN_LEN = 1.0
val DEF_FONT_SIZE = 2
val DEF_PAD_REF_SIZE = 0.25
val DEF_PIN_NAME_SIZE = 0.25
; length between pins
val DEF_PIN_PITCH = 0.5
; min length of rows/columns
val DEF_COL_WIDTH = 0
val DEF_ROW_WIDTH = 0
; padding for top and bottom of a cell
val DEF_CELL_TOP_MARGIN = 0.0
val DEF_CELL_BOTTOM_MARGIN = 0.0
val DEF_GROUP_TOP_MARGIN = 0.0
val DEF_GROUP_BOTTOM_MARGIN = 0.0
; length between groups/singleton pins
val DEF_PIN_PADDING = 0.5
val DESIGNATOR_MARGIN = 1.0
val DEF_SHOW_GRID = false

val GRID_SCALE = UNIT-TO-MM / 2.0
val MIN_GRID_NUDGE = 0.5
val SHOW_GRID_ROW = "ROW %_"
val SHOW_GRID_COL = "COL %_"

val TEXT_BORDER_PADDING = 0.2

val GROUP_HEAD_MARGIN_PROP = `group-head-margin
val GROUP_TAIL_MARGIN_PROP = `group-tail-margin

val SYM_PROPS = [
  ROW_PROP
  COL_PROP
  ALIGN_PROP
  SIDE_PROP
  GROUP_PROP
  HEAD_MARGIN_PROP
  TAIL_MARGIN_PROP
  BANK_PROP
]

defn scale (d: Double) -> Double :
  GRID_SCALE * d

; Valid anchors for Left/Right, Up/Down pins
val LR_ANCHORS = [N, C, S]
val UD_ANCHORS = [W, C, E]

defn anchors (s: Dir) :
  match(s) :
    (lr: Left|Right) : LR_ANCHORS
    (ud: Up|Down) : UD_ANCHORS

; Ordering and default anchors for Left/Right, Up/Down pins
defn first-anchor (s: Dir) :
  match(s) :
    (lr: Left|Right) : N
    (ud: Up|Down) : W

defn last-anchor (s: Dir) :
  match(s) :
    (lr: Left|Right) : S
    (ud: Up|Down) : E

defn default-anchor (s: Dir) :
  match(s) :
    (lr:Left|Right) : C
    (ud:Up|Down) : C

defn text-anchor (s: Dir) :
  match(s) :
    (l: Left|Down) : W
    (u: Right|Up) : E

; Takes a seqable of JITXObject and checks that every one of them has
; a port type. They are returned in a vector (stable order) but an exception
; is thrown if one or more of the objects is not of a supported port type
defn check-port-type (objs: Seqable<JITXObject>) -> Vector<JITXObject> :
  val non-ports = Vector<JITXObject>()
  val ports = Vector<JITXObject>()

  for o in objs do :
    match(o) :
      (s:Self) : add(non-ports, s)
      (ns) :
        match(port-type(ns)) :
          (s:SinglePin) : add(ports, ns)
          (b:Bundle|PortArray) : add-all(ports, pins(ns))
          (f): add(non-ports, o)
  if length(non-ports) > 0 :
    throw $ InvalidPortObject(non-ports)
  ports

defn check-non-neg (prop:Symbol, arg:Int) :
  if arg < 0 :
    throw $ NegativeValueProperty("negative val %_ for prop '%_'" % [arg, prop])

defn check-valid-anchor (side:Dir, anchor:Anchor) :
  val valid-anchors = anchors(side)
  if not contains?(valid-anchors, anchor) :
    throw $ InvalidAlignProperty("anchor %_ not compatible with side %_. Expect one of %_",
      % [anchor, side, valid-anchors])

doc: \<DOC>
Parameters for Box Symbol Glyph Construction

This type contains various parmaeters that we may
want to apply to all box symbols. We provide default
values for a sane consistent default look.
<DOC>
public defstruct BoxSymbolParams <: Equalable :
  min-col-width:Int with: (
    ensure => ensure-non-negative!
    updater => sub-min-col-width
  )
  min-row-width:Int with: (
    ensure => ensure-non-negative!
    updater => sub-min-row-width
  )
  line-width:Double with: (
    ensure => ensure-positive!
    updater => sub-line-width
  )
  pin-length:Double with: (
    ensure => ensure-positive!
    updater => sub-pin-length
  )
  doc: \<DOC>
  Font size for pad names that appear on the symbol.
  <DOC>
  pad-ref-size:Double with: (
    ensure => ensure-positive!
    updater => sub-pad-ref-size
  )
  doc: \<DOC>
  Spacing between input pins.
  This value is in symbol grid units. The best values are
  whole numbers or half-numbers (0.5, 1.5, etc).
  <DOC>
  pin-pitch:Double with: (
    updater => sub-pin-pitch,
    ensure => ensure-positive!
  )
  doc: \<DOC>
  Font size for pin names that appear on the symbol.
  <DOC>
  pin-name-size:Double with: (
    ensure => ensure-positive!
  )
  doc: \<DOC>
  Show row/col grid lines for debugging.
  <DOC>
  show-grid:True|False
  ; Others here like:
  ; Default Head & Foot Padding
  ;    Example: for components that only have pins on the
  ;      left and right side - we may want to add additional
  ;      rectangle height so that there is more body above the first
  ;      pin and/or below the last pin.
  ; For the future:
  ;  Color - stroke, fill, etc.
  ;

with:
  constructor => #BoxSymbolParams
  equalable => true
  printer => true

doc: \<DOC>
Main Type for building Box Symbols.
<DOC>
public defn BoxSymbolParams (
  --
  col-width:Int = DEF_COL_WIDTH
  row-width:Int = DEF_ROW_WIDTH
  line-width:Double = DEF_LINE_WIDTH
  pin-length:Double = DEF_PIN_LEN
  pad-ref-size:Double = DEF_PAD_REF_SIZE
  pin-pitch:Double = DEF_PIN_PITCH
  pin-name-size:Double = DEF_PIN_NAME_SIZE
  show-grid:True|False = DEF_SHOW_GRID
  ) -> BoxSymbolParams:
  #BoxSymbolParams(
    col-width
    row-width
    line-width
    pin-length
    pad-ref-size
    pin-pitch
    pin-name-size
    show-grid
  )

; Stores the default box symbols parameters so that they can
;  be overridden by the user.
var DEF_BOXSYMB_PARAMS = BoxSymbolParams()

public defn get-default-box-symbol-params () -> BoxSymbolParams :
  DEF_BOXSYMB_PARAMS

public defn set-default-box-symbol-params (v:BoxSymbolParams) -> False :
  DEF_BOXSYMB_PARAMS = v

public defn reset-default-box-symbol-params () -> False :
  DEF_BOXSYMB_PARAMS = BoxSymbolParams()

doc: \<DOC>
<DOC>
public defstruct BoxSymbol <: SymbolDefn :
  doc: \<DOC>
  This is the component from which we are building this symbol
  This component object will provide the pins and pin properties
  needed to construct the box symbol.
  <DOC>
  obj:Instantiable|Self

  doc: \<DOC>
  Optional Explicit Parameters for this Box Symbol

  This is useful for testing or explicitly overriding the defaults without
  changing them for the rest of the schematic.
  <DOC>
  params:Maybe<BoxSymbolParams>
    with: (default => None())

  ; Maintains the grid information for the overall box symbol
  grid:GridInfo
    with: (default => GridInfo())
  ; Maintains the pin decorators for each pin (exclusive of banks)
  decorator-by-pin:HashTable<Ref, Vector<PinDecorator>>
    with: (default => HashTable<Ref,Vector<PinDecorator>>())

  ; tracks group-properties
  prop-by-group:HashTable<String,HashTable<Symbol,?>>
    with: (default => HashTable<String,HashTable<Symbol,?>>())

  ; for multi-bank box symbols, empty table for non-banked box symbols
  banks:HashTable<Int|Ref,GridInfo>
    with: (default => HashTable<Int|Ref,GridInfo>())
with:
  constructor => #BoxSymbol
  printer => true

public defn BoxSymbol (
  obj:Instantiable|Self
  --
  params:BoxSymbolParams = ?
  ) -> BoxSymbol:
  #BoxSymbol(obj, params)

defstruct DecoratorInfo :
  ddims: Dims
  x-padded: Double
  decs: Vector<PinDecorator>
  keep-pin-name?: True|False

defn only-outside-decorator? (decs: Vector<PinDecorator>) -> True|False :
  contains?(seq-cat({class(_)}, decs), DEC_OUTSIDE)
    and not contains?(seq-cat({class(_)}, decs), DEC_INSIDE)

defstruct GridInfo :
  ; 1-indexed dimensions
  dims:[Int, Int]
    with: (
      default => [1,1]
      setter => set-dims
  )
  ; whether the user has explicitly set a grid or not
  active-grid?:True|False
    with: (default => false, setter => set-active-grid?)
  ; since `self` can change when generating the symbol data,
  ; pin-info is all the relevant pin property information
  ; copied out from self before symbol generation
with :
  printer => true

; In order to support multi-bank box-symbols, the data to create the symbol for
; each bank is a filtered, computed subset of the pin data for the source
; box symbol. We generate these data structures only when `create-symbol` is
; called for a specific bank.
defstruct BoxSymbolBank <: SymbolDefn :
  grid:GridInfo
  params:BoxSymbolParams
  pin-info:Table<Ref,Table<Symbol,?>>
    with: (
      default => HashTable<Ref,Table<Symbol,?>>()
      setter => set-pin-info
    )
  ; maintain the order of pins since copying to a table
  ; will lose that information
  pin-order:Tuple<Ref>
    with: (
      default => [], setter => set-pin-order
    )
  rcs-by-pin:HashTable<Ref,RCS>
    with: (
      default => HashTable<Ref,RCS>()
    )
  dec-info-by-pin:HashTable<Ref, DecoratorInfo>
    with: (default => HashTable<Ref,DecoratorInfo>())
with :
  printer => true

; ============== Helper Functions ================
;
defn get-params (x:BoxSymbol) -> BoxSymbolParams :
  match(params(x)):
    (_:None): get-default-box-symbol-params()
    (v:One<BoxSymbolParams>): value(v)

; save all relevant pin property information
; explicitly since eventuallly we will lose the reference to self.
; If no bank is specified, everything in the box symbol is used,
; otherwise only the pins and grid for that specific bank are used.
defn save-pin-info (x:BoxSymbol, bank:Int|Ref|False = false) -> BoxSymbolBank :
  val pin-infos = HashTable<Ref, HashTable<Symbol, ?>>()
  val pin-order = Vector<Ref>()
  val decorators = HashTable<Ref,DecoratorInfo>()

  val sorted-pins = sort-by-row-index(pins(obj(x)))
  val filtered-pins = Vector<JITXObject>()
  for p in sorted-pins do :
    match(bank, get-property?(p, BANK_PROP)) :
      (b:Int|Ref, o:One) :
        if value(o) == b :
          add(filtered-pins, p)
      (b:Int|Ref, f:None) :
        false
      (f:False, o:One) :
        false
      (f1:False, f2:None) :
        add(filtered-pins, p)

  if length(filtered-pins) == 0 :
    throw $ Exception("No pins found for bank %_, box-symbol %_" % [bank, name(x)])
  if bank is False and length(sorted-pins) != length(filtered-pins) :
    throw $ Exception("Cannot mix pins with and without 'bank' property")

  val bank-grid =
    match(bank) :
      (b: Int|Ref):
        match(get?(banks(x), b)) :
          (gi: GridInfo) : gi
          (f) : GridInfo()
      (f) : grid(x)

  val pins-by-group = HashTable<String, Vector<JITXObject>>()
  val rcs-by-pin = HashTable<Ref,RCS>()
  for p in filtered-pins do :
    val props = HashTable<Symbol, ?>()
    for pr in SYM_PROPS do :
      match(get-property?(p, pr)) :
        (one: One) :
          props[pr] = value(one)
        (none: None) :
          false

    rcs-by-pin[ref(p)] = calc-rcs-for-pin(ref(p), props, dims(bank-grid))
    pin-infos[ref(p)] = props
    ;println("DEBUG %_ %_" % [ref(p), props])
    add(pin-order, ref(p))

    match(get-property?(p, GROUP_PROP)) :
      (one: One) :
        add-to-vector-table(pins-by-group, value(one), p)
      (none: None) :
        false

    within pin-decs = got?(decorator-by-pin(x), ref(p)) :
      val d = to-Dims(bounds(Union(seq(art, pin-decs))))
      decorators[ref(p)] = DecoratorInfo(
        d
        /x(d) + TEXT_BORDER_PADDING
        pin-decs
        only-outside-decorator?(pin-decs)
      )

  ; Add group margins
  for kv in pins-by-group do :
    val pins = value(kv)
    val head-pin = pins[0]
    val tail-pin = pins[length(pins) - 1]
    within group-props = got?(prop-by-group(x), key(kv)) :
      within group-head-margin = got?(group-props, GROUP_HEAD_MARGIN_PROP) :
        pin-infos[ref(head-pin)][GROUP_HEAD_MARGIN_PROP] = group-head-margin
      within group-tail-margin = got?(group-props, GROUP_TAIL_MARGIN_PROP) :
        pin-infos[ref(tail-pin)][GROUP_TAIL_MARGIN_PROP] = group-tail-margin

  check-properties(filtered-pins)

  BoxSymbolBank(
    bank-grid
    get-params(x)
    pin-infos
    to-tuple $ pin-order
    rcs-by-pin
    decorators
  )

defn check-properties (pins:Seqable<JITXObject>) :
  for p in pins do :
    val side? = get-property?(p, SIDE_PROP)
    match(side?, get-property?(p, ALIGN_PROP)) :
      (o1:One, o2:One) :
        if ((value(o1) == Left or value(o1) == Right)
            and not contains?(LR_ANCHORS, value(o2)))
          or ((value(o1) == Up or value(o1) == Down)
            and not contains?(UD_ANCHORS, value(o2))) :
          throw $ InvalidAlignProperty("Side %_ and Alignment %_ not compatible \
            for pin %_" % [value(o1), value(o2), ref(p)])
      (f1, f2) :
        false

defn check-prop (prop: ?, filter: ?) -> True|False :
    match(prop, filter) :
      (n: None, f: One<?>) :
        false
      (n, f: None) :
        true
      (v: One<Int|Ref>, p) :
        value(v) == p
      (n, f) :
        throw $ GenericBoxSymbolError("Unsupported args to check-prop %_ %_"
          % [prop, filter])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SymbolDefn Interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public defmethod name (x:BoxSymbol) -> String :
  to-string("Box-%_" % [obj(x)])

; Need an override here because `self` will get
; clobbered inside the nested contexts so
; all the pin property data needed for
; rendering the symbol correctly has to be copied out
public defmethod create-symbol (
  x:BoxSymbol,
  --
  pose:Pose = loc(0.0, 0.0),
  scale:Double = UNIT-TO-MM
  description:String = ""
) -> SchematicSymbol :
  create-symbol(x, false, pose = pose, scale = scale, description = description)

public defn create-symbol (
  x:BoxSymbol,
  bank:Int|Ref|False
  --
  pose:Pose = loc(0.0, 0.0),
  scale:Double = UNIT-TO-MM
  description:String = ""
) -> SchematicSymbol :
  val bb = save-pin-info(x, bank)

  pcb-symbol sym :
    name = name(x)
    description = description
    make-all(bb, pose = pose, scale = scale)
  sym
; ===== Helpers for build-pins =======
;
; contains pin data for one side of a single grid cell
defstruct CellPinInfo :
  ; Each element in a "pin-group" is either a group name
  ; (String) or a singleton pin (Ref)
  ; The individual pin refs for a group name can be
  ; looked up through the pin-groups table
  pin-groups-by-align: HashTable<Anchor, Vector<Ref|String>>
  pin-groups: HashTable<String,Vector<Ref>>
  side: Dir
with :
  printer => true

; contains min sizing data for a single grid cell
; this may not be the final size because cells in the same row
; or column may require larger sizing
defstruct CellSizeInfo :
  ; position offsets for each pin in each alignment group
  align-group-offsets: HashTable<Anchor, KeyValue<Double,Vector<Double>>>
  min-total-size: Double
with :
  printer => true

defn min-cell-size (s: Dir, params: BoxSymbolParams) :
  DEF_CELL_TOP_MARGIN + DEF_CELL_BOTTOM_MARGIN +
    match(s) :
      (lr: Left|Right):
        to-double(min-row-width(params))
      (ud: Up|Down):
        to-double(min-col-width(params))

public defmethod build-pins (bb:BoxSymbolBank, node:SymbolNode) :
  val params = params(bb)
  val num-rows = dims(grid(bb))[0]
  val num-cols = dims(grid(bb))[1]
  val pin-info-bs = pin-info(bb)
  val pin-order-bs = pin-order(bb)

  val pins-by-rcs = HashTable<RCS,Vector<Ref>>()
  val pin-info-by-rcs = HashTable<RCS, CellPinInfo>()
  val size-info-by-rcs = HashTable<RCS, CellSizeInfo>()
  val actual-size-by-rcs = HashTable<RCS, Double>()
  val text-size-by-side = HashTable<Dir, Double>()

  val pin-pitch = maximum([
    DEF_PIN_PADDING, pad-ref-size(params), pin-name-size(params), pin-pitch(params)])

  defn calc-padded-text-length (p-ref: Ref) -> Double :
    val base = (MIN_GRID_NUDGE / 2.0) + scale(x $ text-size(to-string(p-ref), pin-name-size(params)))
    match(get?(dec-info-by-pin(bb), p-ref)):
      (di:DecoratorInfo) :
        if keep-pin-name?(di) :
          base
        else :
          (x-padded(di)) + base
      (f) :
        base

  ; group pins by cell and side
  for p-ref in pin-order-bs do :
    val p-info = pin-info-bs[p-ref]
    val rcs = rcs-by-pin(bb)[p-ref]
    add-to-vector-table(pins-by-rcs, rcs, p-ref)
    val text-length = calc-padded-text-length(p-ref)
    val prev-length = get?(text-size-by-side, side(rcs), 0.0)
    if text-length > prev-length :
      text-size-by-side[side(rcs)] = text-length

  val text-buffer-bottom = round-to-grid $ get?(text-size-by-side, Down, 0.0)
  val text-buffer-top = round-to-grid $ get?(text-size-by-side, Up, 0.0)
  val text-buffer-left = round-to-grid $ get?(text-size-by-side, Left, 0.0)
  val text-buffer-right = round-to-grid $ get?(text-size-by-side, Right, 0.0)
  ; ================ align pins in cell ===============
  ;
  ; Run logic to figure out the pin groupings and alignment within each cell
  ;
  defn align-pins-for-rcs (rcs:RCS, pins:Vector<Ref>) -> CellPinInfo :
    val aligned-pin-groups = HashTable<Anchor,Vector<Ref|String>>()
    val pin-groups = HashTable<String,Vector<Ref>>()

    ; representative anchor for group
    val group-anchors = HashTable<String,Anchor>()
    ; prevent groups from being added twice to aligned-pin-groups
    val seen-groups = HashSet<String>()

    val side = side(rcs)
    val def-anchor = default-anchor(side)

    ; multiple alignments in a group are not allowed
    defn check-group-align (group:String, align:Anchor|False) :
      match(get?(group-anchors, group)) :
        (a: Anchor) :
          if align != a :
            throw $ BoxSymbolParamError("multiple alignments found in same group:
              group:%_ [%_ %_]" % [group, align, a])
        (f) : false

    ; go through all the pins in a cell, bookkeeping the following :
    ;   * bucketing pins by group
    ;   * bucketing singleton pins and groups by alignment
    ;     - if one or more pins in a group has a specific alignment
    ;       that alignment is used for the whole group
    ;     - multiple alignments in a group not allowed
    ;
    ; need two passes, first pass is to validate and assign explicitly
    ; specified alignments to groups. second pass is to assign pins that were
    ; unspecified or added to a group after the user assigned an alignment to a group
    for p in pins do :
      match(get?(pin-info-bs[p], GROUP_PROP)) :
        (g: String) :
          add-to-vector-table(pin-groups, g, p)
          match(get?(pin-info-bs[p], ALIGN_PROP)) :
            (a: Anchor) :
              check-valid-anchor(side, a)
              check-group-align(g, a)
              group-anchors[g] = a
            (f) : false
        (f) : false

    ; Since not all pins in a group may have the alignment specified, we need to rebuild the table
    ; as a group may have been bucketed to more than one anchor
    ;   * default alignment for L/R pins is S, U/D pins is E
    for p in pins do :
      match(get?(pin-info-bs[p], GROUP_PROP)) :
        (g: String) :
          if add(seen-groups, g) :
            val a = get?(group-anchors, g, def-anchor)
            add-to-vector-table(aligned-pin-groups, a, g)
        (f) :
          val a = get?(pin-info-bs[p], ALIGN_PROP, def-anchor)
          add-to-vector-table(aligned-pin-groups, a, p)

    CellPinInfo(aligned-pin-groups, pin-groups, side)

  ; figure out pin alignment groups for each cell
  for rcs+pins in pins-by-rcs do :
    val rcs = key(rcs+pins)
    pin-info-by-rcs[rcs] = align-pins-for-rcs(rcs, value(rcs+pins))

  ; ================ calculate min size for each cell ==================
  ;
  ; calculate size for each alignment section in cell
  ;
  ; Note: Margin properties are added on top of default pin padding
  ;
  defn calc-min-cell-dimension (c:CellPinInfo) -> CellSizeInfo :
    defn get-head-margin-for-pin (p: Ref) -> Double :
      val pin-margin =
        match(get?(pin-info-bs[p], HEAD_MARGIN_PROP)) :
          (m:Double) : round-to-grid(m)
          (f) : DEF_CELL_TOP_MARGIN
      val group-margin =
        match(get?(pin-info-bs[p], GROUP_HEAD_MARGIN_PROP)) :
          (m:Double) : round-to-grid(m)
          (f) : DEF_GROUP_TOP_MARGIN
      pin-margin + group-margin

    defn get-tail-margin-for-pin (p: Ref) -> Double :
      val pin-margin =
        match(get?(pin-info-bs[p], TAIL_MARGIN_PROP)) :
          (m:Double) : round-to-grid(m)
          (f) : DEF_CELL_BOTTOM_MARGIN
      val group-margin =
        match(get?(pin-info-bs[p], GROUP_TAIL_MARGIN_PROP)) :
          (m:Double) : round-to-grid(m)
          (f) : DEF_GROUP_BOTTOM_MARGIN
      pin-margin + group-margin

    defn calc-section-offsets (pin-group: Vector<Ref|String>) -> [Double, Vector<Double>] :
      var total = pin-pitch
      val pos = Vector<Double>()
      for (p in pin-group, i in 0 to false) do :
        match(p) :
          (single: Ref) :
            total = total + get-head-margin-for-pin(single)
            add(pos, total)
            total = total + get-tail-margin-for-pin(single)
            total = total + pin-pitch
          (group: String) :
            for p in pin-groups(c)[group] do :
              total = total + get-head-margin-for-pin(p)
              add(pos, total)
              total = total + get-tail-margin-for-pin(p)
              total = total + pin-pitch
      [total, pos]

    ; for a given alignment section, calculate the size of the entire section
    val align-to-offsets = HashTable<Anchor,KeyValue<Double,Vector<Double>>>()
    var total = 0.0
    for a in anchors(side(c)) do :
      match(get?(pin-groups-by-align(c), a)) :
        (pins: Vector<Ref|String>) :
          val [size, offsets] = calc-section-offsets(pins)
          total = total + size
          align-to-offsets[a] = size => offsets
        (f) : false
    ; if length(anchors(side(c))) > 0 :
    ;   total = total + pin-pitch
    CellSizeInfo(align-to-offsets, max(total, min-cell-size(side(c), params)))

  for rcs+pin-info in pin-info-by-rcs do :
    val rcs = key(rcs+pin-info)
    size-info-by-rcs[rcs] = calc-min-cell-dimension(value(rcs+pin-info))

  defn calc-width-height () -> [Double, Double] :
    var max-text-width = 0.0
    var max-text-length = 0.0

    defn calc-side (side:Left|Up, len:Int) -> Double :
      var total-size = 0.0
      val min-cell-size =
        match(side) :
          (l:Left) : to-double(min-row-width(params))
          (u:Up) : to-double(min-col-width(params))
      for i in 0 to len do :
        val [start-edge, end-edge] =
          match(side) :
            (l:Left) : [RCS(i,0,Left),RCS(i,(num-cols - 1),Right)]
            (u:Up) : [RCS(0,i,Up),RCS((num-rows - 1),i,Down)]
        val cell-size =
          match(
            get?(size-info-by-rcs, start-edge)
            get?(size-info-by-rcs, end-edge)
          ):
            (f: False, g: CellSizeInfo) : min-total-size(g)
            (g: CellSizeInfo, f: False) : min-total-size(g)
            (g1: CellSizeInfo, g2:CellSizeInfo): max(min-total-size(g1), min-total-size(g2))
            (f1,f2) : min-cell-size
        actual-size-by-rcs[start-edge] = cell-size
        actual-size-by-rcs[end-edge] = cell-size
        total-size = total-size + cell-size
      total-size
    [calc-side(Up, num-cols), calc-side(Left, num-rows)]

  ; calculate and draw rectangle
  val [width, height] = calc-width-height()
  val adj-height = height + text-buffer-top + text-buffer-bottom
  val adj-width = width + text-buffer-left + text-buffer-right
  val top = adj-height / 2.0
  val top-buffer = calc-snap-grid-buffer(top + text-buffer-top)
  val top-snap-grid = top + top-buffer
  val left = (- 1.0) * (adj-width / 2.0)
  val side-buffer = calc-snap-grid-buffer(left - text-buffer-left)
  val left-snap-grid = left + side-buffer
  val top-left = Point(left-snap-grid, top-snap-grid)

  val base-box-pose = loc(side-buffer, top-buffer)

  rectangle(node, adj-width, adj-height, pose = base-box-pose)
  line-rectangle(node, top-left, top-left + Point(adj-width, (- adj-height)), line-width(params))

  ;println("Rectangle w%_, h%_, pose %_" % [width, height, base-box-pose])
  defn convert-maybe (x:Maybe<Double>) -> Double :
    match(x):
      (_:None): 1.0
      (x:One<Double>): value(x)
  defn build-cell (row:Int, col:Int, side:Dir, start:Point) :
    val rcs = RCS(row, col, side)
    within pin-info = got?(pin-info-by-rcs, rcs) :
      val actual-size = actual-size-by-rcs[rcs]
      val size-info = size-info-by-rcs[rcs]
      ;println("RCS%_\n%_\n%_\nactual-size %_" % [rcs, pin-info, size-info, actual-size])

      defn calc-start (base:Point, offset:Double) -> Point :
        match(side) :
          (lr: Left|Right) : Point(x(base), y(base) - offset)
          (ud: Up|Down) : Point(x(base) + offset, y(base))
      defn create-default-vpin-params () -> VirtualPinParams :
        VirtualPinParams(
          direction = side,
          pin-length = pin-length(params),
          pad-ref-size = pad-ref-size(params),
          pin-name-size = pin-name-size(params)
        )

      defn add-decorated-pin (p:Ref, pos:Point, di:DecoratorInfo) :
        val dec-offset =
          match(side) :
            (l:Left) : Point(x(pos) + x-padded(di), y(pos))
            (r:Right) : Point(x(pos) - x-padded(di), y(pos))
            (u:Up) : loc(x(pos), y(pos) - x-padded(di), 90.0)
            (d:Down) : loc(x(pos), y(pos) + x-padded(di), 90.0)

        val vpin =
          if keep-pin-name?(di) :
            add-pin(node, p, pos, params = create-default-vpin-params())
          else :
            text(node, dec-offset, to-string(p), unit-size = pin-name-size(params), anchor = text-anchor(side))
            add-pin(node, p, pos, params = VirtualPinParams(
              direction = side,
              pin-length = pin-length(params),
              pad-ref-size = pad-ref-size(params)
            ))

        for dec in decs(di) do :
          add-decorator(vpin, dec)

      defn build-alignment-section (
        groups:Vector<Ref|String>
        offsets:Vector<Double>
        start:Point
      ) :
        val pins = Vector<Ref>()
        for g in groups do :
          match(g) :
            (p:Ref) : add(pins, p)
            (g:String) : add-all(pins, pin-groups(pin-info)[g])
        val positions =
          match(side) :
            (lr:Left|Right) :
              for i in 0 to length(pins) seq : Point(x(start), y(start) - offsets[i])
            (ud:Up|Down) :
              for i in 0 to length(pins) seq : Point(x(start) + offsets[i], y(start))
        for (p in pins, pos in positions) do :
          match(get?(dec-info-by-pin(bb), p)) :
            (di: DecoratorInfo) :
              add-decorated-pin(p, pos, di)
            (f) :
              add-pin(node, p, pos, params = create-default-vpin-params())

      ; build an alignment group that's not the center
      defn build-edge-align-group (align:N|E|W|S, align-start:Point) :
        match(get?(pin-groups-by-align(pin-info), align)):
          (groups: Vector<Ref|String>) :
            ;println("alignment group %_ starts %_" % [align, align-start])
            val offsets = value(align-group-offsets(size-info)[align])
            build-alignment-section(groups, offsets, align-start)
          (f) : false

      ; returns true if p1 is after p2
      defn after? (p1: Point, p2: Point) -> True|False :
        match(side) :
          (lr: Left|Right) :
            y(p2) > y(p1)
          (ud: Up|Down) :
            x(p2) < x(p1)

      defn build-center-align-group (center-start:Point, bottom-start:Point) :
        within pin-order = got?(pin-groups-by-align(pin-info), C) :
          val size = key(align-group-offsets(size-info)[C])
          val offsets = value(align-group-offsets(size-info)[C])
          var above-center = 0.0
          var below-center = 0.0
          val center-pin-group = length(pin-order) / 2
          val mod2 = length(pin-order) % 2
          ; odd number of groups/pins, need to split center group
          if (mod2 != 0) :
            val group-length =
              match(pin-order[center-pin-group]) :
                (g: String) : length(pin-groups(pin-info)[g])
                (p: Ref) : 1
            val edge-to-center = to-double((group-length / 2) - ((group-length - 1) % 2))
            above-center = above-center + edge-to-center
            below-center = below-center + edge-to-center

          above-center = above-center + offsets[center-pin-group]
          below-center = below-center + size - offsets[center-pin-group]
          ; Place in the true center of cell first
          val true-center = calc-start(center-start, round-to-grid(actual-size / 2.0))
          var adjusted-center = true-center
          ; check if crosses bottom threshold
          while after?(calc-start(adjusted-center, below-center), bottom-start) :
            adjusted-center = calc-start(adjusted-center, (- DEF_PIN_PADDING))
          ; check if crosses top threshold
          while after?(center-start, calc-start(adjusted-center, (- above-center))) :
            adjusted-center = calc-start(adjusted-center, DEF_PIN_PADDING)
          val adjusted-center-start = calc-start(adjusted-center, (- above-center))
          build-alignment-section(pin-order, offsets, adjusted-center-start)

      val [first-anchor, last-anchor] = [first-anchor(side), last-anchor(side)]
      val top-size =
        match(get?(align-group-offsets(size-info), first-anchor)) :
          (kv: KeyValue<Double,Vector<Double>>) :
            key(kv)
          (f): 0.0
      val bottom-start = calc-start(start, actual-size -
        match(get?(align-group-offsets(size-info), last-anchor)):
          (kv: KeyValue<Double,Vector<Double>>) :
            key(kv)
          (f): 0.0
      )
      val center-start = calc-start(start, top-size)

      ; Build pins for each section
      build-edge-align-group(first-anchor, start)
      build-center-align-group(center-start, bottom-start)
      build-edge-align-group(last-anchor, bottom-start)

  ; finally build pins in each cell
  defn calc-start (base:Point, x-off:Double, y-off:Double) :
    Point(x(base) + x-off, y(base) - y-off)

  val show-grid? = show-grid(params)
  var row-offset = text-buffer-top

  for i in 0 to num-rows do :
    val down = row-offset + actual-size-by-rcs[RCS(i,0,Left)]
    val center-y = row-offset + actual-size-by-rcs[RCS(i,0,Left)] / 2.0

    if show-grid? :
      var adj-y = center-y
        if i == 0 :
          adj-y = adj-y - text-buffer-top / 2.0
        if i == num-rows - 1 :
          adj-y = adj-y + text-buffer-bottom / 2.0
      text(node,
        calc-start(top-left, (- scale(pin-length(params))), adj-y),
        to-string(SHOW_GRID_ROW % [i]),
        unit-size = pin-name-size(params),
        anchor = E)
    var col-offset = text-buffer-left
    for j in 0 to num-cols do :
      val right = col-offset + actual-size-by-rcs[RCS(0,j,Up)]
      val center-x = col-offset + actual-size-by-rcs[RCS(0,j,Up)] / 2.0
      if i == 0 :
        val start = calc-start(top-left, col-offset, 0.0)
        build-cell(i, j, Up, start)
        if show-grid? :
          var adj-x = center-x
          if j == 0 :
            adj-x = adj-x - text-buffer-left / 2.0
          if j == num-cols - 1 :
            adj-x = adj-x + text-buffer-right / 2.0
          text(node,
            calc-start(top-left, adj-x, (- scale(pin-length(params)))),
            to-string(SHOW_GRID_COL % [j]),
            unit-size = pin-name-size(params),
            anchor = S)
          if j > 0 :
            line(node,
              [calc-start(top-left, col-offset, 0.0),
              calc-start(top-left, col-offset, adj-height)]
            )
      if i == num-rows - 1 :
        val start = calc-start(top-left, col-offset, adj-height)
        build-cell(i, j, Down, start)
        if show-grid? and j > 0 :
          line(node,
            [calc-start(top-left, col-offset, 0.0),
            calc-start(top-left, col-offset, adj-height)]
          )
      if j == 0 :
        build-cell(i, j, Left, calc-start(top-left, 0.0, row-offset))
        if show-grid? and i > 0 :
          line(node,
            [calc-start(top-left, 0.0, row-offset),
            calc-start(top-left, adj-width, row-offset)]
          )
      if j == num-cols - 1 :
        build-cell(i, j, Right, calc-start(top-left, adj-width, row-offset))
        if show-grid? and i < num-rows - 1:
          line(node,
            [calc-start(top-left, 0.0, down),
            calc-start(top-left, adj-width, down)]
          )
      col-offset = right
    row-offset = down

public defmethod build-artwork (x:BoxSymbolBank, node:SymbolNode) :
  false

public defmethod build-params (x:BoxSymbolBank, sn:SymbolNode) :
  val b = glyph-bounds(sn)
  text(sn, [left(b), up(b) + DESIGNATOR_MARGIN], ">REF", anchor = SW, font-size = 8)
  text(sn, [left(b), down(b) - DESIGNATOR_MARGIN], ">VALUE", anchor = NW, font-size = 8)

public defmethod build-orientation (x:BoxSymbolBank, sn:SymbolNode) :
  inside pcb-symbol:
    ; By default - box symbols have a preferred orientation
    ;   of vertical. Without this - the ground and power net symbols
    ;   can cause them to rotate in non-optimal orientations.
    preferred-orientation = PreferRotation([0])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

doc: \<DOC>
Find a set of pins that match a particular query

@param b Box Symbol object

@param pattern Glob pattern used to find specific pins by the string variant of the pin reference.
For example, if the there is a pin `D.p[0]`, `D.p[1]`, `D.p[2]`, `M.p[0]`, `M.p[1]` and `M.p[2]`
The user could use a glob pattern `D.p[*]` to select `D.p[0]`, `D.p[1]`, `D.p[2]`

@param bank Optional bank selector so that will limit query to selecting only pins from this particular bank (symbol unit).
@param row Optional row selector that will limit query to selecting only pins from this particular row of the
  box grid.
@param column Optional column selector that will limit query to selecting only pins from this particular column of the box grid.

@return Tuple of Pins that match the given criteria.
<DOC>
public defn find-pins-by-regex (
  b:BoxSymbol, pattern:String
  --
  bank:Int|Ref = ?
  row:Int|Ref = ?
  column:Int|Ref = ?
  ) -> Vector<JITXObject> :

  val matches = Vector<Pin>()

  for p in pins(obj(b)) do :
    if (
      check-prop(property?(p.bank), bank)
      and check-prop(property?(p.row), row)
      and check-prop(property?(p.column), column)
      and not empty?(regex-match(pattern, to-string(ref(p))))
    ) :
      add(matches, Pin(local(p)))
  matches

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pin Grid Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

doc: \<DOC>
Check for an active grid

Components like resistors, capacitors, etc might not have an active grid.

@param b Box Symbol object
@return boolean that indicates of a grid is present on this symbol or not.
<DOC>
public defn has-grid? (b:BoxSymbol) -> True|False :
  active-grid?(grid(b))

doc: \<DOC>
Set the grid for a component

@param b Box Symbol object
@param grid Tuple of [row,column] where row & column must be greater than zero.
@param bank bank ID for multi-symbol unit BoxSymbols.
<DOC>
public defn set-grid (b:BoxSymbol, dims:[Int, Int]) :
  if not has-grid?(b) :
    if dims[0] <= 0 or dims[1] <= 0 :
      throw $ InvalidGridDimension("grid a dims must be >= 1, %_" % [dims])
    set-dims(grid(b), dims)
    set-active-grid?(grid(b), true)
  else :
    throw $ InvalidGridDimension("Active grid already set to %_" % [grid(b)])
  false

public defn set-grid (b:BoxSymbol, dims:[Int, Int], bank:Int|Ref) :
  if not key?(banks(b), bank) :
    banks(b)[bank] = GridInfo(dims, true)
  false

doc: \<DOC>
Get the total number of rows in the pin grid.

This function is for components with only one symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of rows in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-rows (b:BoxSymbol) -> Int:
  dims(grid(b))[0]

doc: \<DOC>
Get the total number of rows in the pin grid of a particular symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of rows in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-rows (b:BoxSymbol, bank:Int|Ref) -> Int:
  match(get?(banks(b), bank)) :
    (gi: GridInfo) :
      dims(gi)[0]
    (f) : 1

doc: \<DOC>
Get the total number of columns in the pin grid.

This function is for components that have only one symbol unit.

@param b Box Symbol object
@return number of columns in the pin grid of component symbol. If no
pin grid is active, this function returns 0.
<DOC>
public defn get-columns (b:BoxSymbol) -> Int:
  dims(grid(b))[1]

doc: \<DOC>
Get the total number of columns in the pin grid of a particular symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of columns in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-columns (b:BoxSymbol, bank:Int|Ref) -> Int:
  match(get?(banks(b), bank)) :
    (gi: GridInfo) :
      dims(gi)[1]
    (f) : 1

doc: \<DOC>
Set the pin grid position for a pin or set of pins.

If the grid does not exist yet - this is an error and this function
should throw an exception.

There are only a limited set of valid row/column combinations based on the
edges of the box symbol.

@param pin-set One Pin or a Tuple of Pins present on `obj` that will be added to a group.
@param row Row index into the pin grid.
@param column Column index into the pin grid.
@throws IndexError If either the `row` or `column` are outside the active grid cells
<DOC>
public defn set-grid-edge (row:Int, col:Int, pins: JITXObject ...) :
  set-row(row, pins)
  set-column(col, pins)

doc: \<DOC>
Set the Row assignment for these pins

Typically this would be used when the `side` parameter had already
been set on these pins to `Left` or `Right`. The `side` parameter would
then drive the column assignment to either `0` or `N-1` where N is the number of columns .
<DOC>
public defn set-row (row:Int, pins: JITXObject ...) :
  set-row(row, pins)

public defn set-row (row:Int, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
  check-non-neg(ROW_PROP, row)
  for p in valid-pins do :
    set-property(p, ROW_PROP, row)

doc: \<DOC>
Set the Column assignment for these pins

Typically this would be used when the `side` parameter had already
been set on these pins to `Up` or `Down`. The `side` parameter would
then drive the row assignment to `0` or `M-1` where M is the number of rows.
<DOC>
public defn set-column (col:Int, pins: JITXObject ...) :
  set-column(col, pins)

public defn set-column (col:Int, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
    check-non-neg(COL_PROP, col)
    for p in valid-pins do :
      set-property(p, COL_PROP, col)

doc: \<DOC>
Set a horizontal line separator on the edge of a row

@param b Box Symbol object
@param row Row Index into the pin grid.
@param pos Used to select which side of the row (N/S) to draw the separator line. Default value is S
@param bank Optional bank (symbol unit) identifier
@param line-width Width of the separator in symbol grid units
<DOC>
defn set-horz-separator (b:BoxSymbol, row:Int -- pos:Anchor = S , bank:Int|Ref = ?, line-width:Double = 0.05) :
  false

doc: \<DOC>
Set a vertical line separator on the edge of a column

@param b Box Symbol object
@param column Column Index into the pin grid.
@param pos Used to select which side of the column (E/W) to draw the separator line. Default value is E
@param bank Optional bank (symbol unit) identifier
@param line-width Width of the separator in symbol grid units
<DOC>
defn set-vert-separator (b:BoxSymbol, column:Int -- pos:Anchor = E , bank:Int|Ref = ?) :
  false

doc: \<DOC>
Set the side of the box symbol to assign to a pin or set of pins

This function will set the direction and side of the passed pins.

If a `grid` exists - then the appropriate column/row will be selected. For example,
The `Top` side would be given row 0. The `Left` side would be given column 0.
A `Right` side would be given column N-1 where N is the number of columns.

If the `grid` does not exist, then adding a side parameter for a set of pins would begin
constructing the grid. For example, Adding a set of pins on the `Right` and `Left` would
construct a grid of 1 row and 2 columns. Subsequent operations might increase the number of
rows if `Top` and `Bottom` pin sets were added. In this case, the row & column indices for the first group
of `Right` and `Left` pins would need to be modified. They would move from row index 0 to row index 1. The `Right`
side pins would move to column index 2. The `Top` side pins would be in row index 0 and column index 1.

NOTE: If this is too complex - we can add the constraint that the user must add the `grid` first, but in order to
match the existing functionality, I think we would need to support this.

@param pin-set One Pin or a Tuple of Pins present on `obj` that will be added to a side.
@param side Selects the edge of a box symbol on to which the pins will be drawn
<DOC>
public defn set-side (side:Dir, pins: JITXObject ...)  :
  set-side(side, pins)

public defn set-side (side:Dir, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, SIDE_PROP, side)

; defn get-side (p:Pin) -> Maybe<Dir> :
;   One(Left)

; defn get-side! (p:Pin) -> Dir :
;   Left

public defn pins-in-group (b:BoxSymbol, group:String) -> Tuple<JITXObject> :
  to-tuple $ for p in pins(obj(b)) seq? :
    match(get-property?(p, GROUP_PROP)) :
      (one:One)   :
        if value(one) == group :
          One(p)
        else :
          None()
      (none:None) :
        None()

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bank
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public defn set-bank (bank:Int|Ref, pins: JITXObject ...)  :
  set-bank(bank, pins)

public defn set-bank (bank:Int|Ref, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, BANK_PROP, bank)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Alignment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public defn set-alignment (pos:Anchor, pins: JITXObject ...)  :
  set-alignment(pos, pins)

public defn set-alignment (pos:Anchor, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, ALIGN_PROP, pos)

; defn get-alignment (p:Pin) -> Maybe<Anchor> :
;   One(C)

; defn get-alignment! (p:Pin) -> Anchor :
;   C

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Group
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public defn set-group (group:String, pins: JITXObject ...)  :
  set-group(group, pins)

public defn set-group (group:String, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, GROUP_PROP, group)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Margin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public defn set-head-margin (margin:Double, pins: JITXObject ...) :
  set-head-margin(margin, pins)

public defn set-head-margin (margin:Double, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, HEAD_MARGIN_PROP, margin)

public defn set-tail-margin (margin:Double, pins: JITXObject ...) :
  set-tail-margin(margin, pins)

public defn set-tail-margin (margin:Double, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, TAIL_MARGIN_PROP, margin)

; This one is a bit more complicated.
; Alignment property for groups are separated from alignment properties
; for individual pins because pins may be added to the group. User should also be able to set additional margins for
; each pin if they so wish.
;
; We keep a map internally of group to margin so we only apply the margin to the pins
; at symbol generation time.
public defn set-head-margin (box: BoxSymbol, margin:Double, group: String) :
  set-prop-for-group(box, margin, group, GROUP_HEAD_MARGIN_PROP)

public defn set-tail-margin (box: BoxSymbol, margin:Double, group: String) :
  set-prop-for-group(box, margin, group, GROUP_TAIL_MARGIN_PROP)

defn set-prop-for-group (box: BoxSymbol, v: ?, group: String, prop: Symbol) :
  add-to-nested-hashtable(prop-by-group(box), group, prop, v)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Decorators
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


doc: \<DOC>
Add a particular decorator[s] to the passed pins.

@param b Box Symbol Object
@param pin-set Pin or Set of Pins to add the decorator to.
@param decorators One or More decorators to add to these pins.

NOTE: Multiple decorators may not stack well yet - WIP.
<DOC>
public defn add-decorator (b:BoxSymbol, pin-set: Seqable<JITXObject>, decorators:Seqable<PinDecorator>) :
  val valid-pins = check-port-type(pin-set)
  for p in valid-pins do :
    add-to-vector-table(decorator-by-pin(b), ref(p), decorators)

public defn add-decorator (b:BoxSymbol, p:JITXObject, decorator:PinDecorator) :
  add-decorator(b, [p], [decorator])

defn round-to-grid (d: Double) -> Double :
  if d < 0.0 :
    to-double(floor(d / 0.5)) * 0.5
  else :
    to-double(ceil(d / 0.5)) * 0.5

defn calc-snap-grid-buffer (dim: Double) -> Double :
  ceil(dim / 0.5) * 0.5 - (dim)

public deftype UnitSymbol :
  BoxSymbol <: UnitSymbol
  SchematicSymbol <: UnitSymbol

public defn assign-symbols (banks: KeyValue<Int|Ref, UnitSymbol> ...) -> False :
  assign-symbols(banks)

public defn assign-symbols (banks: Seqable<KeyValue<Int|Ref, UnitSymbol>>) -> False :
  val schem-syms = Vector<KeyValue<Int|Ref, SchematicSymbol>>()
  for [bank, symbol] in kvs(banks) do :
    add(schem-syms, bank =>
      match(symbol) :
        (b: BoxSymbol) : create-symbol(b, bank)
        (s: SchematicSymbol) : s
    )
  assign-schematic-symbols(to-tuple $ schem-syms)
