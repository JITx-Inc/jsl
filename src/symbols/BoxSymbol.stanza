#use-added-syntax(jitx)
defpackage jsl/symbols/BoxSymbol:
  import algorithm/utils
  import core
  import collections
  import lang-utils
  import pcre
  import jitx
  import jitx/commands
  import jitx/utils/got
  import jitx/schematic/analysis
  import jsl/ensure
  import jsl/symbols/utils
  import jsl/symbols/SymbolDefn
  import jsl/symbols/SymbolNode
  import jsl/geometry/box
  import math

val DEF_LINE_WIDTH = 0.05
val DEF_PIN_LEN = 1.0
val DEF_PAD_REF_SIZE = 0.25
val DEF_PIN_NAME_SIZE = 0.25
; length between pins
val DEF_PIN_PITCH = 0.5
; min length of rows/columns
val DEF_COL_WIDTH = 2
val DEF_ROW_WIDTH = 1
; padding for top and bottom of a cell
val DEF_CELL_TOP_MARGIN = 0.0
val DEF_CELL_BOTTOM_MARGIN = 0.0
; length between groups/singleton pins
val DEF_PIN_PADDING = 0.5
val DESIGNATOR_MARGIN = 1.0

; Property constants
public :
  val ROW_PROP = `row
  val COL_PROP = `column
  val ALIGN_PROP = `alignment
  val SIDE_PROP = `side
  val GROUP_PROP = `group
  val TOP_MARGIN_PROP = `top-margin
  val BOTTOM_MARGIN_PROP = `bottom-margin
  val BANK_PROP = `bank

val SYM_PROPS = [
  ROW_PROP
  COL_PROP
  ALIGN_PROP
  SIDE_PROP
  GROUP_PROP
  TOP_MARGIN_PROP
  BOTTOM_MARGIN_PROP
  BANK_PROP
]

; Valid anchors for Left/Right, Up/Down pins
val LR_ANCHORS = [N, C, S]
val UD_ANCHORS = [W, C, E]

defn anchors (s: Dir) :
  match(s) :
    (lr: Left|Right) : LR_ANCHORS
    (ud: Up|Down) : UD_ANCHORS

; Ordering and default anchors for Left/Right, Up/Down pins
defn first-anchor (s: Dir) :
  match(s) :
    (lr: Left|Right) : N
    (ud: Up|Down) : W

defn last-anchor (s: Dir) :
  match(s) :
    (lr: Left|Right) : S
    (ud: Up|Down) : E

defn default-anchor (s: Dir) :
  match(s) :
    (lr:Left|Right) : S
    (ud:Up|Down) : E

; Takes a seqable of JITXObject and checks that every one of them has
; a port type. They are returned in a vector (stable order) but an exception
; is thrown if one or more of the objects is not of a supported port type
defn check-port-type (objs: Seqable<JITXObject>) -> Vector<JITXObject> :
  val non-ports = Vector<JITXObject>()
  val ports = Vector<JITXObject>()

  for o in objs do :
    match(o) :
      (s:Self) : add(non-ports, s)
      (ns) :
        match(port-type(ns)) :
          (s:SinglePin) : add(ports, ns)
          (b:Bundle|PortArray) : add-all(ports, pins(ns))
          (f): add(non-ports, o)
  if length(non-ports) > 0 :
    throw $ BoxSymbolApiError("Object(s) %_ are not of expected PortType"
      % [non-ports])
  ports

defn check-non-neg (prop:Symbol, arg:Int) :
  if arg < 0 :
    throw $ BoxSymbolParamError("negative val %_ for prop '%_'" % [arg, prop])

defn check-valid-anchor (side:Dir, anchor:Anchor) :
  val valid-anchors = anchors(side)
  if not contains?(valid-anchors, anchor) :
    throw $ BoxSymbolParamError("anchor %_ not compatible with side %_. Expect one of %_",
      % [anchor, side, valid-anchors])

doc: \<DOC>
Parameters for Box Symbol Glyph Construction

This type contains various parmaeters that we may
want to apply to all box symbols. We provide default
values for a sane consistent default look.
<DOC>
public defstruct BoxSymbolParams <: Equalable :
  min-col-width:Int with: (
    ensure => ensure-non-negative!
    updater => sub-min-col-width
  )
  min-row-width:Int with: (
    ensure => ensure-non-negative!
    updater => sub-min-row-width
  )
  line-width:Double with: (
    ensure => ensure-positive!
    updater => sub-line-width
  )
  pin-length:Double with: (
    ensure => ensure-positive!
    updater => sub-pin-length
  )
  doc: \<DOC>
  Font size for pad names that appear on the symbol.
  <DOC>
  pad-ref-size:Double with: (
    ensure => ensure-positive!
    updater => sub-pad-ref-size
  )
  doc: \<DOC>
  Spacing between input pins.
  This value is in symbol grid units. The best values are
  whole numbers or half-numbers (0.5, 1.5, etc).
  <DOC>
  pin-pitch:Double with: (
    updater => sub-pin-pitch,
    ensure => ensure-positive!
  )
  doc: \<DOC>
  Font size for pin names that appear on the symbol.
  <DOC>
  pin-name-size:Double with: (
    ensure => ensure-positive!
  )
  ; Others here like:
  ; Default Head & Foot Padding
  ;    Example: for components that only have pins on the
  ;      left and right side - we may want to add additional
  ;      rectangle height so that there is more body above the first
  ;      pin and/or below the last pin.
  ; For the future:
  ;  Color - stroke, fill, etc.
  ;
with:
  constructor => #BoxSymbolParams
  equalable => true
  printer => true

doc: \<DOC>
Main Type for building Box Symbols.
<DOC>
public defn BoxSymbolParams (
  --
  col-width:Int = DEF_COL_WIDTH
  row-width:Int = DEF_ROW_WIDTH
  line-width:Double = DEF_LINE_WIDTH
  pin-length:Double = DEF_PIN_LEN
  pad-ref-size:Double = DEF_PAD_REF_SIZE
  pin-pitch:Double = DEF_PIN_PITCH
  pin-name-size:Double = DEF_PIN_NAME_SIZE
  ) -> BoxSymbolParams:
  #BoxSymbolParams(
    col-width
    row-width
    line-width
    pin-length
    pad-ref-size
    pin-pitch
    pin-name-size
  )

; Stores the default box symbols parameters so that they can
;  be overridden by the user.
var DEF_BOXSYMB_PARAMS = BoxSymbolParams()

public defn get-default-box-symbol-params () -> BoxSymbolParams :
  DEF_BOXSYMB_PARAMS

public defn set-default-box-symbol-params (v:BoxSymbolParams) -> False :
  DEF_BOXSYMB_PARAMS = v

public defn reset-default-box-symbol-params () -> False :
  DEF_BOXSYMB_PARAMS = BoxSymbolParams()

doc: \<DOC>
<DOC>
public defstruct BoxSymbol <: SymbolDefn :
  doc: \<DOC>
  This is the component from which we are building this symbol
  This component object will provide the pins and pin properties
  needed to construct the box symbol.
  <DOC>
  obj:Instantiable|Self

  doc: \<DOC>
  Optional Explicit Parameters for this Box Symbol

  This is useful for testing or explicitly overriding the defaults without
  changing them for the rest of the schematic.
  <DOC>
  params:Maybe<BoxSymbolParams>
    with: (default => None())

  ; Maintains the grid information for the overall box symbol
  grid:GridInfo
    with: (default => GridInfo())
  ; Maintains the pin decorators for each pin (exclusive of banks)
  decorator-by-pin:HashTable<Ref, Vector<PinDecorator>>
    with: (default => HashTable<Ref,Vector<PinDecorator>>())

  ; for multi-bank box symbols
  banks:HashTable<Int|Ref,GridInfo>
    with: (default => HashTable<Int|Ref,GridInfo>())
with:
  constructor => #BoxSymbol
  printer => true

public defn BoxSymbol (
  obj:Instantiable|Self
  --
  params:BoxSymbolParams = ?
  ) -> BoxSymbol:
  #BoxSymbol(obj, params)

defstruct GridInfo :
  ; 1-indexed dimensions
  dims:[Int, Int]
    with: (default => [1,1], setter => set-dims)
  ; whether the user has explicitly set a grid or not
  active-grid?:True|False
    with: (default => false, setter => set-active-grid?)
  ; since `self` can change when generating the symbol data,
  ; pin-info is all the relevant pin property information
  ; copied out from self before symbol generation

; In order to support multi-bank box-symbols, the data to create the symbol for
; each bank is a filtered, computed subset of the pin data for the source
; box symbol. We generate these data structures only when `create-symbol` is
; called for a specific bank.
defstruct BoxSymbolBank <: SymbolDefn :
  grid:GridInfo
  params:BoxSymbolParams
  pin-info:Table<Ref,Table<Symbol,?>>
    with: (
      default => HashTable<Ref,Table<Symbol,?>>()
      setter => set-pin-info
    )
  ; maintain the order of pins since copying to a table
  ; will lose that information
  pin-order:Tuple<Ref>
    with: (
      default => [], setter => set-pin-order
    )
  decorator-by-pin:HashTable<Ref, Vector<PinDecorator>>
    with: (default => HashTable<Ref,Vector<PinDecorator>>())
with :
  printer => true
; ============== Helper Functions ================
;
defn get-params (x:BoxSymbol) -> BoxSymbolParams :
  match(params(x)):
    (_:None): get-default-box-symbol-params()
    (v:One<BoxSymbolParams>): value(v)

; save all relevant pin property information
; explicitly since eventuallly we will lose the reference to self.
; If no bank is specified, everything in the box symbol is used,
; otherwise only the pins and grid for that specific bank are used.
defn save-pin-info (x:BoxSymbol, bank:Int|Ref|False = false) -> BoxSymbolBank :
  val pin-infos = HashTable<Ref, HashTable<Symbol, ?>>()
  val pin-order = Vector<Ref>()
  val decorators = HashTable<Ref,Vector<PinDecorator>>()

  val sorted-pins = sort-by-row-index(pins(obj(x)))
  val filtered-pins = Vector<JITXObject>()
  for p in sorted-pins do :
    match(bank, get-property?(p, BANK_PROP)) :
      (b:Int|Ref, o:One) :
        if value(o) == b : add(filtered-pins, p)
      (b:Int|Ref, f:None) :
        false
      (f:False, o:One) :
        false
      (f1:False, f2:None) :
        add(filtered-pins, p)

  if length(filtered-pins) == 0 :
    throw $ Exception("No pins found for bank %_, box-symbol %_" % [bank, name(x)])
  if bank is False and length(sorted-pins) != length(filtered-pins) :
    throw $ Exception("Cannot mix pins with and without 'bank' property")

  for p in filtered-pins do :
    val props = HashTable<Symbol, ?>()
    for pr in SYM_PROPS do :
      match(get-property?(p, pr)) :
        (one: One) :
          props[pr] = value(one)
        (none: None) :
          false
    within pin-decs = got?(decorator-by-pin(x), ref(p)) :
      add-to-vector-table(decorators, ref(p), pin-decs)
    pin-infos[ref(p)] = props
    add(pin-order, ref(p))

  val bank-grid =
    match(bank) :
      (b: Int|Ref):
        match(get?(banks(x), b)) :
          (gi: GridInfo) : gi
          (f) : GridInfo()
      (f) : grid(x)

  check-properties(filtered-pins, bank-grid)

  BoxSymbolBank(
    bank-grid
    get-params(x)
    pin-infos
    to-tuple $ pin-order
    decorators
  )

defn check-properties (pins:Seqable<JITXObject>, grid: GridInfo) :
  for p in pins do :
    val side? = get-property?(p, SIDE_PROP)
    match(side?, get-property?(p, ALIGN_PROP)) :
      (o1:One, o2:One) :
        if ((value(o1) == Left or value(o1) == Right)
            and not contains?(LR_ANCHORS, value(o2)))
          or ((value(o1) == Up or value(o1) == Down)
            and not contains?(UD_ANCHORS, value(o2))) :
          throw $ BoxSymbolParamError("Side %_ and Alignment %_ not compatible \
            for pin %_" % [value(o1), value(o2), ref(p)])
      (f1, f2) :
        false

    ; check rows and cols are valid
    val max-row = dims(grid)[0] - 1
    match(get-property?(p, ROW_PROP), side?) :
      (o1:One, side:One):
        if (value(side) == Up and value(o1) != 0)
          or (value(side) == Down and value(o1) != max-row) :
          throw $ BoxSymbolParamError("Invalid row %_ (should be 0 or %_) \
            for pin %_ on side %_" % [value(o1), max-row, ref(p), value(side)])
      (f1, f2): false

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SymbolDefn Interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public defmethod name (x:BoxSymbol) -> String :
  to-string("Box-%_" % [obj(x)])

; Need an override here because `self` will get
; clobbered inside the nested contexts so
; all the pin property data needed for
; rendering the symbol correctly has to be copied out
public defmethod create-symbol (
  x:BoxSymbol,
  --
  pose:Pose = loc(0.0, 0.0),
  scale:Double = UNIT-TO-MM
  description:String = ""
) -> SchematicSymbol :
  create-symbol(x, false, pose = pose, scale = scale, description = description)

public defn create-symbol (
  x:BoxSymbol,
  bank:Int|Ref|False
  --
  pose:Pose = loc(0.0, 0.0),
  scale:Double = UNIT-TO-MM
  description:String = ""
) -> SchematicSymbol :
  val bb = save-pin-info(x, bank)

  ;println("DEBUG %_, %_" % [bb, bank])
  pcb-symbol sym :
    name = name(x)
    description = description
    make-all(bb, pose = pose, scale = scale)
  sym
; ===== Helpers for build-pins =======
;
; contains pin data for one side of a single grid cell
defstruct CellPinInfo :
  ; Each element in a "pin-group" is either a group name
  ; (String) or a singleton pin (Ref)
  ; The individual pin refs for a group name can be
  ; looked up through the pin-groups table
  pin-groups-by-align: HashTable<Anchor, Vector<Ref|String>>
  pin-groups: HashTable<String,Vector<Ref>>
  side: Dir
with :
  printer => true

; contains min sizing data for a single grid cell
; this may not be the final size because cells in the same row
; or column may require larger sizing
defstruct CellSizeInfo :
  ; position offsets for each pin in each alignment group
  align-group-offsets: HashTable<Anchor, KeyValue<Double,Vector<Double>>>
  min-total-size: Double
with :
  printer => true

; struct for passing around row/col/side data
defstruct RCS <: Equalable & Hashable :
  row:Int
  col:Int
  side:Dir
with :
  printer => true
  equalable => true
  hashable => true

defn min-cell-size (s: Dir, params: BoxSymbolParams) :
  DEF_CELL_TOP_MARGIN + DEF_CELL_BOTTOM_MARGIN +
    match(s) :
      (lr: Left|Right):
        to-double(min-row-width(params))
      (ud: Up|Down):
        to-double(min-col-width(params))

public defmethod build-pins (bb:BoxSymbolBank, node:SymbolNode) :
  val params = params(bb)
  val ppitch = pin-pitch(params)
  val num-rows = dims(grid(bb))[0]
  val num-cols = dims(grid(bb))[1]
  val pin-info-bs = pin-info(bb)
  val pin-order-bs = pin-order(bb)

  val pins-by-rcs = HashTable<RCS,Vector<Ref>>()
  val pin-info-by-rcs = HashTable<RCS, CellPinInfo>()
  val size-info-by-rcs = HashTable<RCS, CellSizeInfo>()
  val actual-size-by-rcs = HashTable<RCS, Double>()

  ; =========== Calcuate row/col/side for pins ============
  ;
  ; determine row col and side for specific pin given properties for that pin
  ; 'Top' gets row = 0
  ; 'Bottom' gets row = num-rows
  ; 'Left' gets col = 0
  ; 'Right' gets col = num-cols
  ; Defaults :
  ;   side = 'Left', row = 0, col = 0
  defn calc-rcs-for-pin (ref: Ref, props: Table<Symbol,?>) -> RCS:
    val side = get?(props, SIDE_PROP, Left)
    val has-row? = key?(props, ROW_PROP)
    val has-col? = key?(props, COL_PROP)

    val row =
      if side == Top : 0
      else if side == Bottom : num-rows - 1
      else :
        if has-row? :
          val row = props[ROW_PROP]
          if row < 0 or row >= num-rows :
            throw $ BoxSymbolParamError("Invalid row %_ for pin %_" % [row, ref])
          row
        else :
          0
    val col =
      if side == Left : 0
      else if side == Right : num-cols - 1
      else :
        if has-col? :
          val col = props[COL_PROP]
          if col < 0 or col >= num-cols :
            throw $ BoxSymbolParamError("Invalid col %_ for pin %_" % [col, ref])
          col
        else :
          0
    RCS(row, col, side)

  ; group pins by cell and side
  for p-ref in pin-order-bs do :
    val p-info = pin-info-bs[p-ref]
    val rcs = calc-rcs-for-pin(p-ref, p-info)
    add-to-vector-table(pins-by-rcs, rcs, p-ref)

  ; ================ align pins in cell ===============
  ;
  ; Run logic to figure out the pin groupings and alignment within each cell
  ;
  defn align-pins-for-rcs (rcs:RCS, pins:Vector<Ref>) -> CellPinInfo :
    val aligned-pin-groups = HashTable<Anchor,Vector<Ref|String>>()
    val pin-groups = HashTable<String,Vector<Ref>>()

    ; representative anchor for group
    val group-anchors = HashTable<String,Anchor>()
    ; prevent groups from being added twice to aligned-pin-groups
    val seen-groups = HashSet<String>()

    val side = side(rcs)
    val def-anchor = default-anchor(side)

    ; multiple alignments in a group are not allowed
    defn check-group-align (group:String, align:Anchor|False) :
      match(get?(group-anchors, group)) :
        (a: Anchor) :
          if align != a :
            throw $ BoxSymbolParamError("multiple alignments found in same group:
              group:%_ [%_ %_]" % [group, align, a])
        (f) : false

    ; go through all the pins in a cell, bookkeeping the following :
    ;   * bucketing pins by group
    ;   * bucketing singleton pins and groups by alignment
    ;     - if one or more pins in a group has a specific alignment
    ;       that alignment is used for the whole group
    ;     - multiple alignments in a group not allowed
    ;
    ; need two passes, first pass is to validate and assign explicitly
    ; specified alignments to groups. second pass is to assign pins that were
    ; unspecified or added to a group after the user assigned an alignment to a group
    for p in pins do :
      match(get?(pin-info-bs[p], GROUP_PROP)) :
        (g: String) :
          add-to-vector-table(pin-groups, g, p)
          match(get?(pin-info-bs[p], ALIGN_PROP)) :
            (a: Anchor) :
              check-valid-anchor(side, a)
              check-group-align(g, a)
              group-anchors[g] = a
            (f) : false
        (f) : false

    ; Since not all pins in a group may have the alignment specified, we need to rebuild the table
    ; as a group may have been bucketed to more than one anchor
    ;   * default alignment for L/R pins is S, U/D pins is E
    for p in pins do :
      match(get?(pin-info-bs[p], GROUP_PROP)) :
        (g: String) :
          if add(seen-groups, g) :
            val a = get?(group-anchors, g, def-anchor)
            add-to-vector-table(aligned-pin-groups, a, g)
        (f) :
          val a = get?(pin-info-bs[p], ALIGN_PROP, def-anchor)
          add-to-vector-table(aligned-pin-groups, a, p)

    CellPinInfo(aligned-pin-groups, pin-groups, side)

  ; figure out pin alignment groups for each cell
  for rcs+pins in pins-by-rcs do :
    val rcs = key(rcs+pins)
    pin-info-by-rcs[rcs] = align-pins-for-rcs(rcs, value(rcs+pins))

  ; ================ calculate min size for each cell ==================
  ;
  ; calculate size for each alignment section in cell
  ;
  ; Note: Margin properties are added on top of default pin padding
  ;
  defn calc-min-cell-dimension (c:CellPinInfo) -> CellSizeInfo :
    defn get-top-margin-for-pin (p: Ref) -> Double :
      match(get?(pin-info-bs[p], TOP_MARGIN_PROP)) :
        (m:Double) : round-to-grid(m)
        (f) : DEF_CELL_TOP_MARGIN

    defn get-bottom-margin-for-pin (p: Ref) -> Double :
      match(get?(pin-info-bs[p], BOTTOM_MARGIN_PROP)) :
        (m:Double) : round-to-grid(m)
        (f) : DEF_CELL_BOTTOM_MARGIN

    defn calc-section-offsets (pin-group: Vector<Ref|String>) -> [Double, Vector<Double>] :
      var total = DEF_PIN_PADDING
      val pos = Vector<Double>()
      for (p in pin-group, i in 0 to false) do :
        match(p) :
          (single: Ref) :
            total = total + get-top-margin-for-pin(single)
            add(pos, total)
            total = total + get-bottom-margin-for-pin(single)
            total = total + DEF_PIN_PADDING
          (group: String) :
            for p in pin-groups(c)[group] do :
              total = total + get-top-margin-for-pin(p)
              add(pos, total)
              total = total + get-bottom-margin-for-pin(p)
              total = total + DEF_PIN_PADDING
      [total, pos]

    ; for a given alignment section, calculate the size of the entire section
    val align-to-offsets = HashTable<Anchor,KeyValue<Double,Vector<Double>>>()
    var total = 0.0
    for a in anchors(side(c)) do :
      match(get?(pin-groups-by-align(c), a)) :
        (pins: Vector<Ref|String>) :
          val [size, offsets] = calc-section-offsets(pins)
          total = total + size
          align-to-offsets[a] = size => offsets
        (f) : false
    CellSizeInfo(align-to-offsets, max(total, min-cell-size(side(c), params)))

  for rcs+pin-info in pin-info-by-rcs do :
    val rcs = key(rcs+pin-info)
    size-info-by-rcs[rcs] = calc-min-cell-dimension(value(rcs+pin-info))

  defn calc-width-height () -> [Double, Double] :
    var max-text-width = 0.0
    var max-text-length = 0.0

    defn calc-side (side:Left|Up, len:Int) -> Double :
      var total-size = 0.0
      val min-cell-size =
        match(side) :
          (l:Left) : to-double(min-row-width(params))
          (u:Up) : to-double(min-col-width(params))
      for i in 0 to len do :
        val [start-edge, end-edge] =
          match(side) :
            (l:Left) : [RCS(i,0,Left),RCS(i,(num-cols - 1),Right)]
            (u:Up) : [RCS(0,i,Up),RCS((num-rows - 1),i,Down)]
        val cell-size =
          match(
            get?(size-info-by-rcs, start-edge)
            get?(size-info-by-rcs, end-edge)
          ):
            (f: False, g: CellSizeInfo) : min-total-size(g)
            (g: CellSizeInfo, f: False) : min-total-size(g)
            (g1: CellSizeInfo, g2:CellSizeInfo): max(min-total-size(g1), min-total-size(g2))
            (f1,f2) : min-cell-size
        actual-size-by-rcs[start-edge] = cell-size
        actual-size-by-rcs[end-edge] = cell-size
        total-size = total-size + cell-size
      total-size
    [calc-side(Up, num-cols), calc-side(Left, num-rows)]

  ; calculate and draw rectangle
  val [width, height] = calc-width-height()
  val top = height / 2.0
  val top-buffer = calc-snap-grid-buffer(top)
  val top-snap-grid = top + top-buffer
  val left = (- 1.0) * (width / 2.0)
  val side-buffer = calc-snap-grid-buffer(left)
  val left-snap-grid = left + side-buffer
  val top-left = Point(left-snap-grid, top-snap-grid)

  val base-box-pose = loc(side-buffer, top-buffer)
  rectangle(node, width, height, pose = base-box-pose)
  ;println("Rectangle w%_, h%_, pose %_" % [width, height, base-box-pose])

  defn build-cell (row:Int, col:Int, side:Dir, start:Point) :
    val rcs = RCS(row, col, side)
    within pin-info = got?(pin-info-by-rcs, rcs) :
      val actual-size = actual-size-by-rcs[rcs]
      val size-info = size-info-by-rcs[rcs]
      ;println("RCS%_\n%_\n%_\nactual-size %_" % [rcs, pin-info, size-info, actual-size])

      defn calc-start (base:Point, offset:Double) -> Point :
        match(side) :
          (lr: Left|Right) : Point(x(base), y(base) - offset)
          (ud: Up|Down) : Point(x(base) + offset, y(base))
      defn create-default-vpin-params () -> VirtualPinParams :
        VirtualPinParams(
          direction = side,
          pin-length = pin-length(params),
          pad-ref-size = pad-ref-size(params),
          pin-name-size = pin-name-size(params)
        )

      defn build-alignment-section (
        groups:Vector<Ref|String>
        offsets:Vector<Double>
        start:Point
      ) :
        val pins = Vector<Ref>()
        for g in groups do :
          match(g) :
            (p:Ref) : add(pins, p)
            (g:String) : add-all(pins, pin-groups(pin-info)[g])
        val positions =
          match(side) :
            (lr:Left|Right) :
              for i in 0 to length(pins) seq : Point(x(start), y(start) - offsets[i])
            (ud:Up|Down) :
              for i in 0 to length(pins) seq : Point(x(start) + offsets[i], y(start))
        for (p in pins, pos in positions) do :
          val decs = get?(decorator-by-pin(bb), p, [])
          val dec-offset =
            if length(decs) == 0 : pos
            else :
              match(side) :
                (l:Left) : loc(0.6 0.0) * pos
                (r:Right) : loc((-1.0), 0.0) * pos
                (u:Up) : loc(loc(0.0, (- 1.0)) * pos, 90.0)
                (d:Down) : loc(loc(0.0, 0.6) * pos, 90.0)
          val custom-params =
            if length(decs) == 0 :
              create-default-vpin-params()
            else :
              VirtualPinParams(
                direction = side,
                pin-length = pin-length(params),
                pad-ref-size = pad-ref-size(params)
              )
          val vpin = add-pin(node, p, pos, params = custom-params)
          if length(decs) > 0 :
            text(node, dec-offset, to-string(p), font-size = 2)
          for d in decs do :
            add-decorator(vpin, d)

      ; build an alignment group that's not the center
      defn build-edge-align-group (align:N|E|W|S, align-start:Point) :
        match(get?(pin-groups-by-align(pin-info), align)):
          (groups: Vector<Ref|String>) :
            ;println("alignment group %_ starts %_" % [align, align-start])
            val offsets = value(align-group-offsets(size-info)[align])
            build-alignment-section(groups, offsets, align-start)
          (f) : false

      ; returns true if p1 is after p2
      defn after? (p1: Point, p2: Point) -> True|False :
        match(side) :
          (lr: Left|Right) :
            y(p2) > y(p1)
          (ud: Up|Down) :
            x(p2) < x(p1)

      defn build-center-align-group (center-start:Point, bottom-start:Point) :
        within pin-order = got?(pin-groups-by-align(pin-info), C) :
          val size = key(align-group-offsets(size-info)[C])
          val offsets = value(align-group-offsets(size-info)[C])
          var above-center = 0.0
          var below-center = 0.0
          val center-pin-group = length(pin-order) / 2
          val mod2 = length(pin-order) % 2
          ; odd number of groups/pins, need to split center group
          if (mod2 != 0) :
            val group-length =
              match(pin-order[center-pin-group]) :
                (g: String) : length(pin-groups(pin-info)[g])
                (p: Ref) : 1
            val edge-to-center = to-double((group-length / 2) - ((group-length - 1) % 2)) * ppitch
            above-center = above-center + edge-to-center
            below-center = below-center + edge-to-center

          above-center = above-center + offsets[center-pin-group]
          below-center = below-center + size - offsets[center-pin-group]
          ; Place in the true center of cell first
          val true-center = calc-start(center-start, round-to-grid(actual-size / 2.0))
          var adjusted-center = true-center
          ; check if crosses bottom threshold
          while after?(calc-start(adjusted-center, below-center), bottom-start) :
            adjusted-center = calc-start(adjusted-center, (- DEF_PIN_PADDING))
          ; check if crosses top threshold
          while after?(center-start, calc-start(adjusted-center, (- above-center))) :
            adjusted-center = calc-start(adjusted-center, DEF_PIN_PADDING)
          val adjusted-center-start = calc-start(adjusted-center, (- above-center))
          build-alignment-section(pin-order, offsets, adjusted-center-start)

      val [first-anchor, last-anchor] = [first-anchor(side), last-anchor(side)]
      val top-size =
        match(get?(align-group-offsets(size-info), first-anchor)) :
          (kv: KeyValue<Double,Vector<Double>>) :
            key(kv)
          (f): 0.0
      val bottom-start = calc-start(start, actual-size -
        match(get?(align-group-offsets(size-info), last-anchor)):
          (kv: KeyValue<Double,Vector<Double>>) :
            key(kv)
          (f): 0.0
      )
      val center-start = calc-start(start, top-size)

      ; Build pns for each section
      build-edge-align-group(first-anchor, start)
      build-center-align-group(center-start, bottom-start)
      build-edge-align-group(last-anchor, bottom-start)

  ; finally build pins in each cell
  defn calc-start (base:Point, x-off:Double, y-off:Double) :
    Point(x(base) + x-off, y(base) - y-off)

  var row-offset = 0.0
  for i in 0 to num-rows do :
    val cols =
      if i == 0 or i == num-rows - 1 :
        0 to num-cols
      else if num-cols == 1 :
        [0]
      else :
        [0, num-cols - 1]
    var col-offset = 0.0
    val down = actual-size-by-rcs[RCS(i,0,Left)] + row-offset
    for j in cols do :
      val right = actual-size-by-rcs[RCS(0,j,Up)] + col-offset
      if i == 0 :
        build-cell(i, j, Up, calc-start(top-left, col-offset, row-offset))
      if i == num-rows - 1 :
        build-cell(i, j, Down, calc-start(top-left, col-offset, down))
      if j == 0 :
        build-cell(i, j, Left, calc-start(top-left, col-offset, row-offset))
      if j == num-cols - 1 :
        build-cell(i, j, Right, calc-start(top-left, right, row-offset))
      col-offset = right
    row-offset = down

public defmethod build-artwork (x:BoxSymbolBank, node:SymbolNode) :
  false

public defmethod build-params (x:BoxSymbolBank, sn:SymbolNode) :
  val b = glyph-bounds(sn)
  text(sn, [left(b), up(b) + DESIGNATOR_MARGIN], ">REF", anchor = SW, font-size = 8)
  text(sn, [left(b), down(b) - DESIGNATOR_MARGIN], ">VALUE", anchor = NW, font-size = 8)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

doc: \<DOC>
Find a set of pins that match a particular query

@param b Box Symbol object

@param pattern Glob pattern used to find specific pins by the string variant of the pin reference.
For example, if the there is a pin `D.p[0]`, `D.p[1]`, `D.p[2]`, `M.p[0]`, `M.p[1]` and `M.p[2]`
The user could use a glob pattern `D.p[*]` to select `D.p[0]`, `D.p[1]`, `D.p[2]`

@param bank Optional bank selector so that will limit query to selecting only pins from this particular bank (symbol unit).
@param row Optional row selector that will limit query to selecting only pins from this particular row of the
  box grid.
@param column Optional column selector that will limit query to selecting only pins from this particular column of the box grid.

@return Tuple of Pins that match the given criteria.
<DOC>
defn check-prop (prop: ?, filter: ?) -> True|False :
    match(prop, filter) :
      (n: None, f: One<?>) :
        false
      (n, f: None) :
        true
      (v: One<Int|Ref>, p) :
        value(v) == p
      (n, f) :
        throw $ BoxSymbolApiError("Unsupported args to check-prop %_ %_"
          % [prop, filter])

public defn find-pins-by-regex (
  b:BoxSymbol, pattern:String
  --
  bank:Int|Ref = ?
  row:Int|Ref = ?
  column:Int|Ref = ?
  ) -> Vector<JITXObject> :

  val matches = Vector<Pin>()

  for p in pins(obj(b)) do :
    if (
      check-prop(property?(p.bank), bank)
      and check-prop(property?(p.row), row)
      and check-prop(property?(p.column), column)
      and not empty?(regex-match(pattern, to-string(ref(p))))
    ) :
      add(matches, Pin(local(p)))
  matches

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pin Grid Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

doc: \<DOC>
Check for an active grid

Components like resistors, capacitors, etc might not have an active grid.

@param b Box Symbol object
@return Indicates of a grid is present on this symbol or not.
<DOC>
public defn has-grid? (b:BoxSymbol) -> True|False :
  active-grid?(grid(b))

doc: \<DOC>
Set the grid for a component

@param b Box Symbol object
@param grid Tuple of [row,column] where row & column must be greater than zero.
@param bank bank ID for multi-symbol unit BoxSymbols.
<DOC>
public defn set-grid (b:BoxSymbol, dims:[Int, Int]) :
  if not has-grid?(b) :
    set-dims(grid(b), dims)
    set-active-grid?(grid(b), true)
      ; default unspecified pins to 0, 0
    for p in pins(obj(b)) do :
      set-pin-grid-default(p)
  else :
    throw $ BoxSymbolApiError("Active grid already set to %_" % [grid(b)])
  false

public defn set-grid (b:BoxSymbol, dims:[Int, Int], bank:Int|Ref) :
  if not key?(banks(b), bank) :
    banks(b)[bank] = GridInfo(dims, true)
    ; default unspecified pins to 0, 0
    for p in pins(obj(b)) do :
      match(get-property?(p, BANK_PROP)) :
        (o:One):
          if value(o) == bank :
            set-pin-grid-default(p)
        (f): false
  false

defn set-pin-grid-default (p: JITXObject) :
  if not has-property?(p.row) :
    set-property(p, ROW_PROP, 0)
  if not has-property?(p.col) :
    set-property(p, COL_PROP, 0)

doc: \<DOC>
Get the total number of rows in the pin grid.

This function is for components with only one symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of rows in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-rows (b:BoxSymbol) -> Int:
  dims(grid(b))[0]

doc: \<DOC>
Get the total number of rows in the pin grid of a particular symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of rows in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-rows (b:BoxSymbol, bank:Int|Ref) -> Int:
  match(get?(banks(b), bank)) :
    (gi: GridInfo) :
      dims(gi)[0]
    (f) : 1

doc: \<DOC>
Get the total number of columns in the pin grid.

This function is for components that have only one symbol unit.

@param b Box Symbol object
@return number of columns in the pin grid of component symbol. If no
pin grid is active, this function returns 0.
<DOC>
public defn get-columns (b:BoxSymbol) -> Int:
  dims(grid(b))[1]

doc: \<DOC>
Get the total number of columns in the pin grid of a particular symbol unit.

@param b Box Symbol object
@param bank Selects for a particular symbol unit.
@return number of columns in the pin grid of the given `bank`. If no
pin grid is active for this bank, this function returns 0.
<DOC>
public defn get-columns (b:BoxSymbol, bank:Int|Ref) -> Int:
  match(get?(banks(b), bank)) :
    (gi: GridInfo) :
      dims(gi)[1]
    (f) : 1

doc: \<DOC>
Set the pin grid position for a pin or set of pins.

If the grid doesn't exist yet - this is an error and this function
should throw an exception.

There are only a limited set of valid row/column combinations based on the
edges of the box symbol.

@param pin-set One Pin or a Tuple of Pins present on `obj` that will be added to a group.
@param row Row index into the pin grid.
@param column Column index into the pin grid.
@throws IndexError If either the `row` or `column` are outside the active grid cells
<DOC>
public defn set-grid-edge (row:Int, col:Int, pins: JITXObject ...) :
  set-row(row, pins)
  set-column(col, pins)

doc: \<DOC>
Set the Row assignment for these pins

Typically this would be used when the `side` parameter had already
been set on these pins to `Left` or `Right`. The `side` parameter would
then drive the column assignment to either `0` or `N-1` where N is the number of columns .
<DOC>
public defn set-row (row:Int, pins: JITXObject ...) :
  set-row(row, pins)

public defn set-row (row:Int, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
  check-non-neg(ROW_PROP, row)
  for p in valid-pins do :
    set-property(p, ROW_PROP, row)

doc: \<DOC>
Set the Column assignment for these pins

Typically this would be used when the `side` parameter had already
been set on these pins to `Up` or `Down`. The `side` parameter would
then drive the row assignment to `0` or `M-1` where M is the number of rows.
<DOC>
public defn set-column (col:Int, pins: JITXObject ...) :
  set-column(col, pins)

public defn set-column (col:Int, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
    check-non-neg(COL_PROP, col)
    for p in valid-pins do :
      set-property(p, ROW_PROP, col)

; defn get-row (p:Pin) -> Maybe<Int>:
;   One(0)

; defn get-row! (p:Pin) -> Int:
;   0

; defn get-column (p:Pin) -> Maybe<Int>:
;   One(0)

; defn get-column! (p:Pin) -> Int:
;   0

doc: \<DOC>
Set a horizontal line separator on the edge of a row

@param b Box Symbol object
@param row Row Index into the pin grid.
@param pos Used to select which side of the row (N/S) to draw the separator line. Default value is S
@param bank Optional bank (symbol unit) identifier
@param line-width Width of the separator in symbol grid units
<DOC>
defn set-horz-separator (b:BoxSymbol, row:Int -- pos:Anchor = S , bank:Int|Ref = ?, line-width:Double = 0.05) :
  false

doc: \<DOC>
Set a vertical line separator on the edge of a column

@param b Box Symbol object
@param column Column Index into the pin grid.
@param pos Used to select which side of the column (E/W) to draw the separator line. Default value is E
@param bank Optional bank (symbol unit) identifier
@param line-width Width of the separator in symbol grid units
<DOC>
defn set-vert-separator (b:BoxSymbol, column:Int -- pos:Anchor = E , bank:Int|Ref = ?) :
  false

doc: \<DOC>
Set the side of the box symbol to assign to a pin or set of pins

This function will set the direction and side of the passed pins.

If a `grid` exists - then the appropriate column/row will be selected. For example,
The `Top` side would be given row 0. The `Left` side would be given column 0.
A `Right` side would be given column N-1 where N is the number of columns.

If the `grid` does not exist, then adding a side parameter for a set of pins would begin
constructing the grid. For example, Adding a set of pins on the `Right` and `Left` would
construct a grid of 1 row and 2 columns. Subsequent operations might increase the number of
rows if `Top` and `Bottom` pin sets were added. In this case, the row & column indices for the first group
of `Right` and `Left` pins would need to be modified. They would move from row index 0 to row index 1. The `Right`
side pins would move to column index 2. The `Top` side pins would be in row index 0 and column index 1.

NOTE: If this is too complex - we can add the constraint that the user must add the `grid` first, but in order to
match the existing functionality, I think we would need to support this.

@param pin-set One Pin or a Tuple of Pins present on `obj` that will be added to a side.
@param side Selects the edge of a box symbol on to which the pins will be drawn
<DOC>
public defn set-side (side:Dir, pins: JITXObject ...)  :
  set-side(side, pins)

public defn set-side (side:Dir, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, SIDE_PROP, side)

; defn get-side (p:Pin) -> Maybe<Dir> :
;   One(Left)

; defn get-side! (p:Pin) -> Dir :
;   Left

public defn pins-in-group (b:BoxSymbol, group:String) -> Tuple<JITXObject> :
  to-tuple $ for p in pins(obj(b)) seq? :
    match(get-property?(p, GROUP_PROP)) :
      (one:One)   :
        if value(one) == group :
          One(p)
        else :
          None()
      (none:None) :
        None()

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bank
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public defn set-bank (bank:Int|Ref, pins: JITXObject ...)  :
  set-bank(bank, pins)

public defn set-bank (bank:Int|Ref, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, BANK_PROP, bank)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Alignment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public defn set-alignment (pos:Anchor, pins: JITXObject ...)  :
  set-alignment(pos, pins)

public defn set-alignment (pos:Anchor, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, ALIGN_PROP, pos)

; defn get-alignment (p:Pin) -> Maybe<Anchor> :
;   One(C)

; defn get-alignment! (p:Pin) -> Anchor :
;   C

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Group
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public defn set-group (group:String, pins: JITXObject ...)  :
  set-group(group, pins)

public defn set-group (group:String, pins: Seqable<JITXObject>)  :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, GROUP_PROP, group)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Margin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public defn set-top-margin (margin:Double, pins: JITXObject ...) :
  set-top-margin(margin, pins)

public defn set-top-margin (margin:Double, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, TOP_MARGIN_PROP, margin)

public defn set-bottom-margin (margin:Double, pins: JITXObject ...) :
  set-bottom-margin(margin, pins)

public defn set-bottom-margin (margin:Double, pins: Seqable<JITXObject>) :
  val valid-pins = check-port-type(pins)
  for p in valid-pins do :
    set-property(p, BOTTOM_MARGIN_PROP, margin)

defn set-left-margin (pin-set:Tuple<Pin>|Pin, margin:Double) :
  false

defn set-right-margin (pin-set:Tuple<Pin>|Pin, margin:Double) :
  false


defn set-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-top-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-bottom-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-left-margin (b:BoxSymbol, group:String, margin:Double) :
  false

defn set-right-margin (b:BoxSymbol, group:String, margin:Double) :
  false


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Decorators
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


doc: \<DOC>
Add a particular decorator[s] to the passed pins.

@param b Box Symbol Object
@param pin-set Pin or Set of Pins to add the decorator to.
@param decorators One or More decorators to add to these pins.

NOTE: Multiple decorators may not stack well yet - WIP.
<DOC>
public defn add-decorator (b:BoxSymbol, pin-set: Seqable<JITXObject>, decorators:Seqable<PinDecorator>) :
  val valid-pins = check-port-type(pin-set)
  for p in valid-pins do :
    add-to-vector-table(decorator-by-pin(b), ref(p), decorators)

public defn add-decorator (b:BoxSymbol, p:JITXObject, decorator:PinDecorator) :
  add-decorator(b, [p], [decorator])

;Sort the given pins by their .pin-properties-row-index field.
defn sort-by-row-index (pins:Tuple<JITXObject>) -> Tuple<JITXObject> :
  ;Compare pin[i0] versus pin[i1].
  ;Indices are used, instead of the pin directly, in order to perform a
  ;stable sort.
  ;All pins without a .pin-properties-row-index are put in the beginning.
  defn compare-index (i0:Int, i1:Int) :
    val ai = value?(property?(pins[i0].pin-properties-row-index))
    val bi = value?(property?(pins[i1].pin-properties-row-index))
    match(ai, bi) :
      (ai:Int, bi:Int) : compare(ai, bi)
      (ai:Int, bi) : 1
      (ai, bi:Int) : -1
      (ai, bi) : compare(i0,i1)
  val indices = qsort(0 to length(pins), compare-index)
  map({pins[_]}, indices)

defn round-to-grid (d: Double) -> Double :
  to-double(to-int(d / 0.5)) * 0.5

defn calc-snap-grid-buffer (dim: Double) -> Double :
  ceil(dim / 0.5) * 0.5 - (dim)

public defn assign-symbols (banks:Tuple<KeyValue<Int|Ref, UnitSymbol>>) :
  defn ensure-non-empty-banks! () :
    if empty?(banks) :
      throw(EmptyBanks(""))
  defn ensure-unique-bank-arguments! () :
    val seen-banks = HashSet<Int|Ref>()
    val duplicate-banks = Vector<Int|Ref>()
    for bank-kv in banks do :
      val bank = key(bank-kv)
      if not add(seen-banks, bank) :
        add(duplicate-banks, bank)
    if not empty?(duplicate-banks) :
      throw(DuplicateBanks(to-tuple(duplicate-banks)))
  defn ensure-banks-exist! (pin-banks:Tuple<Maybe>) :
    val banks* = map(key, banks)
    val pin-banks* = unique-banks(pin-banks)
    val extra-banks = difference(banks*, pin-banks*)
    if not empty?(extra-banks) :
      throw(MissingRequestedBanks(qsort(extra-banks)))
    val missing-banks = difference(pin-banks*, banks*)
    if not empty?(missing-banks) :
      throw(MissingBankArguments(qsort(missing-banks)))
  defn ensure-symbol-pins! (pins:Tuple<JITXObject>, pin-banks:Tuple<Maybe>) :
    val bad-matches = to-tuple $
      for bank in banks seq? :
        match(value(bank)) :
          (box:BoxSymbol) : None()
          (symbol:SchematicSymbol) :
            val symbol-pins = to-hashset(ref, /pins(symbol))
            val mismatched-pins = to-tuple $
              for (p in pins, b in pin-banks) seq? :
                val pin-ref = ref(p)
                if value!(b) == bank and not symbol-pins[pin-ref] :
                  One(pin-ref)
                else :
                  None()
            if not empty?(mismatched-pins) :
              One(name(symbol) => to-tuple(mismatched-pins))
            else :
              None()
    if not empty?(bad-matches) :
      throw(MissingSymbolPins(bad-matches))
  ensure-non-empty-banks!()
  ensure-unique-bank-arguments!()
  inside pcb-component :
    val pins = sort-by-row-index(pins(self))
    val pin-sides0 = map({property?(_.side)}, pins)
    val pin-banks = map({property?(_.bank)}, pins)
    val pin-sides = ensure-good-sides!(pins, pin-sides0)
    ensure-good-banks!(pins, pin-banks, true)
    ensure-banks-exist!(pin-banks)
    ensure-symbol-pins!(pins, pin-banks)
    val wrapped-banks =
      for [bank, symbol?] in kvs(banks) seq :
        match(symbol?) :
          (box:BoxSymbol) :
            val entries = for (p in pins, s in pin-sides, b in pin-banks) seq? :
              if value!(b) == bank : One(s => p)
              else : None()
            BoxBank(to-tuple(entries))
          (symbol:SchematicSymbol) :
            val pin-mappings = for (p in pins, b in pin-banks) seq? :
              if value!(b) == bank :
                One(p => dot(symbol, ref(p)))
              else :
                None()
            StandardBank(symbol, to-tuple(pin-mappings))
    make-box-symbol(wrapped-banks)

public deftype UnitSymbol :
  BoxSymbol <: UnitSymbol
  SchematicSymbol <: UnitSymbol

public defstruct BoxBank :
  entries: Collection<KeyValue<Dir,JITXObject|Seqable<JITXObject>>>

public defstruct StandardBank :
  symbol: SchematicSymbol
  pin-mappings: Tuple<KeyValue<JITXObject, JITXObject>>

public defn make-box-symbol (banks:Seqable<BoxBank|StandardBank>) :
  inside pcb-component :
    symbol :
      for (bank in banks, u in 0 to false) do :
        val [sym, mapping] =
          match(bank) :
            ;(bank:BoxBank) : generate-box-symbol-unit(flatten-pin-entries(entries(bank)))
            (bank:StandardBank) : [symbol(bank), pin-mappings(bank)]
        unit(u) = sym(
          for e in mapping do :
            key(e) => value(e))

public pcb-struct ocdb/utils/box-symbol/MissingBankProperty <: Exception :
  pins: Tuple<Ref>

defmethod print (o:OutputStream, e:MissingBankProperty) :
  print(o, "Pins %, do not have a .bank property." % [pins(e)])

public pcb-struct ocdb/utils/box-symbol/MissingBankArguments <: Exception :
  banks: Tuple<Int|Ref>

defmethod print (o:OutputStream, e:MissingBankArguments) :
  print(o, "Banks %, are not found in `make-box-symbol` arguments." % [banks(e)])

public pcb-struct ocdb/utils/box-symbol/MissingRequestedBanks <: Exception :
  banks: Tuple<Int|Ref>

defmethod print (o:OutputStream, e:MissingRequestedBanks) :
  print(o, "Banks %, are not found in any .bank properties." % [banks(e)])

;[TODO] Allow pcb-structs to have no fields.
public pcb-struct ocdb/utils/box-symbol/EmptyBanks <: Exception :
  e: ?

defmethod print (o:OutputStream, e:EmptyBanks) :
  print(o, "`make-box-symbol` bank arguments cannot be empty.")

public pcb-struct ocdb/utils/box-symbol/DuplicateBanks <: Exception :
  banks: Tuple<Int|Ref>

defmethod print (o:OutputStream, e:DuplicateBanks) :
  print(o, "Banks %, are duplicate in `make-box-symbol` arguments." % [banks(e)])

public pcb-struct ocdb/utils/box-symbol/MissingSymbolPins <: Exception :
  missing: Tuple<KeyValue<String, Tuple<Ref>>>

defmethod print (o:OutputStream, e:MissingSymbolPins) :
  defn format (kv:KeyValue<String, Tuple<Ref>>) -> Printable :
    "pcb-symbol %~ is missing pin(s) %," % [key(kv), value(kv)]
  val error-str = \<S>`make-box-symbol` requires component pin names to match symbol pin names:
%n<S> % [map(Indented{format(_)}, missing(e))]
  print(o, error-str)

defn ensure-good-banks! (pins:Tuple<JITXObject>,
                         banks:Tuple<Maybe>,
                         require-banks?:True|False) :
  ;Check that all pins.banks are either Int|Ref or not given.
  for (p in pins, b in banks) do :
    ;[TODO] Why is `false` allowed?
    if value?(b) is-not Int|Ref|False :
      throw(IncorrectBankProperty(ref(p), object-type(value?(b))))
  ;Check that all banks given or no banks given (if not required).
  if none?(empty?, banks) :
    false
  else :
    val ps = to-tuple $ for (p in pins, b in banks) seq? :
      if empty?(b) : One(ref(p))
      else : None()
    if require-banks? and empty?(ps) :
      throw(MissingBankProperty(ps))

defn ensure-good-sides! (pins:Tuple<JITXObject>, sides:Tuple<Maybe>) -> Tuple<Dir> :
  ;Check that all pins.side is either Dir or not given.
  for (p in pins, s in sides) do :
    ;[TODO] Why is `false` allowed?
    if value?(s) is-not Dir|False :
      throw(IncorrectSideProperty(ref(p), object-type(value?(s))))
  ;Default side is Right
  if all?(empty?, sides) :
    map({Right}, pins)
  else if none?(empty?, sides) :
    map(value!, sides)
  else :
    val ps = for (p in pins, s in sides) seq? :
      if empty?(s) : One(ref(p))
      else : None()
    throw(MissingSideProperty(to-tuple(ps)))

defn flatten-pin-entries (es:Seqable<KeyValue<Dir,JITXObject|Seqable<JITXObject>>>) -> Vector<KeyValue<Dir,Pin>> :
  val entries = Vector<KeyValue<Dir,Pin>>()
  for e in es do :
    match(value(e)) :
      (p:Pin) : add(entries, key(e) => p)
      (ps:Seqable<Pin>) : do(add{entries, key(e) => _}, ps)
  entries

;============================================================
;====================== Errors ==============================
;============================================================
deftype BoxSymbolError <: Exception
defmulti message (e: BoxSymbolError) -> ?

defstruct BoxSymbolApiError <: BoxSymbolError :
  message: ? with : (as-method => true)

defstruct BoxSymbolParamError <: BoxSymbolError :
  message: ? with : (as-method => true)

defmethod print (o:OutputStream, e:BoxSymbolApiError) :
  print(o, "BoxSymbol API error: %_" % [message(e)])

defmethod print (o:OutputStream, e:BoxSymbolParamError) :
  print(o, "BoxSymbol invalid param: %_" % [message(e)])

public pcb-struct ocdb/utils/box-symbol/IncorrectSideProperty <: Exception :
  pin: Ref
  actual-type: String

defmethod print (o:OutputStream, e:IncorrectSideProperty) :
  print(o, "Property %_.side is expected to be a Dir object but is instead of type %_." % [
    pin(e), actual-type(e)])

public pcb-struct ocdb/utils/box-symbol/MissingSideProperty <: Exception :
  pins: Tuple<Ref>

defmethod print (o:OutputStream, e:MissingSideProperty) :
  print(o, "Pins %, do not have a .side property." % [pins(e)])

public pcb-struct ocdb/utils/box-symbol/IncorrectBankProperty <: Exception :
  pin: Ref
  actual-type: String

defmethod print (o:OutputStream, e:IncorrectBankProperty) :
  print(o, "Property %_.bank is expected to be a Int|Ref object but is instead of type %_." % [
    pin(e), actual-type(e)])

defn unique-banks (banks:Tuple<Maybe>) :
  val banks* = to-vector<Int|Ref> $ to-hashset<Int|Ref> $
    for b in banks seq :
      match(b) :
        (o:One) : value(o)
        (n:None) : throw $ Exception("One or more pins found with no banks")
  defn compare-bank (x:Int|Ref, y:Int|Ref) -> Int :
    defn rank (x:Int|Ref) :
      match(x) :
        (x:Int) : 0
        (x:Ref) : 1
    val c = compare(rank(x), rank(y))
    if c == 0 : compare(x, y)
    else : c
  qsort!(banks*, compare-bank)
  banks*