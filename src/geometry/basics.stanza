#use-added-syntax(jitx)
defpackage jsl/geometry/basics:
  import core
  import jitx
  import jitx/commands

; TODO -
;   I want to refactor the shape definitions in esir.stanza:
;   1.  We keep the form of `Shape(anchor:Anchor, args ...)` - this is useful for
;       reducing a lot of the duplicative `anchor = anchor` code.
;   2   We add a `Shape(args, ..., anchor:Anchor = C)` variant to all
;       so that the user can optional include an `anchor = C` in their
;       code.
public defn Capsule (size:Dims -- anchor:Anchor = C):
  Capsule(anchor, x(size), y(size))

public defn Rectangle (size:Dims -- anchor:Anchor = C):
  Rectangle(anchor, x(size), y(size))

public defn RoundedRectangle (size:Dims, r:Double -- anchor:Anchor = C):
  RoundedRectangle(anchor, x(size), y(size), r)

public defn ChamferedRectangle (size:Dims, r:Double -- anchor:Anchor = C):
  ChamferedRectangle(anchor, x(size), y(size), r)

public defn DShape (size:Dims, r:Double -- anchor:Anchor = C):
  DShape(anchor, x(size), y(size), r)

public defn GeneralRoundedRectangle (size:Dims, r:Double, m:CornerModifier -- anchor:Anchor = C) :
  GeneralRoundedRectangle(anchor, x(size), y(size), r, m)

public defn GeneralRoundedRectangle (size:Dims, r:Tuple<Double> -- anchor:Anchor = C) :
  GeneralRoundedRectangle(anchor, x(size), y(size), r)

public defn GeneralChamferedRectangle (size:Dims, r:Double, m:CornerModifier -- anchor:Anchor = C) :
  GeneralChamferedRectangle(anchor, x(size), y(size), r, m)

public defn GeneralChamferedRectangle (size:Dims, r:Tuple<Double> -- anchor:Anchor = C) :
  GeneralChamferedRectangle(anchor, x(size), y(size), r)

; TODO - this conflicts with the circle definition
;   in `esir.stanza`

; public defn Circle (radius:Double -- anchor:Anchor = C):
;   Circle(anchor, radius)


doc: \<DOC>
Expand for Union shapes

This is provides an implementation that supports `Union` by recursively
applying the `expand` operation on all shapes in the Union.
<DOC>
public defn expand-union (x:Shape|Union, amount:Double) -> Shape:
  match(x):
    (U:Union):
      Union $ for obj in shapes(U) seq:
        expand-union(obj, amount)
    (y:Shape): expand(y, amount)

doc: \<DOC>
Increase the size of a `Dims` by `amount` on all sides

Effective width and height are larger by `2.0 * amount`

@param d Originating `Dims` instance that this method will expand.
@param amount quantity for expansion on all sides.
<DOC>
public defn expand (d:Dims, amount:Double) -> Dims :
  val r2 = amount * 2.0
  Dims(x(d) + r2, y(d) + r2)

doc: \<DOC>
Increase the size of a `Dims` by different x and y amounts.

@param d Originating `Dims` instance that this method will expand.
@param amount `Dims` that encodes the expansion amount of the X and Y
  axis as two different values.
<DOC>
public defn expand (d:Dims, amount:Dims) -> Dims :
  Dims(x(d) + (x(amount) * 2.0), y(d) + (y(amount) * 2.0))

doc: \<DOC>
Compute the bounding Dims object that encapsulates the sequence of passed Dims.

@param objs The set of objects that will be reviewed.
@param expand-by Add additional margin on all sides by this amount.
The resultant `Dims` object will be `2.0 * expand-by` greater than
the maximum outline
  Default value is 0.0.
<DOC>
public defn bounds (
  objs:Collection<Dims>
  --
  expand-by:Double = 0.0
  ) -> Dims:
  val max-X = maximum(x, objs)
  val max-Y = maximum(y, objs)
  expand{_, expand-by} $ Dims(x(max-X), y(max-Y))

doc: \<DOC>
Is B entirely enclosed by A ?
<DOC>
public defn contains? (a:Dims, b:Dims) -> True|False :
  (x(a) > x(b)) and (y(a) > y(b))

doc: \<DOC>
Diameter to Radius Converter
<DOC>
public defn to-radius (diam:Double) -> Double : diam / 2.0

