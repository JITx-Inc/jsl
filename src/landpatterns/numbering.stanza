#use-added-syntax(jitx)
defpackage jsl/landpatterns/numbering:
  import core
  import math

  import jitx
  import jsl/ensure
  import jsl/landpatterns/helpers
  import jsl/errors

doc: \<DOC>
Numbering Scheme for a Set of Pads

The landpattern generators typically use a 2D grid to generate
the pads related to a component. This grid is a zero-index
row and column setup.

-  For DIP style components (SOP, SOIC, DFN/SON, etc ), there are typically
  2 columns and `N / 2` rows (where `N` is the number of pins).
-  For Quad style components (QFP, QFN, etc), there are typically
  4 columns and `N / 4` rows (where `N` is the number of pins).
-  For BGA style components, there are typically N pins and X columns by Y rows
  where X * Y = N (for a Full Matrix). This is only example to demonstrate the
  typical row and column configurations. More complex arrangements are possible.

Note that this numbering scheme does not consider the exposed thermal lead/pad
to be part of the pin numbering sequence.

<DOC>
public deftype Numbering

doc: \<DOC>
Convert the row and column indices into a pad number or reference

@param x Self
@param row Zero-based row offset into the pad grid
@param column Zero-based column offset into the pad grid.
@return Either an Int or a {@link Ref} that determines the
  pad identifier or name.
<DOC>
public defmulti to-pad-id (x:Numbering, row:Int, column:Int) -> Int|Ref

; Default for Std IC Numbering
val DUAL-ROW-COLS = 2

doc: \<DOC>
Standard IC Numbering

TODO: Figure here

@param num-pads Total number of pads of the grid assuming that all
  of the grid placements are active. This function assumes that the
  device has only two columns and an equal number of rows in each
  column.
<DOC>
public defstruct Std-IC-Numbering <: Numbering :
  num-pads:Int with: (ensure => ensure-even-positive!)

defn check-valid-rc (rows:Int, r:Int, c:Int) :
  if (r < 0 or c < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [r,c])

  if not (r < rows):
    throw $ ValueError("Invalid Row Offset: %_ < %_" % [r, rows])

  if not (c < DUAL-ROW-COLS):
    throw $ ValueError("Invalid Column Offset: %_ < %_" % [c, DUAL-ROW-COLS])

public defmethod to-pad-id (x:Std-IC-Numbering, row:Int, column:Int) -> Int|Ref :
  val rows = num-pads(x) / DUAL-ROW-COLS
  check-valid-rc(rows, row, column)

  if column == 0:
    row + 1
  else:
    num-pads(x) - row

doc: \<DOC>
Row Major Pad Numbering

Example for 2-column grid:
```
    1    2
    3    4
    5    6
    ...
```
@param num-pads Total number of pads of the grid assuming that all
  of the grid placements are active. This function assumes that all
  rows have an equal number of columns.
@param num-rows Total number of rows of pads in the grid.
@throws ValueError If num-pads is not divisible by num-rows.
<DOC>
public defstruct Row-Major-Numbering <: Numbering :
  num-pads:Int with: (ensure => ensure-positive!)
  num-rows:Int with: (ensure => ensure-positive!)
with:
  constructor => #Row-Major-Numbering

public defn Row-Major-Numbering (num-pads:Int, num-rows:Int) -> Row-Major-Numbering :
  ensure-divisible!(num-pads, num-rows, "Row-Major-Numbering")
  #Row-Major-Numbering(num-pads, num-rows)

public defmethod to-pad-id (x:Row-Major-Numbering, row:Int, column:Int) -> Int|Ref :
  val rows = num-rows(x)
  val cols = num-pads(x) / rows

  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if not (row < rows):
    throw $ ValueError("Invalid Row Offset: %_ < %_" % [row, rows])

  if not (column < cols):
    throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])

  (row * cols) + column + 1

doc: \<DOC>
Column Major Pad Numbering

Example for 2-column grid:
  ```
    1   5
    2   6
    3   7
    4   8
  ```
@param num-pads Total number of pads of the grid assuming that all
  of the grid placements are active. This function assumes that all
  columns have an equal number of rows.
@param num-columns Total number of columns in the grid.
@throws ValueError If num-pads is not divisible by num-columns.
<DOC>
public defstruct Column-Major-Numbering <: Numbering :
  num-pads:Int with: (ensure => ensure-positive!)
  num-columns:Int with: (ensure => ensure-positive!)
with:
  constructor => #Column-Major-Numbering

public defn Column-Major-Numbering (num-pads:Int, num-columns:Int) -> Column-Major-Numbering :
  ensure-divisible!(num-pads, num-columns, "Column-Major-Numbering")
  #Column-Major-Numbering(num-pads, num-columns)

public defmethod to-pad-id (x:Column-Major-Numbering, row:Int, column:Int) -> Int|Ref :
  val cols = num-columns(x)
  val rows = num-pads(x) / cols

  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if not (row < rows):
    throw $ ValueError("Invalid Row Offset: %_ < %_" % [row, rows])

  if not (column < cols):
    throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])

  (column * rows) + row + 1

doc: \<DOC>
Uneven (Asymmetric) Column Major Numbering

This provides a mechanism to create a column major
numbering scheme where each column may not have the exact
same number of rows.
<DOC>
public defstruct Uneven-Column-Major-Numbering <: Numbering :
  columns:Tuple<Int>

doc: \<DOC>
Construct an Uneven Column Structure for Quad Packages

This will construct a asymmetric column major numbering that
expects (2 * x-count) + (2 * y-count) total unique leads in the package.

@param x-count Number of leads on the E/W sides of the package
@param y-count Number of leads on the N/S side of the package.
<DOC>
public defn Uneven-Column-Major-Numbering (x-count:Int, y-count:Int) -> Uneven-Column-Major-Numbering :
  Uneven-Column-Major-Numbering([x-count, y-count, x-count, y-count])

public defmethod to-pad-id (x:Uneven-Column-Major-Numbering, row:Int, column:Int) -> Int|Ref :
  val c-set = columns(x)
  val cols = length(c-set)
  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if not (column < cols):
    throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])

  val rows = c-set[column]
  if not (row < rows):
    throw $ ValueError("Invalid Row Offset: %_ < %_" % [row, rows])

  val offset = sum(c-set[0 to column]) when column > 0 else 0
  offset + row + 1

public defn get-total-pads (x:Uneven-Column-Major-Numbering) -> Int :
  sum(columns(x))

val DEF-ROW-OMITS = "IOQSXZ"

doc: \<DOC>
Create pad Ref sequence for a 2-axis Grid (eg for BGAs)
The created references use a {@link IndexRef} consisting of
a letter for the row indicator and a number index for the column.
For example:
  row=1, column=1 =>  `A[1]`
  row=2, column=7 =>  `B[7]`
  row=21, column=3 => `AA[3]`

Note that the final example assumes the default omit character
  sequence.

The `start-row` and `start-col` parameters are used to
offset the numbering generation. For example - lets say you
wanted to have a 5x5 grid but start with row 'C' and column 5,
Setting `start-row = 2` and `start-col = 4` (zero-indexed).
This results in a grid with rows C, D, E, F, G and columns
5, 6, 7, 8, 9.
<DOC>
public defstruct Grid-Numbering <: Numbering :
  doc: \<DOC>
  Number of Rows in the Grid
  <DOC>
  rows:Int
  doc: \<DOC>
  Number of Columns in the Grid
  <DOC>
  columns:Int
  doc: \<DOC>
  Set the starting row offset.
  Default is 0, which is typically maps to 'A' unless
  the `omit-rows` contains 'A'.
  <DOC>
  start-row:Int
  doc: \<DOC>
  Set the starting column offset/
  Default is 0, which is typically the first column index.
  <DOC>
  start-col:Int
  doc: \<DOC>
  List of letters to not uses as the row id in the generated
  pad reference. By default this is set to "IOQSXZ" by IPC7351B.
  For example, this means that the row sequence will consist of:
    ... G, H, J ...
  Where `I` is absent
  <DOC>
  omit-rows:String
  doc: \<DOC>
  Lookup table for converting row/column indices to a Ref.
  This lookup is pre-computed based on the `rows/columns/etc`
  <DOC>
  pad-lookup:Tuple<Ref>
with:
  constructor => #Grid-Numbering

public defn Grid-Numbering (
  rows:Int,
  columns:Int,
  start-row:Int = 0,
  start-col:Int = 0,
  omit-rows:String = DEF-ROW-OMITS
  ) -> Grid-Numbering:

  ensure-positive!("Grid-Numbering:rows", rows)
  ensure-positive!("Grid-Numbering:columns", columns)
  ensure-non-negative!("Grid-Numbering:start-row", start-row)
  ensure-non-negative!("Grid-Numbering:start-col", start-col)

  val pad-names = create-pad-lookup(rows, columns, start-row, start-col, omit-rows)

  #Grid-Numbering(rows, columns, start-row, start-col, omit-rows, pad-names)

public defmethod to-pad-id (g:Grid-Numbering, row:Int, column:Int) -> Int|Ref :
  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if not (row < rows(g)):
    throw $ ValueError("Invalid Row Offset: %_ < %_" % [row, rows(g)])

  val cols = columns(g)
  if not (column < cols):
    throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])

  val index = ( (row * cols) + column)
  pad-lookup(g)[index]

doc: \<DOC>
Given a Row Letter, convert to an Int offset in 0-index form

@param g Grid Numbering Scheme
@param row identifies which row we are attempting to convert
@param Offset which will take into a account the omitted
<DOC>
public defn to-row-index (g:Grid-Numbering, row:Ref|String) -> Int :
  val raw-letters = compute-letters(omit-rows(g))
  val start = start-row(g)
  val end = min(start + rows(g), length(raw-letters))
  val letters = raw-letters[start to end]

  val row*:String = to-string $ match(row):
    (r:VarRef): name(r)
    (r:IndexRef): name $ (ref(r) as VarRef)
    (s:String): s

  val offsets = to-tuple $ for i in 0 to length(row*) seq:
    val curr-letter = row*[i]
    val id = for letter in letters index-when :
      letter == curr-letter
    match(id):
      (x:Int): x
      (x:False):
        throw $ ValueError("Row Letter '%_' Is Invalid - Expected: %, " % [curr-letter, letters])

  val num-letters = to-double $ length(letters)
  val ret = to-int $ sum $ for (offset in in-reverse(offsets), i in 0 to false) seq:
    to-double(offset + 1) * pow(num-letters, to-double(i))

  if ret > rows(g):
    throw $ ValueError("Row Letter '%_' is Out of Range" % [row])

  ret - 1

doc: \<DOC>
Compute the row range based on the start and end character.

This is a utility function for constructing the `Range` for the
row offsets (ie, Int values) from the character values.

@param grid Grid Numbering Scheme
@param start First row as a character or sequence of characters.
@param end Inclusive end row as a character or sequence of characters.
@return The resultant range is a 1-based index to match the `PadIsland`
constructor interface.
<DOC>
public defn to-row-range (grid:Grid-Numbering, start:Char|String, end:Char|String) -> Range :
  val s = to-string(start)
  val e = to-string(end)

  val row-start = to-row-index(grid, s)
  val row-end = to-row-index(grid, e)

  (row-start + 1) through (row-end + 1)

defn compute-letters (omit-rows:String) -> Tuple<Char> :
  val omits = upper-case(omit-rows)
  to-tuple $ for ch in make-letter-seq('A', 'Z') filter:
      not contains?(omits, ch)

defn create-pad-lookup (
  rows:Int,
  columns:Int,
  start-row:Int = 0,
  start-col:Int = 0,
  omit-rows:String = DEF-ROW-OMITS
  ) -> Tuple<Ref> :
  val letters = compute-letters(omit-rows)
  ; Pre-compute the lookup table for the
  ;  grid of references.
  val pad-names = to-tuple $
  for (row in start-row to (start-row + rows)) seq-cat:
    val row-name = Ref(lookup-row-name(row, letters))
    for col in start-col to (start-col + columns) seq:
      row-name[col + 1]
  pad-names

doc: \<DOC>
Returns the name of a row given its index and a list of omitted
characters.

The algorithm is a realization of this description from JEDEC JC-11:

> When a package is viewed ... with the A1 corner in the upper left position,
> terminal rows are lettered from top to bottom starting with A and
> terminal columns are numbered from left to right starting with 1.
> ... For packages with greater than 20 rows (i.e.,  following rows W and Y),
> the 21st row is designated AA and subsequent rows are designated AB, AC, etc.

The modification is we abstract over the omitted characters to support non-
standard naming conventions.

@param idx This index value is 0-based
@param table Available characters from which we can select
row character reference prefixes.
<DOC>
defn lookup-row-name (idx:Int, table:Tuple<Char>) -> String:
  val buffer = StringBuffer()
  let loop (i:Int = idx) :
    val rem = i / length(table)
    val char-index = i % length(table)
    loop(rem - 1) when rem > 0
    print(buffer, table[char-index])
  to-string(buffer)

doc: \<DOC>
Cathode/Anode Numbering Scheme

This numbering scheme is used for any two-pin component with
polarity. This allows us to differentiate the positive (anode, `a`) from the
negative (cathode, `c`) terminals.
<DOC>
public deftype C-A-Numbering <: Numbering

public defn C-A-Numbering () -> C-A-Numbering :
  new C-A-Numbering

public defmethod to-pad-id (x:C-A-Numbering, row:Int, column:Int) -> Int|Ref :
  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if (row > 1 or column > 0):
    throw $ ValueError("Invalid Row or Column Index: r=%_ in [0,1] or c=%_ in [0]" % [row, column])

  if row == 0: Ref("a")
  else: Ref("c")