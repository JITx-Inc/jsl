doc: \<DOC>
@title Pad Planner
@brief How & Where to Place Pads
@desc

When building complex landpatterns, we are often faced with
cases where the package for a particular component does
something out of the ordinary. You will often run into this
when looking at BGA packages where some subset of the balls
in a grid may be depopulated. Sometimes this is pretty
straight forward like for a thermally enhanced BGA pattern:

TODO - Figure here showing a thermally enhanced BGA

Other times, it can be more off the beaten path:

TODO - Figure here showing the Dialog chip with offset
  sub-grid of balls.

Regardless, we need tools to instructs the JITX environment
how to place the pads we need for a particular component. This
is where the "Pad Planner" comes in.

Pad Planner is a piece of code that tells the land pattern generator:

1.  Whether or not to place a pad at a particular location.
2.  The features of the pad to place at a particular location.

In order for the Pad Planner to provide good guidance, we have to
have a common understanding between the generator and the planner:

1.  The pads for a landpattern are generally going to be in a grid of some sort.
  1.  BGA packages have an obvious 2D grid.
  2.  Quad Packages (QFP, QFN, etc) also have a 2D grid but it isn't quite as obvious.
  3.  The Pad Planner makes the assumption that the pads of a component are arranged in
  a 2D grid with rows and columns.
2.  A common shape characteristic
  1.  Many landpatterns use {@link Rectangle} for the shape of their pads.
  2.  Sometimes we might want to use {@link RoundedRectangle} or {@link Capsule}.
  3.  The Pad Planner makes the assumption that each pad's geometry will be described
  by a {@link Dims} object. This means that if we want to provide different shapes,
  we have to shim them into accepting a {@link Dims} object.
  4.  Shape Orientation - The Pad Planner doesn't actually care about this but the
  shapes generated by it need to align with the package's needs. The Pad Planner
  shapes will be aligned with the Dims object. The Package's land pattern generator
  is responsible for making sure that the `x` dimension of the shape corresponds with
  the `lead-length` direction, andn the `y` dimension corresponds with the `lead-width` direction.

<DOC>
#use-added-syntax(jitx)
defpackage jsl/landpatterns/pad-planner:
  import core
  import jitx with:
    prefix(Rectangle) => jitx-
  import jsl/landpatterns/pads
  import jsl/geometry/basics

doc: \<DOC>
Pad Planner Base Type

This defines the interface for a Pad Planner. The Pad Planner
is consulted by the landpattern generator when determing
what pads to create and what shape those pads should have.
<DOC>
public deftype PadPlanner

doc: \<DOC>
Check if this package grid location is active.

In this context, `active` means that there should be a copper
pad at this location. `inactive` means that no copper pad should be
placed at this location.

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Pad Grid location is Active.
<DOC>
public defmulti active? (x:PadPlanner, row:Int, column:Int) -> True|False

doc: \<DOC>
Retrieve the Shape Generator for this grid position

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Shape Generator function with declared signature. This function
will accept the following arguments:

-  Dims - Size of the generated pad

This function will return a `Shape` object with those properties. Note that
the shape should have its own internal `Pose` object so that this method
could add a custom offset if needed.
<DOC>
public defmulti shape-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False

doc: \<DOC>
Retrieve the Pad Generator for this grid position

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Pad Generator function with declared signature. This function
will accept the following arguments:

-  Dims - Size of the generated pad

This function will return a `pcb-pad` definition which uses the
shape provided by `shape-generator`.
<DOC>
public defmulti pad-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Pad)|False

doc: \<DOC>
Default implementation for the `pad-generator`

By default, this function will use the {@link smd-pad} generator
for creating the pad definition. The default soldermask and
pastemask settings will be used.
<DOC>
public defmethod pad-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Pad)|False:
  val func = shape-generator(x, row, column)
  match(func):
    (x:False): false
    (f): smd-pad{f(_0)}


doc: \<DOC>
Through-hole Pad Generator
This function is an alternate to the `pad-generator` function. This
function is used to generate through-hole pads where the `pad-generator`
is for SMT pads.

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Pad Generator function with declared signature. This function
will accept the following arguments:

-  hole:Dims - Size of the plated-through hole (not accounting for plating)
-  copper:Dims - Size of the pad annulus for the hole.

This function will return a `pcb-pad` definition which uses the
shape provided by `shape-generator` and the hole provided by `hole-generator`.
<DOC>
public defmulti th-pad-generator (x:PadPlanner, row:Int, column:Int) -> ( (Dims, Dims) -> Pad )|False

doc: \<DOC>
Default Through-Hole Pad Generator
The default implementation will generate either plated or non-plated holes
depending on whether the `shape-generator` returns true or false.
For non-plated holes - the `copper:Dims` argument will be ignored.

If the user tries to use `th-pad-generator` when `hole-generator`
returns false - then no pad is created.
<DOC>
public defmethod th-pad-generator (x:PadPlanner, row:Int, column:Int) -> ( (Dims, Dims) -> Pad )|False :
  val shape-gen = shape-generator(x, row, column)
  val hole-gen = hole-generator(x, row, column)


  match(active?(x, row, column), shape-gen, hole-gen):
    (a:False, f, h): false
    (a:True, f:(Dims -> Shape), h:(Dims -> Shape)):
      pth-pad{h(_0), f(_1)}
    (a:True, f:False, h:(Dims -> Shape)):
      defn npth-gen (hole:Dims, copper:Dims) -> Pad :
        npth-pad(h(hole))
      npth-gen
    (a:True, f, h):
      ; TODO - Log Warning Here ?
      ; this is a exceptional case but I'm not sure it is an error
      false

doc: \<DOC>
Hole Shape for Pad
This function provides the user with the ability to create a
plated through-hole pad instead of an SMT pad.

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.

@return If this function returns `false` then no hole is created.
Otherwise, if a the function returns a shape, then holes of that
shape will be created. Note - that you can pass any shape here but
your fabricator may have limitations on what shapes it can create.

TODO - Should we make this return `Circle|Capsule` instead of `Shape` ?
  Holes in the board generally speaking are very expensive to make in
  other shapes but I don't necessarily want to limit things here.
  Perhaps with make non-Circle/Capsule shaped holes a check that is
  disable-able so that the user can override.
<DOC>
public defmulti hole-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False

doc: \<DOC>
Default `hole-shape` - No Holes Created.
@return Always `false`
<DOC>
public defmethod hole-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False :
  false

doc: \<DOC>
Pad Planner that always returns a Shape Converter

This is a default implementation of the PadPlanner interface
for swapping a particular shape for all pads in a landpattern.

This is useful for when you don't want to use `Rectangle`
(the typical default) and you want to replace it with
say `RoundedRectangle`.
<DOC>
public defstruct ShapePadPlanner <: PadPlanner :
  shaper:(Dims -> Shape)

public defmethod active? (x:ShapePadPlanner, row:Int, column:Int) -> True|False :
  true

public defmethod shape-generator (x:ShapePadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  if active?(x, row, column): shaper(x)
  else: false

public val rect-shaper:(Dims -> Shape) = Rectangle ;  {Rectangle(_0)}

public val RectanglePadPlanner = ShapePadPlanner(rect-shaper)

public defn round-rect-shaper (radius:Double) -> (Dims -> Shape) :
  {RoundedRectangle(x(_0), y(_0), radius)}

public defn RoundedRectanglePadPlanner (radius:Double) -> ShapePadPlanner :
  ShapePadPlanner( round-rect-shaper(radius) )

; TODO ChamferredRectangle
; TODO Capsule

public defstruct Pin1-PadPlanner <: PadPlanner :
  pin1-shaper:(Dims -> Shape)
  shaper:(Dims -> Shape)

public defmethod active? (x:Pin1-PadPlanner, row:Int, column:Int) -> True|False :
  true

public defmethod shape-generator (x:Pin1-PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  if active?(x, row, column):
    if column == 0 and row == 0: pin1-shaper(x)
    else: shaper(x)
  else: false

; TODO - Corner Pin Shapers
;  Make different pad shapes (possibly with pose offsets)
;  in the corner pads of say a QFN or QFP


doc: \<DOC>
Plated Through-Hole Pad Planner

Basic Pad Planner for PTH pads. This asssumes the hole size
is the same for all grid locations.
<DOC>
public defstruct PthPadPlanner <: ShapePadPlanner:
  doc: \<DOC>
  Copper pad shape
  Both top and bottom copper for the PTH will
  have the same shape.
  <DOC>
  shaper:(Dims -> Shape) with: (as-method => true)

doc: \<DOC>
Shape generator for Circle/Capsule

For through-holes, the most common shapes are circles and
slots. This is a helper function for creating those patterns
in the PthPadPlanner
<DOC>
public defn to-CircleOrCapsule (d:Dims) -> Shape :
  ; TODO - we may need to be more careful here
  ;  comparison between doubles isn't always a good check
  if x(d) != y(d):
    Capsule(d)
  else:
    Circle(to-radius $ x(d))

public defmethod hole-generator (x:PthPadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  to-CircleOrCapsule

public defn PthPadPlanner () -> PthPadPlanner :
  PthPadPlanner(to-CircleOrCapsule)