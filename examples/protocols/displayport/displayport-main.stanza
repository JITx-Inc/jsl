#use-added-syntax(jitx)
defpackage jsl/examples/protocols/displayport/main:
  import core
  import collections
  import jitx
  import jitx/commands


  import jsl/design/settings
  import jsl/symbols/SymbolDefn
  import jsl/symbols/capacitors
  import jsl/symbols/resistors
  import jsl/landpatterns/packages
  import jsl/landpatterns/two-pin/SMT

  import jsl/protocols/displayport
  import jsl/si/helpers

  import jsl/examples/protocols/displayport/displayport-board
  import jsl/examples/protocols/displayport/displayport-src


public pcb-component block-cap :
  name = "block-cap"
  manufacturer = "KYOCERA AVX"
  mpn = "02016D224MAT2A"
  emodel = Capacitor(2.2e-07, 0.2, 6.3, false)
  datasheet = "http://datasheets.avx.com/cx5r.pdf"
  reference-prefix = "C"

  pin-properties :
    [pin:Ref | pads:Ref ... ]
    [p[1] | p[1] ]
    [p[2] | p[2] ]

  val symb = CapacitorSymbol()
  assign-symbol(create-symbol(symb))

  val pkg = SMT-Chip(
    chips["0201"],
    density-level = DensityLevelB
  )

  val lp = create-landpattern(pkg)
  assign-landpattern(lp)

  ; adding a pin model to the pins of this component allow si constraints
  ; to be propagated through this component correctly. Obviously the values
  ; used for this component are just placeholders.

  pin-model(self.p[1] self.p[2]) = PinModel(typ(0.0), typ(0.0))

public pcb-component pu-res :
  name = "pull-up res"
  manufacturer = "KYOCERA AVX"
  mpn = "02016D224MAT2A"
  emodel = Resistor(50.0e3)
  datasheet = "http://datasheets.avx.com/cx5r.pdf"
  reference-prefix = "R"

  pin-properties :
    [pin:Ref | pads:Ref ... ]
    [p[1] | p[1] ]
    [p[2] | p[2] ]

  val symb = ResistorSymbol()
  assign-symbol(create-symbol(symb))

  val pkg = SMT-Chip(
    chips["0201"],
    density-level = DensityLevelB
  )

  val lp = create-landpattern(pkg)
  assign-landpattern(lp)

  ; adding a pin model to the pins of this component allow si constraints
  ; to be propagated through this component correctly. Obviously the values
  ; used for this component are just placeholders.

  pin-model(self.p[1] self.p[2]) = PinModel(typ(0.0), typ(0.0))


pcb-module displayport-example :
  pin VDD
  pin GND

  inst dut1 : jsl/examples/protocols/displayport/displayport-src/module(source = true)
  inst dut2 : jsl/examples/protocols/displayport/displayport-src/module(source = false)

  require src : displayport from dut1
  require dst : displayport from dut2

  val gen = DP1p4

  val [skew, loss] = displayport-get-skew-loss-vals(gen)

  connect-displayport(skew, loss, pu-res, VDD, block-cap, src, dst)
  displayport-apply-routing-structure(diff, src, dst)

  net (VDD dut1.VDD dut2.VDD)
  net (GND dut1.GND dut2.GND)

set-current-design("displayport-example")
setup-board()
; Set the schematic sheet size
set-paper(ANSI-A)

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(displayport-example)

; View the results
view-board()
; view-schematic()
view-design-explorer()
; view-bom(BOM-STD)
