#use-added-syntax(jitx)
defpackage jsl/landpatterns/BGA:
  import core
  import math
  import collections
  import jitx with:
    ; @NOTE - this is due to the way that I want the optional
    ;   args to work with `anchor`.
    prefix(Rectangle) => jitx-

  import jitx/commands

  import jsl/design/settings
  import jsl/geometry/basics
  import jsl/landpatterns/helpers
  import jsl/landpatterns/leads
  import jsl/errors

public pcb-enum jsl/landpatterns/BGA/BGAPadType:
  SolderMaskDefined,
  NonSolderMaskDefined,
  ; TODO Collapsible seems to be the same as `NonSolderMaskDefined`
  ; @see https://e2e.ti.com/support/power-management-group/power-management/f/power-management-forum/549723/how-do-we-know-bga-is-collapsing-or-noncollapsing-bga-balls
  ; @see https://www.pcblibraries.com/Forum/collapsing-vs-noncollapsing-bga-balls_topic1868.html
  ; Seems to only be for larger BGA pitches
  ; Seems to come from the physical phenomenon where the ball flows around the pad and
  ;  collapses on the pad, swallowing it.
  ; In Soldermask defined pads - this doesn't happen because of the surface tension and the
  ;  soldermask trapping the solder.
  Collapsible

defn default-mask-registration () -> Double:
  clearance(current-rules(), SolderMaskRegistration)

; TODO - why is `typical-ball-diameter` not a Toleranced ?
; TODO - where does this calculation come from.

doc: \<DOC>
BGA Pad Definition
@param typical-ball-diameter
@param pad-type
@param solder-mask-registration
@param density-level
<DOC>
pcb-pad bga-pad (typical-ball-diameter:Double,      ; the typical/nominal size of the bga balls
                 pad-type:BGAPadType,               ; the bga pad type, (collapsible, solder mask defined, or non-soldermask defined)
                 solder-mask-registration:Double = default-mask-registration()   ; the solder-mask registration of the design
                 density-level:DensityLevel = DENSITY-LEVEL,        ; the density level of the design
                 ) :
  name = "BGA Pad"
  type = SMD
  val solder-mask-defined? = pad-type is SolderMaskDefined
  val collapsible? = pad-type is Collapsible

  ; TODO - where do these numbers come from ?
  val adjustment = switch(density-level) :
    ; IPC7351 seems to indicate that BGAs are only ever described in
    ;   nominal on page 15
    ; I'm not sure about the logic of this.
    ; TODO - this seems backwards
    DensityLevelA: 0.75 when collapsible? else 1.15
    DensityLevelB: 0.80 when collapsible? else 1.10
    DensityLevelC: 0.85 when collapsible? else 1.05

  val definition-diameter = typical-ball-diameter * adjustment
  val referenced-diameter = definition-diameter + solder-mask-registration * 2.0

  if not solder-mask-defined?:
    shape = Circle( to-radius $ definition-diameter)
    layer(SolderMask(Top)) = Circle( to-radius $ referenced-diameter)
  else:
    shape = Circle(to-radius $ referenced-diameter)
    layer(SolderMask(Top)) = Circle( to-radius $ definition-diameter)

; A BGAModifier is an abstract type representing a class of BGA Components. It is used to
; control the way pads are depopulated and spaced on the land pattern. You can declare
; a custom BGA modifier using the new type syntax:
;
; defn MyBgaModifier () :
;   new BGAModifier:
;     defmethod locs (this, num-rows:Int, num-cols:Int) -> Seqable<Pose>:
;       ...
;     defmethod depopulated? (this, row-index:Int, column-index:Int) -> True|False:
;       ...
;
doc: \<DOC>
Abstract Interface for defining ball population in BGA landpatterns.
<DOC>
public deftype BGAModifier
doc: \<DOC>
Check if a particular BGA grid location is depopulated.
@param m self
@param r Row index as a 0-based offset into the rows of the BGA package
@param c Column index as a 0-based offset into the columns of the BGA package.
@return
  True = No Pad at this location
  False = Pad at this location
<DOC>
public defmulti depopulated? (m:BGAModifier, r:Int, c:Int) -> True|False
doc: \<DOC>
Retries the sequence of locations for all pads of this BGA package.
@param m self
@param nr Number of Rows
@param nc Number of Columns
@param pitch Center-to-Center Distance between adjacent pads in both
  row-wise and column-wise direction.
@return A sequence of positions for the pads to be created.
<DOC>
public defmulti locs (m:BGAModifier, nr:Int, nc:Int, pitch:Double) -> Seqable<Pose>

doc: \<DOC>
Default Implementation of `depopulated?` interface.
This implementation always returns false indicating that all
pads are populated
<DOC>
defmethod depopulated? (m:BGAModifier, r:Int, c:Int) -> True|False:
  false
defmethod locs (m:BGAModifier, nr:Int, nc:Int, pitch:Double) :
  grid-locs(nr, nc, pitch, pitch)

; A "FullMatrix" BGA is one where no pads are depopulated and the pad
; columns and rows are all equidistant.
public defstruct FullMatrix <: BGAModifier

; A "StageredMatrix" BGA is one where every other pad is depopulated,
; alternating across rows. The distance between adjacent pads on subsequent
; rows will be pitch / sqrt(2).
; In order to retain the A1 contact position, must be a Full Odd Matrix
public defstruct StaggeredMatrix <: BGAModifier

; An "EquilaterTriangleMatrix" is like a staggered matrix, but where the
; pads are all equistance from eachother. This means for any three adjacent pads
; with two in the same row or column, the centers of the pads form an equilateral
; triangle.
public defstruct EquilateralTriangleMatrix <: BGAModifier

; A "PerimeterMatrix" is like a full matrix, but with a region of pads in the
; center depopulated.
public defstruct PerimeterMatrix <: BGAModifier:
  rows:Range, ; the range of rows to depopulate
  cols:Range, ; the range of columns to depopulate

; A "ThermallyEnhancedMatrix" is like a PerimeterMatrix, except with some
; region in the center remaining populated.
public defstruct ThermallyEnhancedMatrix <: BGAModifier:
  perimeter-rows:Range, ; the range of rows to depopulate
  perimeter-cols:Range, ; the range of columns to depopulate
  interior-rows:Range, ; the range of rows in the center to remain populated
  interior-cols:Range, ; the range of columns in the center to remain populated

public defn CustomDepop (f:(Int, Int) -> True|False) :
  new BGAModifier:
    defmethod depopulated? (this, r:Int, c:Int) :
      f(r, c)

defmethod depopulated? (m:StaggeredMatrix, r:Int, c:Int) :
  ((r + 1) % 2) == (c % 2)

defmethod depopulated? (m:EquilateralTriangleMatrix, r:Int, c:Int) :
  ((r + 1) % 2) == (c % 2)

defmethod depopulated? (m:PerimeterMatrix, r:Int, c:Int) :
  contains?(rows(m), r) and contains?(cols(m), c)

defmethod depopulated? (m:ThermallyEnhancedMatrix, r:Int, c:Int) :
  (contains?(perimeter-rows(m), r) and contains?(perimeter-cols(m), c)) and not
  (contains?(interior-rows(m), r) and contains?(interior-cols(m), c))

defmethod locs (m:EquilateralTriangleMatrix, nr:Int, nc:Int, pitch:Double) :
  val vertical   = sqrt(3.0) * 0.5 * pitch
  val horizontal = pitch * 0.5
  grid-locs(nr, nc, horizontal, vertical)




;============================================================
;================== Pad Name Algorithm ======================
;============================================================

val DEF-ROW-OMITS = "IOQSXZ"

; BGAPadNames is a helper type to create a lookup table of precomputed
; pad names given BGA parameters
doc: \<DOC>
Generator for BGA Pad Names

The Pads are given {@link Ref} objects that indicate the name of the pad.
This type is used to generate the restricted set of rows/columns for
a BGA package's pads.
<DOC>
public deftype BGAPadNames

; Lookup the pad name given row and column indices
doc: \<DOC>
BGA Pad Name Lookup

@param b self
@param r Row index into the BGA's rows. This value is 0-indexed.
@param c Column index into the BGA's columns. This value is 0-indexed.
@throws ValueError When a row or column index is outside the available bounds
  of the package.
<DOC>
public defmulti get (b:BGAPadNames, r:Int, c:Int) -> Ref

; Precompute all of the pad names in a grid
doc: \<DOC>
BGA Pad Names Generator with Pre-computed values
@param num-rows Number of Rows of pads in the BGA package
@param num-cols Number of Columns of pads in the BGA package
@param row-chars-omitted? Set of characters in the form of a string
  that will not be selected from to create the Row index reference name.
  By default, this is `"IOQSXZ"`
<DOC>
public defn BGAPadNames (num-rows:Int, num-cols:Int, row-chars-omitted:String = DEF-ROW-OMITS) :
  ; Character table
  val table = to-tuple $
    for ch in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" filter:
      not contains?(upper-case(row-chars-omitted), ch)

  ; Construct a lookup table of pad names
  val pad-names = to-tuple $
    for row in 0 to num-rows seq-cat:
      val row-name = Ref(lookup-bga-row-name(row, table))
      for col in 0 to num-cols seq:
        row-name[col + 1]

  val rowSet = to-hashset<Int>(0 to num-rows)
  val colSet = to-hashset<Int>(0 to num-cols)
  ; finally wrap the table in a helper to perform the lookup.
  new BGAPadNames:
    defmethod get (this, r:Int, c:Int) :
      if not get(rowSet, r):
        throw $ ValueError("Invalid Row Index: %_ not in Row Set" % [r])
      if not get(colSet, c):
        throw $ ValueError("Invalid Column Index: %_ not in Column Set" % [c])
      pad-names[r * num-cols + c]

doc: \<DOC>
Returns the name of a row given its index and a list of omitted
characters.

The algorithm is a realization of this description from JEDEC JC-11:

> When a package is viewed ... with the A1 corner in the upper left position,
> terminal rows are lettered from top to bottom starting with A and
> terminal columns are numbered from left to right starting with 1.
> ... For packages with greater than 20 rows (i.e.,  following rows W and Y),
> the 21st row is designated AA and subsequent rows are designated AB, AC, etc.

The modification is we abstract over the omitted characters to support non-
standard naming conventions.

<DOC>
defn lookup-bga-row-name (idx:Int, table:Tuple<Char>) :
  val buffer = StringBuffer()
  let loop (i:Int = idx) :
    val rem = i / length(table)
    val char-index = i % length(table)
    loop(rem - 1) when rem > 0
    print(buffer, table[char-index])
  to-string(buffer)


; TODO - why is ball diameter not a toleranced ?
; TODO - why is BGAPadNames an interface if we are not going to
;   allow the user to access it.
doc: \<DOC>
Generator to create BGA Landpatterns
@param num-rows Number of rows of pads for this packagae
@param num-cols Number of columns of pads for this package.
@param pitch Center-To-Center Distance between adjacent pads
@param ball-diameter Nominal solder ball diameter
@param pad-type Selects between Soldermask Defined and Non-Soldermask Defined.
@param package-length Length (y-axis) of the package body
@param package-width Width (x-axis) of the package body
@param modifier Oracle for deciding which pads to populate for this package.
  The default is a {@link FullMatrix} population of pads.
@param row-characters-omitted? String of characters that will be removed
  from the row pad name generator. If `false`, then the characters `"IOQSXZ"`
  will not be included. Alternatively, the user can list which characters will
  be avoided.
@param mirrored? Mirrors the column indices across the Y axis. This does not
  affect the row indices.
@param density-level Defines the compactness of the symbol created. By default,
  the design density-level will be selected.
<DOC>
public defn make-bga-landpattern (
  num-rows:Int,
  num-cols:Int,
  pitch:Double,
  ball-diameter:Double,
  pad-type:BGAPadType,
  package-length:Toleranced,
  package-width:Toleranced,
  --
  modifier:BGAModifier = FullMatrix(),
  row-characters-omitted:String = DEF-ROW-OMITS,
  mirrored?:True|False = false,
  density-level:DensityLevel = DENSITY-LEVEL
  ) :
  ensure-positive!("make-bga:num-rows", num-rows)
  ensure-positive!("make-bga:num-cols", num-cols)
  ensure-positive!("make-bga:pitch", pitch)
  ensure-positive!("make-bga:ball-diameter", ball-diameter)

  inside pcb-landpattern:
    ;-------------------------------------------------------------
    ; Compute the pad definition
    val pad-def = bga-pad(ball-diameter, pad-type)

    ;-------------------------------------------------------------
    ; Layout the pads
    ; Calculate pad indices
    val pin-indices = to-tuple $
      for r in 0 to num-rows seq-cat:
        for c in 0 to num-cols seq:
          val c* = c when not mirrored? else (num-cols - c - 1)
          [r, c]

    ; Calculate pad locations
    val pad-locs = to-tuple(locs(modifier, num-rows, num-cols, pitch))

    ; Calculate pad names
    val pad-names = BGAPadNames(num-rows, num-cols, row-characters-omitted)

    ; Layout the pad given indices and locations
    for ([row, col] in pin-indices, loc in pad-locs) do:
      if not depopulated?(modifier, row, col) :
        pad (pad-names[row, col]) : pad-def at loc

    ;-------------------------------------------------------------
    ; Compute the courtyard
    val courtyard-excess = bga-courtyard-excess(density-level)
    val pkg-sz = Dims(max-value(package-length), max-value(package-width))
    val cy-sz = enlarge(pkg-sz, 2.0 * courtyard-excess)
    layer(Courtyard(Top)) = Rectangle(cy-sz)

    ;-------------------------------------------------------------
    ; Compute the orientation marker
    val silk-solder-mask-clearance = clearance(current-rules(), MinSilkSolderMaskSpace)
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
    val line-width = clearance(current-rules(), MinSilkscreenWidth)
    val pad-loc = center(pad-locs[0])
    val pol-x = x(pad-loc) - ball-diameter * 0.5 - solder-mask-registration
    val pol-y = y(pad-loc) + ball-diameter * 0.5 + solder-mask-registration
    val line-length = 3.0 * line-width
    val dist  = solder-mask-registration + silk-solder-mask-clearance + line-width * 0.5 + 0.01
    layer(Silkscreen("pol", Top)) = loc(pol-x, pol-y + dist) * Line(line-width, [Point(0.0, 0.0), Point(line-length, 0.0)])

    ;-------------------------------------------------------------
    ; Add the reference label
    val minHeight = clearance(current-rules(), MinSilkscreenTextHeight)
    val ref-pos = loc(0.0, 0.5 * (y(cy-sz) - minHeight))
    ref-label(ref-pos)

doc: \<DOC>
Generator to create BGA Landpatterns
@param num-rows Number of rows of pads for this packagae
@param num-cols Number of columns of pads for this package.
@param pitch Center-To-Center Distance between adjacent pads
@param ball-diameter Nominal solder ball diameter
@param pad-type Selects between Soldermask Defined and Non-Soldermask Defined.
@param package-length Length (y-axis) of the package body
@param package-width Width (x-axis) of the package body
@param modifier Oracle for deciding which pads to populate for this package.
  The default is a {@link FullMatrix} population of pads.
@param row-characters-omitted? String of characters that will be removed
  from the row pad name generator. If `false`, then the characters `"IOQSXZ"`
  will not be included. Alternatively, the user can list which characters will
  be avoided.
@param mirrored? Mirrors the column indices across the Y axis. This does not
  affect the row i````ndices.
@param density-level Defines the compactness of the symbol created. By default,
  the design density-level will be selected.
<DOC>
public pcb-landpattern bga-landpattern (
  num-rows:Int,
  num-cols:Int,
  pitch:Double,
  ball-diameter:Double,
  pad-type:BGAPadType,
  package-length:Toleranced,
  package-width:Toleranced,
  --
  modifier:BGAModifier = FullMatrix(),
  row-characters-omitted:String = DEF-ROW-OMITS,
  mirrored?:True|False = false,
  density-level:DensityLevel = DENSITY-LEVEL
  ):
  name = to-string("BGA%_P%_X%_" % [pitch, typ-value(package-length), typ-value(package-width)])
  make-bga-landpattern(
    num-rows, num-cols,
    pitch, ball-diameter,
    pad-type,
    package-length, package-width,
    modifier = modifier,
    row-characters-omitted = row-characters-omitted
    mirrored? = mirrored?
    density-level = density-level
    )