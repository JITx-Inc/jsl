#use-added-syntax(jitx, tests)
defpackage jsl/tests/designs/BoxSymbolTest:
  import core
  import collections
  import jitx
  import jitx/commands

  import jsl/symbols/audio
  import jsl/symbols/BoxSymbol
  import jsl/design/settings
  import jsl/landpatterns/two-pin/SMT
  import jsl/examples/landpatterns/board
  import jsl/landpatterns/packages
  import jsl/landpatterns/pad-island
  import jsl/landpatterns/SOIC
  import jsl/landpatterns/numbering
  import jsl/landpatterns/pad-planner
  import jsl/symbols/SymbolDefn
  import jsl/symbols/decorators


pcb-component basic-test:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir]
      [ VDD | p[8] | Right]
      [ DIN  | p[1] | Left]
      [ EN | p[2] | Left]
      [ CLK | p[3] | Left]
      [ DOUT | p[5] | Right ]
      [ ALERT | p[6] | Right ]
      [ NC    | p[7] | Left ]
      [ GND | p[4] | Left]

  val box = BoxSymbol(self)
  var results = []
  var test-pins = []

  ; test regex
  results = to-tuple $ seq({to-string(ref(_))}, find-pins-by-regex(box, ".*D"))
  val expected = ["VDD", "DIN", "DOUT", "GND"]
  for e in expected do :
    #EXPECT(contains?(results, e) == true)

  ; test row filtering
  results = find-pins-by-regex(box, ".*D", row = 0)
  #EXPECT(length(results) == 0)
  results = find-pins-by-regex(box, ".*D", bank = 0)
  #EXPECT(length(results) == 0)
  results = find-pins-by-regex(box, ".*D", column = 0)
  #EXPECT(length(results) == 0)

  ; test grid init
  #EXPECT(has-grid?(box) == false)
  set-grid(box, [4, 2])
  #EXPECT(has-grid?(box) == true)
  for p in pins(self) do :
    #EXPECT(property(p.row) == 0)
    #EXPECT(property(p.column) == 0)
  #EXPECT(get-rows(box) == 4)
  #EXPECT(get-columns(box) == 2)

  ; tests set-row/set-column
  val [row, col] = [3,3]
  test-pins = to-pins(pins(self))
  set-row(test-pins, row)
  set-column(test-pins, col)
  for p in pins(self) do :
    #EXPECT(property(p.row) == row)
    #EXPECT(property(p.column) == col)
  val group1 = [self.EN, self.DIN, self.CLK]
  set-group(to-pins $ group1, "inputs")
  for p in group1 do :
    #EXPECT(property(p.group) == "inputs")

  ; test pins-in-group
  test-pins = find-pins-by-regex(box, ".*D")
  set-alignment(test-pins, N)
  for p in pins(self) do :
    if contains?(test-pins, to-pin(p)) :
      #EXPECT(property(p.alignment) == N)
    else :
      #EXPECT(get-property?(p, ALIGN_PROP) == None())

  set-row(pins-in-group(box, "inputs"), 0)
  for p in group1 do :
    #EXPECT(property(p.row) == 0)

  set-row(to-pin(self.VDD), 0)
  set-alignment(to-pin(self.VDD), S)

  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 8,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)
  ;make-box-symbol()

pcb-component basic:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir]
      [ VDD | p[8] | Right]
      [ DIN  | p[1] | Left]
      [ EN | p[2] | Left]
      [ CLK | p[3] | Left]
      [ DOUT | p[5] | Right ]
      [ ALERT | p[6] | Right ]
      [ NC    | p[7] | Left ]
      [ GND | p[4] | Left]

  val box = BoxSymbol(self)
  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 8,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component basic-grid:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir | row:Int]
      [ VDD | p[8] | Right | 0]
      [ DIN  | p[1] | Left | 1]
      [ EN | p[2] | Left | 1]
      [ CLK | p[3] | Left | 1]
      [ DOUT | p[5] | Right | 1]
      [ ALERT | p[6] | Right | 2]
      [ NC    | p[7] | Left | 3]
      [ GND | p[4] | Left | 4]

  val box = BoxSymbol(self)
  set-grid(box, [5,2])
  set-alignment(to-pin(self.DOUT), C)
  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 8,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component basic-grid-large:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir | row:Int]
      [ VDD | p[8] | Right | 0]
      [ DIN  | p[1] | Left | 1]
      [ DIN2  | p[9] | Left | 1]
      [ DIN3  | p[10] | Left | 1]
      [ DIN4  | p[11] | Left | 1]
      [ DIN5  | p[12] | Left | 1]
      [ DIN6  | p[13] | Left | 1]
      [ DIN7  | p[14] | Left | 1]
      [ DIN8  | p[15] | Left | 1]
      [ DIN9  | p[16] | Left | 1]
      [ DIN10  | p[17] | Left | 1]
      [ EN | p[2] | Left | 1]
      [ CLK | p[3] | Left | 1]
      [ DOUT | p[5] | Right | 1]
      [ ALERT | p[6] | Right | 2]
      [ NC    | p[7] | Left | 3]
      [ GND | p[4] | Left | 4]

  val box = BoxSymbol(self)
  set-grid(box, [5,2])
  set-alignment(to-pin(self.DOUT), C)
  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 18,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component test-chip:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir]
      [ VDD | p[8] | Right ]
      [ DIN  | p[1] | Left ]
      [ DIN2  | p[9] | Left ]
      [ DIN3  | p[10] | Left ]
      [ DIN4  | p[11] | Left ]
      [ DIN5  | p[12] | Left ]
      [ DIN6  | p[13] | Left ]
      [ DIN7  | p[14] | Left ]
      [ DIN8  | p[15] | Left ]
      [ DIN9  | p[16] | Left ]
      [ DIN10  | p[17] | Left ]
      [ EN | p[2] | Left ]
      [ CLK | p[3] | Left ]
      [ DOUT | p[5] | Right ]
      [ ALERT | p[6] | Right ]
      [ NC    | p[7] | Left ]
      [ GND | p[4] | Left ]

  val box = BoxSymbol(self)

  val din-pins = find-pins-by-regex(box, "DIN.*")
  set-row(din-pins, 1)
  set-row(to-pins $ [self.CLK, self.EN], 1)
  set-row(to-pin(self.NC), 3)
  set-row(to-pin(self.GND), 4)
  set-row(to-pin(self.DOUT), 1)
  set-row(to-pin(self.ALERT), 2)
  set-grid(box, [5,2])
  set-alignment(to-pin(self.DOUT), C)

  add-decorator(box, to-pin(self.ALERT), OpenCollectorDecorator())
  add-decorator(box, to-pin(self.CLK), ClockDecorator())

  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 18,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-module test-design:
  inst c : basic-test
  inst c1: basic
  inst c2: basic-grid
  inst c3: basic-grid-large
  inst c4: test-chip

val board-shape = RoundedRectangle(50.0, 50.0, 0.25)

; Set the top level module (the module to be compile into a schematic and PCB)
set-current-design("BoxSymbol-TEST")
set-rules(default-rules)
set-board(default-board(board-shape))
set-main-module(test-design)

; Use any helper function from helpers.stanza here. For example:
; run-check-on-design(my-design)

; View the results
view-schematic()
;view-board()