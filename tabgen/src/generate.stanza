defpackage tabgen/generate:
  import core
  import arg-parser
  import tabgen/csv
  import tabgen/utils



defn default-stanza-fname (csv:String) -> String:
  val pos = last-index-of-char(csv, '.')
  val prefix = match(pos):
    (_:False): csv
    (x:Int):
      csv[0 to x]
  string-join([prefix, ".stanza"])

defn pad-to-equal-column-lengths (rows:Tuple<Tuple<String>>) -> Tuple<Tuple<String>> :
  val col-lens = to-tuple $ for row in rows seq:
    to-tuple $ map(length, row)

  val col-max-W = to-tuple $ for i in 0 to length(rows[0]) seq:
    maximum $ for col-len in col-lens seq:
      col-len[i]

  val margin = 2
  to-tuple $ for row in rows seq:
    to-tuple $ for (col in row, i in 0 to false) seq:
      val expLen = col-max-W[i] + margin
      val padCnt = expLen - length(col)
      val padStr = string-join $ repeat(" ", padCnt)
      to-string("%_%_" % [padStr, col])


defn generate-table (cmd-args:CommandArgs):

  val csv-file = args(cmd-args)[0]
  if not file-exists?(csv-file):
    eprint("File path '%_' Does Not Exist - Aborting" % [csv-file])
    exit(1)

  val pkgName = get(cmd-args, "pkg-name")
  val force = get?(cmd-args, "force", false)
  val fpath = get?(cmd-args, "f", default-stanza-fname(csv-file))

  if (not force) and file-exists?(fpath):
    eprint("File path '%_' Exists - Aborting" % [fpath])
    exit(1)

  val table = extract-csv(csv-file)
  println("Extraction Complete")


  val template = \<TMP>
; Auto-Generated File created by 'tabgen'
; Do not manually edit this file.
#use-added-syntax(jitx)
defpackage %_:
  import core
  import jitx

public val header:Tuple<String> = [%,]
public val rows:Tuple = [
  %_
]
<TMP>

  val rows* = pad-to-equal-column-lengths(rows(table))
  val rowLines = string-join{_, "\n  "} $ for row in rows* seq:
    ; println("Row: L=%_  Values=%," % [length(row), row])
    to-string("[%,]" % [row])

  val fileContent = to-string(
    template % [
      pkgName,
      headers(table),
      rowLines
    ]
  )

  spit(fpath, fileContent)
  println("File '%_' Generated" % [fpath])


val GEN-MSG = \<MSG>
This command is a tool for dumping the passed CSV table.
This makes it easier to debug the generation functionality. CSV content
will be written to stdout.

User must pass a "Definitions Database" as the only positional argument. The
definitions database is generated by the 'stanza' compiler using the
'definitions-database' command.
<MSG>

val GEN-ARG-MSG = \<MSG>
User must pass a single file path argument as a positional argument. This
file path should point to the CSV file to extract.
<MSG>

val OUTFILE-MSG = \<MSG>
Output stanza file to be generate that contains the contents from the CSV
file encoded in stanza syntax. This file will contain two public definitions:

1.  `header` - A 'Tuple<String>' of the contents of the header line of the CSV file.
2.  `rows` - A 'Tuple<Tuple<String>' of the rows of the CSV file.

<MSG>

val PKG-NAME-MSG = \<MSG>
Package Name for the generated stanza output file.
<MSG>

val FORCE-MSG = \<MSG>
Force the output to generate a file - even if one already exists.
<MSG>

public defn setup-generate-cmd () -> Command :

  val genFlags = [
    Flag("f", OneFlag, OptionalFlag, OUTFILE-MSG),
    Flag("pkg-name", OneFlag, RequiredFlag, PKG-NAME-MSG),
    Flag("force", ZeroFlag, OptionalFlag, FORCE-MSG),
  ]
  Command("generate", OneArg, GEN-ARG-MSG, genFlags, GEN-MSG, generate-table)

