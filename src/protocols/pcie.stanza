#use-added-syntax(jitx)
defpackage jsl/protocols/pcie:
  import core
  import jitx
  import jitx/commands

  import jsl/bundles
  import jsl/errors
  import jsl/si/helpers
  import jsl/si/couplers
  import jsl/pin-assignment

doc: \<DOC>
PCI-E Bundle
PCI-E is a serial communication supporting high speed data links
@see https://en.wikipedia.org/wiki/PCI_Express
<DOC>

public defenum PCIeVersion:
  PCIE-V1
  PCIE-V2
  PCIE-V3
  PCIE-V4
  PCIE-V5
  PCIE-V6
  PCIE-V7

defn ensure-valid (lanes) -> True|False:
  val res = switch(lanes) :
    1  : true
    2  : true
    4  : true 
    8  : true
    16 : true
    32 : true
    else : throw $ Exception("Invalid Lane Configuration for PCIe Bundle")
  res

public defn pcie (-- lanes:Int = 4) :
  ; This still throws
  ensure-valid(lanes)
  pcb-bundle pcie_b :
    name = "PCI-E"
    description = "PCI-E Serial Communications Link"
    port control : pcie-control
    port data : pcie-data(lanes)
  pcie_b

doc: \<DOC>
PCI-E Data Bundle
PCI-E is a serial communication supporting high speed data links
@see https://en.wikipedia.org/wiki/PCI_Express
<DOC>

public pcb-bundle pcie-data (lanes:Int) :
  name = "PCI-E Data"
  description = "PCI-E Serial Communications Link Data"
  port rx : diff-pair[lanes] 
  port tx : diff-pair[lanes] 
  port refclk : diff-pair


doc: \<DOC>
PCI-E Control Bundle
PCI-E is a serial communication supporting high speed data links
@see https://en.wikipedia.org/wiki/PCI_Express
<DOC>

public pcb-bundle pcie-control :
  name = "PCI-E Control"
  description = "PCI-E Serial Communications Link Control"
  pin PEWAKE#
  pin PRSNT#          ; hot plug detection
  pin PERST#          ; PCI-E Reset signal
  pin CLKREQ#         ; clock request


doc: \<DOC>
The connect-pci-e() function connects two equivalent pcie bundles together by
connecting the tx pairs on the first bundle to the rx pairs on the second bundle and 
vice versa. It also connects the control sub-bundle together without constraints.
For the data lines, the constraints on intra-pair skew, max loss and trace impedance
need to be verified by the user. Some defaults in the table are derived from the references
listed below.
<DOC>

public defn connect-pci-e (gen:jsl/protocols/pcie/PCIeVersion, cap:Instantiable, x:JITXObject, y:JITXObject) : 
  inside pcb-module :
    defn constraint (gen:PCIeVersion, half:True|False, a:JITXObject, b:JITXObject) :
      ; some references for the data in the following table:
      ; https://pcisig.com/pci-express%C2%AE-50-architecture-channel-insertion-loss-budget-0
      ; 

      ; there are also very loose lane to lane skew spec:
      ; the following lane-to-lane (inter pair) skews are tolerable for different lane rates:
      ; Parameter	       2.5 GT/s	5.0 GT/s	8.0 GT/s	16.0 GT/s Unit
      ; Lane to Lane Skew	20	     8	        6	          5 ns
      ;
      ; tpd 170ps/in to 147 ps/in -> 170fs/mil to 147 fs/mil
      ; @  5 mils that is a intra-pair skew of 850 fs to 750 fs
      ; @ 10 mils that is a intra-pair skew of 1.70ps to 1.50ps
      ; for system board skew match: https://docs.broadcom.com/doc/pcie-pcb-layout-review page 2
      ; 
      ; https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/powerquicc/2284/1/AN307_TP_HARDWARE_DESIGN_PCI_SMGIII.pdf
      ; P/N swapping is ok per pair
      ; all lanes being swapped is ok as well
      ; this will be handled in the component level I think
      ; 
      val [sw, ml, ti] = 
        switch(gen) :
          PCIE-V1 : [0.0 +/-  1.0e-12,  12.0, 100.0 +/- (5 %)]  ;   2.5 GT/s
          PCIE-V2 : [0.0 +/-  1.0e-12,  12.0, 100.0 +/- (5 %)]  ;   5.0 GT/s
          PCIE-V3 : [0.0 +/-  1.0e-12,  10.3,  85.0 +/- (5 %)]  ;   8.0 GT/s
          PCIE-V4 : [0.0 +/- 0.850e-12, 13.5,  85.0 +/- (5 %)]  ;  16.0 GT/s
          PCIE-V5 : [0.0 +/- 0.850e-12, 16.0,  85.0 +/- (5 %)]  ;  32.0 GT/s
          PCIE-V6 : [0.0 +/- 0.850e-12, 16.0,  85.0 +/- (5 %)]  ;  64.0 GT/s
          PCIE-V7 : [0.0 +/- 0.850e-12, 16.0,  85.0 +/- (5 %)]  ; 128.0 GT/s

      ; user land code to provide the correct routing structure to us
      ; given that we don't know the stack-up at this point
      val rs = diff-imped-func(gen, ti)
      topo-net(a => b)
      diff-structure(rs, a => b)
      val swf = sw * if (half): typ(0.50) else: typ(1.00)
      val mlf = ml * if (half): typ(0.50) else: typ(1.00)
      skew-window(swf, a => b)
      max-loss(mlf, a => b)

    for (i in 0 to length(x.data.tx)) do : 
      inst bl-x-y-cap : dp-coupler(cap)
      require tx1 : dual-pair from bl-x-y-cap
      constraint(gen, true, x.data.tx[i], tx1.A)
      constraint(gen, true, tx1.B, y.data.rx[i])

    for (i in 0 to length(y.data.tx)) do : 
      inst bl-y-x-cap : dp-coupler(cap)
      require tx1 : dual-pair from bl-y-x-cap
      constraint(gen, true, y.data.tx[i], tx1.A)
      constraint(gen, true, tx1.B, x.data.rx[i])

    constraint(gen, false, x.data.refclk, y.data.refclk)

    net (x.control y.control)

doc: \<DOC>
The diff-imped-func below is going to have to be provided by the user because it is stack-up dependant for now.
The function should return a pcb-differential-routing-structure that will be applied to the differential traces 
in the PCIe bus.
<DOC>
defn diff-imped-func (gen:PCIeVersion, impedance:Toleranced):
  pcb-differential-routing-structure diff (impedance:Toleranced) :
    name = "85/100 Ohm differential impedance - PCIe"
    val tw = switch(typ(impedance)) :
      85.0  : 0.1400
      100.0 : 0.1510
    ; whatever layers are to be used for routing the differential pairs (defined by the user)
    layer(LayerIndex(1, Top)) :
      trace-width  = tw       ; mm
      pair-spacing = 2.0 * tw ; mm
      clearance    = 0.300    ; mm
      velocity = 0.19e12      ; mm/s
      insertion-loss = 0.008  ; db/mm @ 1GHz 

    uncoupled-region = se-50
  diff 


doc: \<DOC>
The pcb-routing-structure(s) below are just examples of the routing structures that need to be maintained 
in the project code because they are dependant on the stack-up and other factors. When using the connect-pci-e()
function, there are board-specific constraints that need to be applied.
<DOC>
public pcb-routing-structure se-50 :
  name = "50 Ohm single-ended"
  layer(Top) :
    trace-width = 0.15    ; mm
    clearance = 0.15     ; mm
    velocity = 0.19e12   ; mm/s
    insertion-loss = 0.008  ; db/mm @ 1GHz 
    neck-down = NeckDown(
      trace-width = 0.156 
      clearance = 0.1 
    )

  layer(Bottom) :
    trace-width = 0.15    ; mm
    clearance = 0.15         ; mm
    velocity = 0.19e12   ; mm/s
    insertion-loss = 0.008  ; db/mm @ 1GHz 
    neck-down = NeckDown(
      trace-width = 0.156 
      clearance = 0.1 
    )

; @TODO - Compute from the JSL Stackup and Strip Line
public pcb-differential-routing-structure diff (eff-imp:Toleranced) :
  name = "85/100 Ohm differential impedance - PCIe"
  val tw = switch(typ(eff-imp)) :
     85.0  : 0.1400
     100.0 : 0.1510

  layer(LayerIndex(1, Top)) :
    trace-width  = tw       ; mm
    pair-spacing = 2.0 * tw ; mm
    clearance    = 0.300    ; mm
    velocity = 0.19e12      ; mm/s
    insertion-loss = 0.008  ; db/mm @ 1GHz 

  uncoupled-region = se-50
