#use-added-syntax(jitx, tests)
defpackage jsl/tests/designs/BoxSymbolTest:
  import core
  import collections
  import jitx
  import jitx/commands

  import jsl/symbols/audio
  import jsl/symbols/BoxSymbol
  import jsl/design/settings
  import jsl/landpatterns/two-pin/SMT
  import jsl/examples/landpatterns/board
  import jsl/landpatterns/packages
  import jsl/landpatterns/pad-island
  import jsl/landpatterns/SOIC
  import jsl/landpatterns/numbering
  import jsl/landpatterns/pad-planner
  import jsl/symbols/SymbolDefn
  import jsl/symbols/decorators
  import jsl/bundles/comms
  import jsl/bundles/general

pcb-component basic-test:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir]
      [ VDD | p[8] | Right]
      [ DIN  | p[1] | Left]
      [ EN | p[2] | Left]
      [ CLK | p[3] | Left]
      [ DOUT | p[5] | Right ]
      [ ALERT | p[6] | Right ]
      [ NC    | p[7] | Left ]
      [ GND | p[4] | Left]

  val box = BoxSymbol(self)
  var results = []
  var test-pins = []

  ; test regex
  results = to-tuple $ seq({to-string(ref(_))}, find-pins-by-regex(box, ".*D"))
  val expected = ["VDD", "DIN", "DOUT", "GND"]
  for e in expected do :
    #EXPECT(contains?(results, e) == true)

  ; test row filtering
  results = find-pins-by-regex(box, ".*D", row = 0)
  #EXPECT(length(results) == 0)
  results = find-pins-by-regex(box, ".*D", bank = 0)
  #EXPECT(length(results) == 0)
  results = find-pins-by-regex(box, ".*D", column = 0)
  #EXPECT(length(results) == 0)

  ; test grid init
  #EXPECT(has-grid?(box) == false)
  set-grid(box, [4, 2])
  #EXPECT(has-grid?(box) == true)
  for p in pins(self) do :
    #EXPECT(property(p.row) == 0)
    #EXPECT(property(p.column) == 0)
  #EXPECT(get-rows(box) == 4)
  #EXPECT(get-columns(box) == 2)

  ; tests set-row/set-column
  val [row, col] = [3,3]
  set-row(row, pins = pins(self))
  set-column(col, pins(self))
  for p in pins(self) do :
    #EXPECT(property(p.row) == row)
    #EXPECT(property(p.column) == col)
  val group1 = [self.EN, self.DIN, self.CLK]
  set-group("inputs", pins = group1)
  for p in group1 do :
    #EXPECT(property(p.group) == "inputs")

  ; test pins-in-group
  test-pins = find-pins-by-regex(box, ".*D")
  set-alignment(N, test-pins)
  for p in pins(self) do :
    if contains?(test-pins, to-pin(p)) :
      #EXPECT(property(p.alignment) == N)
    else :
      #EXPECT(get-property?(p, ALIGN_PROP) == None())

  set-row(0, pins = pins-in-group(box, "inputs"))
  for p in group1 do :
    #EXPECT(property(p.row) == 0)

  set-row(0, self.VDD)
  set-alignment(S, self.VDD)

  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 8,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)
  ;make-box-symbol()

pcb-component basic:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir]
      [ VDD | p[8] | Right]
      [ DIN  | p[1] | Left]
      [ EN | p[2] | Left]
      [ CLK | p[3] | Left]
      [ DOUT | p[5] | Right ]
      [ ALERT | p[6] | Right ]
      [ NC    | p[7] | Left ]
      [ GND | p[4] | Left]

  val box = BoxSymbol(self)
  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 8,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component basic-grid:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir | row:Int]
      [ VDD | p[8] | Right | 0]
      [ DIN  | p[1] | Left | 1]
      [ EN | p[2] | Left | 1]
      [ CLK | p[3] | Left | 1]
      [ DOUT | p[5] | Right | 1]
      [ ALERT | p[6] | Right | 2]
      [ NC    | p[7] | Left | 3]
      [ GND | p[4] | Left | 4]

  val box = BoxSymbol(self)
  set-grid(box, [5,2])
  set-alignment(C, self.DOUT)
  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 8,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component basic-grid-large:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir | row:Int]
      [ VDD | p[8] | Right | 0]
      [ DIN  | p[1] | Left | 1]
      [ DIN2  | p[9] | Left | 1]
      [ DIN3  | p[10] | Left | 1]
      [ DIN4  | p[11] | Left | 1]
      [ DIN5  | p[12] | Left | 1]
      [ DIN6  | p[13] | Left | 1]
      [ DIN7  | p[14] | Left | 1]
      [ DIN8  | p[15] | Left | 1]
      [ DIN9  | p[16] | Left | 1]
      [ DIN10  | p[17] | Left | 1]
      [ EN | p[2] | Left | 1]
      [ CLK | p[3] | Left | 1]
      [ DOUT | p[5] | Right | 1]
      [ ALERT | p[6] | Right | 2]
      [ NC    | p[7] | Left | 3]
      [ GND | p[4] | Left | 4]

  val box = BoxSymbol(self)
  set-grid(box, [5,2])
  set-alignment(C, self.DOUT)
  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 18,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component basic-grid-large-rotate:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir | row:Int]
      [ VDD | p[8] | Up | 0]
      [ DIN  | p[1] | Down | 4]
      [ DIN2  | p[9] | Down | 4]
      [ DIN3  | p[10] | Down | 4]
      [ DIN4  | p[11] | Down | 4]
      [ DIN5  | p[12] | Down | 4]
      [ DIN6  | p[13] | Down | 4]
      [ DIN7  | p[14] | Down | 4]
      [ DIN8  | p[15] | Down | 4]
      [ DIN9  | p[16] | Down | 4]
      [ DIN10  | p[17] | Down | 4]
      [ EN | p[2] | Down | 4]
      [ CLK | p[3] | Down | 4]
      [ DOUT | p[5] | Up | 0]
      [ ALERT | p[6] | Up | 0]
      [ NC    | p[7] | Down | 4]
      [ GND | p[4] | Down | 4]

  val box = BoxSymbol(self)
  set-grid(box, [5,1])
  set-alignment(C, self.DOUT)
  add-decorator(box, to-pin(self.ALERT), OpenCollectorDecorator())
  add-decorator(box, to-pin(self.CLK), ClockDecorator())
  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 18,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component test-chip:
  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir]
      [ VDD | p[8] | Right ]
      [ DIN  | p[1] | Left ]
      [ DIN2  | p[9] | Left ]
      [ DIN3  | p[10] | Left ]
      [ DIN4  | p[11] | Left ]
      [ DIN5  | p[12] | Left ]
      [ DIN6  | p[13] | Left ]
      [ DIN7  | p[14] | Left ]
      [ DIN8  | p[15] | Left ]
      [ DIN9  | p[16] | Left ]
      [ DIN10  | p[17] | Left ]
      [ EN | p[2] | Left ]
      [ CLK | p[3] | Left ]
      [ DOUT | p[5] | Right ]
      [ ALERT | p[6] | Right ]
      [ NC    | p[7] | Left ]
      [ GND | p[4] | Left ]

  val box = BoxSymbol(self)

  val din-pins = find-pins-by-regex(box, "DIN.*")
  set-row(1, din-pins)
  set-row(1, self.CLK, self.EN)
  set-row(3, self.NC)
  set-row(4, self.GND)
  set-row(1, self.DOUT)
  set-row(2, self.ALERT)
  set-grid(box, [5,2])
  set-alignment(C, self.DOUT)

  add-decorator(box, to-pin(self.ALERT), OpenCollectorDecorator())
  add-decorator(box, to-pin(self.CLK), ClockDecorator())

  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 18,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component test-chip-right:
  mpn = "24AA025UIDT-I/OT"

  pin-properties:
    [pin:Ref | pads:Ref ... | side:Dir]
      [ VDD | p[8] | Right ]
      [ DIN  | p[1] | Left ]
      [ DIN2  | p[9] | Left ]
      [ DIN3  | p[10] | Left ]
      [ DIN4  | p[11] | Left ]
      [ DIN5  | p[12] | Left ]
      [ DIN6  | p[13] | Left ]
      [ DIN7  | p[14] | Left ]
      [ DIN8  | p[15] | Left ]
      [ DIN9  | p[16] | Left ]
      [ DIN10  | p[17] | Left ]
      [ EN | p[2] | Left ]
      [ CLK | p[3] | Left ]
      [ DOUT | p[5] | Right ]
      [ VDD2 | p[18] | Right ]
      [ DOUT2 | p[19] | Left ]
      [ ALERT | p[6] | Right ]
      [ NC    | p[7] | Left ]
      [ GND | p[4] | Left ]

  val box = BoxSymbol(self)

  val din-pins = find-pins-by-regex(box, "DIN.*")
  set-row(1, din-pins)
  set-row(1, self.CLK, self.EN)
  set-row(3, self.NC)
  set-row(4, self.GND)
  set-row(1, find-pins-by-regex(box, "DOUT.*"))
  set-row(2, self.ALERT)
  set-grid(box, [5,2])
  set-alignment(C, find-pins-by-regex(box, "DOUT.*"))
  set-top-margin(2.0,self.VDD)
  set-bottom-margin(2.0,self.VDD)
  set-alignment(C, self.VDD2)
  set-alignment(C, self.VDD)
  set-top-margin(2.0, self.DIN10)
  set-bottom-margin(2.0, self.DIN10)
  val d-pins = find-pins-by-regex(box, "DIN.*")
  set-side(Right, d-pins)
  set-side(Left, self.DOUT)

  add-decorator(box, to-pin(self.ALERT), OpenCollectorDecorator())
  add-decorator(box, to-pin(self.CLK), ClockDecorator())

  val symb = create-symbol(box)
  assign-symbol(symb)

  val lp = create-landpattern $ SOIC-N(
    num-leads = 20,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(lp)

pcb-component test-24AA025:
  manufacturer = "Microchip"
  mpn = "24AA025UIDT-I/OT"

  port bus : i2c
  port rail : power
  port ADDR : pin[2]

  pin-properties :
    [pin:Ref | pads:Ref ... | side:Dir | row:Int | SRC-NAME:String ]
    [bus.scl | p[1] | Up | 0 | "SCL" ]
    [bus.sda | p[3] | Up | 0 | "SDA" ]
    [rail.V+ | p[6] | Right | 0 | "VCC" ]
    [rail.V- | p[2] | Left | 1 | "VSS" ]
    [ADDR[0] | p[5] | Down | 1 | "A0" ]
    [ADDR[1] | p[4] | Down | 1 | "A1" ]

  val box = BoxSymbol(self)
  set-grid(box, [2,1])
  set-alignment(N, self.rail.V+)
  set-alignment(S, self.rail.V-)
  set-side(Right, self.rail)
  set-alignment(C, self.bus)
  set-alignment(C, self.ADDR)

  val symb = create-symbol(box)
  assign-symbol(symb)

  val SOIC-pkg = SOIC-N(
    num-leads = 6,
    lead-span = min-max(5.8, 6.2),
    package-length = 4.5 +/- 0.10,
    density-level = DensityLevelC
  )
  assign-landpattern(create-landpattern(SOIC-pkg))

pcb-module test-design:
  inst c : basic-test
  inst c1: basic
  inst c2: basic-grid
  inst c3: basic-grid-large
  inst c3a: basic-grid-large-rotate
  inst c4: test-chip
  inst c5: test-chip-right
  inst c6: test-24AA025

val board-shape = RoundedRectangle(50.0, 50.0, 0.25)

; Set the top level module (the module to be compile into a schematic and PCB)
set-current-design("BoxSymbol-TEST")
set-rules(default-rules)
set-board(default-board(board-shape))
set-main-module(test-design)

; Use any helper function from helpers.stanza here. For example:
; run-check-on-design(my-design)

; View the results
view-schematic()
;view-board()