doc: \<DOC>
@title Pad Planner
@brief How & Where to Place Pads
@desc

When building complex landpatterns, we are often faced with
cases where the package for a particular component does
something out of the ordinary. You will often run into this
when looking at BGA packages where some subset of the balls
in a grid may be depopulated. Sometimes this is pretty
straight forward like for a thermally enhanced BGA pattern:

TODO - Figure here showing a thermally enhanced BGA

Other times, it can be more off the beaten path:

TODO - Figure here showing the Dialog chip with offset
  sub-grid of balls.

Regardless, we need tools to instructs the JITX environment
how to place the pads we need for a particular component. This
is where the "Pad Planner" comes in.

Pad Planner is a piece of code that tells the land pattern generator:

1.  Whether or not to place a pad at a particular location.
2.  The features of the pad to place at a particular location.

In order for the Pad Planner to provide good guidance, we have to
have a common understanding between the generator and the planner:

1.  The pads for a landpattern are generally going to be in a grid of some sort.
  1.  BGA packages have an obvious 2D grid.
  2.  Quad Packages (QFP, QFN, etc) also have a 2D grid but it isn't quite as obvious.
  3.  The Pad Planner makes the assumption that the pads of a component are arranged in
  a 2D grid with rows and columns.
2.  A common shape characteristic
  1.  Many landpatterns use {@link type:Rectangle} for the shape of their pads.
  2.  Sometimes we might want to use {@link type:RoundedRectangle} or {@link type:Capsule}.
  3.  The Pad Planner makes the assumption that each pad's geometry will be described
  by a {@link type:Dims} object. This means that if we want to provide different shapes,
  we have to shim them into accepting a {@link type:Dims} object.
  4.  Shape Orientation - The Pad Planner doesn't actually care about this but the
  shapes generated by it need to align with the package's needs. The Pad Planner
  shapes will be aligned with the Dims object. The Package's land pattern generator
  is responsible for making sure that the `x` dimension of the shape corresponds with
  the `lead-length` direction, and the `y` dimension corresponds with the `lead-width` direction.

<DOC>
#use-added-syntax(jitx)
defpackage jsl/landpatterns/pad-planner:
  import core
  import jitx with:
    prefix(Rectangle) => jitx-
  import jsl/landpatterns/pads
  import jsl/geometry/basics
  import jsl/errors

  import jsl/landpatterns/grid-planner

doc: \<DOC>
Pad Planner Base Type

This defines the interface for a Pad Planner. The Pad Planner
is consulted by the landpattern generator when determining
what pads to create and what shape those pads should have.
<DOC>
public deftype PadPlanner

doc: \<DOC>
Check if this package grid location is active.

In this context, `active` means that there should be a copper
pad at this location. `inactive` means that no copper pad should be
placed at this location.

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Pad Grid location is Active.
<DOC>
public defmulti active? (x:PadPlanner, row:Int, column:Int) -> True|False

doc: \<DOC>
Is this PadPlanner configured to generate through-hole pads ?

This is a flag that indicates whether this planner is intended
for through-hole or surface mount pad generation. This is a
helper function to make it easier to determine whether the
`pad-generator` or `th-pad-generator` functions should be
called in a particular application
<DOC>
public defmulti is-through-hole? (x:PadPlanner) -> True|False

doc: \<DOC>
Default Implementation

This just checks if `hole-generator` returns False or not.
<DOC>
public defmethod is-through-hole? (x:PadPlanner) -> True|False :
  hole-generator(x, 0, 0) is-not False

doc: \<DOC>
Retrieve the Shape Generator for this grid position

In general, this function should not query `active?` unless
it needs to. The `active?` flag will be queried in the `pad-generator`
functions when selecting whether to generate pad shapes.

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Shape Generator function with declared signature. This function
will accept the following arguments:

-  Dims - Size of the generated pad

This function will return a `Shape` object with those properties. Note that
the shape should have its own internal `Pose` object so that this method
could add a custom offset if needed.
<DOC>
public defmulti shape-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False

doc: \<DOC>
Retrieve the Pad Generator for this grid position

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Pad Generator function with declared signature. This function
will accept the following arguments:

-  Dims - Size of the generated pad

This function will return a `pcb-pad` definition which uses the
shape provided by `shape-generator`.
<DOC>
public defmulti pad-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Pad)|False

doc: \<DOC>
Default implementation for the `pad-generator`

By default, this function will use the {@link smd-pad} generator
for creating the pad definition. The default soldermask and
pastemask settings will be used.
<DOC>
public defmethod pad-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Pad)|False:
  val func? = shape-generator(x, row, column)
  match(active?(x, row, column), func?):
    (active:False, x): false
    (active:True, f:(Dims -> Shape)):
      smd-pad{f(_0)}
    (active:True, x:False):
      throw $ NoGeneratorForActivePadError(row, column, "shape-generator")

doc: \<DOC>
Through-hole Pad Generator
This function is an alternate to the `pad-generator` function. This
function is used to generate through-hole pads where the `pad-generator`
is for SMT pads.

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.
@return Pad Generator function with declared signature. This function
will accept the following arguments:

-  hole:Dims - Size of the plated-through hole (not accounting for plating)
-  copper:Dims - Size of the pad annulus for the hole.

This function will return a `pcb-pad` definition which uses the
shape provided by `shape-generator` and the hole provided by `hole-generator`.
<DOC>
public defmulti th-pad-generator (x:PadPlanner, row:Int, column:Int) -> ( (Dims, Dims) -> Pad )|False

doc: \<DOC>
Default Through-Hole Pad Generator
The default implementation will generate either plated or non-plated holes
depending on whether the `shape-generator` returns true or false.
For non-plated holes - the `copper:Dims` argument will be ignored.

If the user tries to use `th-pad-generator` when `hole-generator`
returns false - then this function will raise an error.

@throws NoGeneratorForActivePadError When an improper configuration
of hole and shape generator functions are provided to an active grid location.
<DOC>
public defmethod th-pad-generator (x:PadPlanner, row:Int, column:Int) -> ( (Dims, Dims) -> Pad )|False :
  val shape-gen? = shape-generator(x, row, column)
  val hole-gen? = hole-generator(x, row, column)

  match(active?(x, row, column), shape-gen?, hole-gen?):
    (a:False, f, h): false
    (a:True, f:(Dims -> Shape), h:(Dims -> Shape)):
      pth-pad{h(_0), f(_1)}
    (a:True, f:False, h:(Dims -> Shape)):
      defn npth-gen (hole:Dims, copper:Dims) -> Pad :
        npth-pad(h(hole))
      npth-gen
    (a:True, f, h):
      throw $ NoGeneratorForActivePadError(row, column, "shape- or hole-")

doc: \<DOC>
Hole Shape for Pad
This function provides the user with the ability to create a
plated through-hole pad instead of an SMT pad.

In general, this function should not query `active?` unless
it needs to. The `active?` flag will be queried in the `pad-generator`
functions when selecting whether to generate pad shapes.

The typical use case is to only return `False` if the land pattern
contains zero through-hole pads. If you need to create a land pattern
with a mix of through-hole and surface mount pads - it is better to construct
this land pattern through composition.

If you intend to violate this convention - you must provide a reformed
version of {@link is-through-hole?} in your derived implementation.

@param x Pad Planner (self)
@param row Zero-based Index into the grid of a package's pad positions.
@param column Zero-based Index into the grid of a package's pad positions.

@return This function should return a function that will convert
a `Dims` object into a `Shape`. That function will need to have the
following signature:

```stanza
Dims -> Shape
```

This function can return `false` for location in the grid where no
hole should be created. If this function returns `false` at an
`active? = true` grid location - then the related pad generation
functions will raise an exception.

<DOC>
public defmulti hole-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False

doc: \<DOC>
Default `hole-shape` - No Holes Created.
@return Always `false`
<DOC>
public defmethod hole-generator (x:PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False :
  false

doc: \<DOC>
Pad Planner that always returns a Shape Converter

This is a default implementation of the PadPlanner interface
for swapping a particular shape for all pads in a landpattern.

This is useful for when you don't want to use `Rectangle`
(the typical default) and you want to replace it with
say `RoundedRectangle`.
<DOC>
public defstruct ShapePadPlanner <: PadPlanner :
  shaper:(Dims -> Shape)

public defmethod active? (x:ShapePadPlanner, row:Int, column:Int) -> True|False :
  true

public defmethod shape-generator (x:ShapePadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  shaper(x)

public val rect-shaper:(Dims -> Shape) = Rectangle ;  {Rectangle(_0)}
public val RectanglePadPlanner = ShapePadPlanner(rect-shaper)

public val capsule-shaper:(Dims -> Shape) = Capsule
public val CapsulePadPlanner = ShapePadPlanner(capsule-shaper)

public defn round-rect-shaper (radius:Double) -> (Dims -> Shape) :
  {RoundedRectangle(x(_0), y(_0), radius)}

public defn RoundedRectanglePadPlanner (radius:Double) -> ShapePadPlanner :
  ShapePadPlanner( round-rect-shaper(radius) )

public defn dshape-shaper (radius:Double) -> (Dims -> Shape) :
  {DShape(x(_0), y(_0), radius)}

public defn DShapePadPlanner (radius:Double) -> ShapePadPlanner :
  ShapePadPlanner(dshape-shaper(radius))

public defstruct Pin1-PadPlanner <: PadPlanner :
  pin1-shaper:(Dims -> Shape)
  shaper:(Dims -> Shape)

public defmethod active? (x:Pin1-PadPlanner, row:Int, column:Int) -> True|False :
  true

public defmethod shape-generator (x:Pin1-PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  if column == 0 and row == 0: pin1-shaper(x)
  else: shaper(x)

doc: \<DOC>
Chamfered Corner Shaper

This function is intended to be used with {@link type:Corner-PadPlanner}
to implement the differential corner pads.

<DOC>
public defn chamfered-corner-shaper (radius:Double) -> (Dims -> Shape) :
  GeneralChamferedRectangle{_0, radius, CornerModifierUpperRight}

doc: \<DOC>
Corner Pin Pad Planner

This pad planner is useful for packages like QFN, QFP, and other
quad packages where the pads in the corners need to be customized
to prevent overlapping pad geometry.

This pad planner accepts two shapers - one for normal pads and
one for the pads in the corner. The corner pad will be used
normally in the first row of a column. In the last row of a
column - the corner pad will be mirrored about the X axis.
<DOC>
public defstruct Corner-PadPlanner <: PadPlanner :
  corner-shaper:(Dims -> Shape)
  shaper:(Dims -> Shape)
  rows:Int|Tuple<Int>
with:
  printer => true
  keyword-constructor => true

public defmethod active? (x:Corner-PadPlanner, row:Int, column:Int) -> True|False :
  match(rows(x)):
    (r-set:Tuple<Int>): column < length(r-set)
    (_): true

public defmethod shape-generator (x:Corner-PadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  val rows = match(rows(x)):
    (r-set:Tuple<Int>): r-set[column]
    (row-max:Int): row-max

  if row == 0:
    corner-shaper(x)
  else if row == (rows - 1):
    val flip-Y = loc(Point(0.0, 0.0), FlipY)
    {flip-Y * corner-shaper(x)(_0)}
  else:
    shaper(x)

public defn is-omit? (omits:Tuple<[Int, Int]>, row:Int, column:Int) -> True|False :
  for omit in omits any?:
    val [o-row, o-col] = omit
    o-row == row and o-col == column

public defstruct StaggerPadPlanner <: ShapePadPlanner :
  shaper:(Dims -> Shape) with:
    as-method => true

  doc: \<DOC>
  Set the stagger phase for the planner
  <DOC>
  phase:StaggerPhase with:
    default => Odd-Phase

  doc: \<DOC>
  List of [row, col] combinations that will be non-stuffed
  <DOC>
  omits:Tuple<[Int, Int]> with:
    default => []
with:
  printer => true
  keyword-constructor => true

public defmethod active? (x:StaggerPadPlanner, row:Int, column:Int) -> True|False :
  if not is-omit?(omits(x), row, column):
    stagger-pattern(phase(x), row, column)
  else:
    false

doc: \<DOC>
Plated Through-Hole Pad Planner

Basic Pad Planner for PTH pads. This assumes the hole size
is the same for all grid locations.
<DOC>
public defstruct PthPadPlanner <: ShapePadPlanner:
  doc: \<DOC>
  Copper pad shape
  Both top and bottom copper for the PTH will
  have the same shape.
  <DOC>
  shaper:(Dims -> Shape) with:
    as-method => true
    default => to-CircleOrCapsule

doc: \<DOC>
Shape generator for Circle/Capsule

For through-holes, the most common shapes are circles and
slots. This is a helper function for creating those patterns
in the PthPadPlanner
<DOC>
public defn to-CircleOrCapsule (d:Dims) -> Shape :
  ; TODO - we may need to be more careful here
  ;  comparison between doubles isn't always a good check
  if x(d) != y(d):
    Capsule(d)
  else:
    Circle(to-radius $ x(d))

public defmethod hole-generator (x:PthPadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  to-CircleOrCapsule


public defstruct Pin1-PthPadPlanner <: PthPadPlanner :
  doc: \<DOC>
  Pin 1 Pad Shaper
  This function is called for `col=0, row=0` to construct
  the copper pad shape.
  <DOC>
  pin1-shaper:(Dims -> Shape)
  doc: \<DOC>
  Copper pad shape
  Both top and bottom copper for the PTH will
  have the same shape.
  <DOC>
  shaper:(Dims -> Shape) with:
    as-method => true
    default => to-CircleOrCapsule

public defmethod shape-generator (x:Pin1-PthPadPlanner, row:Int, column:Int) -> (Dims -> Shape)|False:
  if column == 0 and row == 0: pin1-shaper(x)
  else: shaper(x)


public defstruct StaggerPthPlanner <: PthPadPlanner :
  doc: \<DOC>
  Copper pad shape
  Both top and bottom copper for the PTH will
  have the same shape.
  <DOC>
  shaper:(Dims -> Shape) with:
    as-method => true
    default => to-CircleOrCapsule

  doc: \<DOC>
  Set the stagger phase for the planner
  <DOC>
  phase:StaggerPhase with:
    default => Even-Phase
with:
  keyword-constructor => true
  printer => true

public defmethod active? (x:StaggerPthPlanner, row:Int, column:Int) -> True|False:
  stagger-pattern(phase(x), row, column)



doc: \<DOC>
Error for MisMatched Active & Generators

If the generator functions return `False` for an active
pad grid location - then this exception will be thrown.
<DOC>
public defstruct NoGeneratorForActivePadError <: Exception:
  row:Int
  column:Int
  gen-func:String

defmethod print (o:OutputStream, e:NoGeneratorForActivePadError):
  print(o, "No '%_' generator for Active Pad [r=%_, c=%_]" % [gen-func(e), row(e), column(e)])
