doc: \<DOC>
@brief 10GBASE-KR Protocol

10GBASE-KR is a ethernet communication supporting high speed data links
in copper for backplane connections
@see https://en.wikipedia.org/wiki/10_Gigabit_Ethernet#10GBASE-KR

This functions and definitions in this file support defining 10GBASE-KR
connections between components and/or connectors in a board design.

## 10GBASE-KR Blocking Capacitors

The 10GBASE-KR specification calls for AC coupling for the data lanes. This is typically
achieved using a blocking capacitor. When connecting two active components, this typically
means blocking caps from `Tx -> Rx` on both sides of the link. When connecting an
active component to a passive component, this typically means adding the blocking caps only on
the `Tx -> Rx` side of the link.

The functions in this module allow you to pass a blocking capacitor as an `Instantiable`.
This component will get instantiated for each leg of the diff-pair. These functions handle
the topology configuration, but the user needs to set a `pin-model` statement on the capacitor component.


<DOC>
#use-added-syntax(jitx)
defpackage jsl/protocols/ethernet-10G-KR:
  import core
  import jitx
  import jitx/commands

  import jsl/bundles
  import jsl/errors
  import jsl/si/helpers
  import jsl/si/couplers
  import jsl/si/pairs
  import jsl/pin-assignment

doc: \<DOC>
@brief 10GBASE-KR Bundle
The Data Bundle consists of a number (1 or more) of RX and TX pairs (1 RX/TX pair set = 1 lane)
@param num-lanes The number of lanes to be configured for this bundle.
<DOC>

public pcb-bundle ethernet-10G-KR (num-lanes:Int) :
  name = "10GBASE-KR"
  description = "10GBASE-KR Ethernet Communications Link"
  port lane : lane-pair[num-lanes]

doc: \<DOC>
@brief Construct the 10GBASE-KR Topology and Constraints

This function constructs the 10GBASE-KR topology and applies constraints
to the channel for intra-pair skew and channel loss.

@param sw The intra-pair skew value for the differential signals being connected.
@param ml The maximum loss for all differential signals being connected.
@param cap-src-dst Optional DC blocking capacitor to be inserted between the src.TX and dst.RX signal ends. Note that
there are 2 blocking caps inserted, one on each of the pair of P,N signals. The capacitor needs to have pin models applied to its pins
in order for the overall skew and loss values to be respected.
@param cap-dst-src Optional DC blocking capacitor to be inserted between the dst.TX and src.RX signal ends. This capacitor
covers the reverse direction connection between dst.TX and src.RX. If the second component was a connector, then typically
no capacitor is inserted between dst.TX and src.RX (cap-dst-src = false).
@param src This is expected to be a port of `Bundle` type `ethernet-10G-KR`
@param dst This is expected to be a port of `Bundle` type `ethernet-10G-KR`
@param null-modem If set to true, connects src.TX through the optional cap-src-dst to dst.RX and dst.TX through the optional cap-dst-src to src.RX. 
If set to false, connects src.TX through the optional cap-src-dst to dst.TX and dst.RX through the optional cap-dst-src to src.RX
<DOC>
public defn connect-10G-KR (sw:Toleranced, ml:Double, cap-src-dst:Instantiable|False, cap-dst-src:Instantiable|False, src:JITXObject, dst:JITXObject, null-modem:True|False) :
  inside pcb-module :
    ; check-bundle(ethernet-10G-KR, src, dst)
    if length(src.lane) != length(dst.lane) :
      throw $ Exception("Invalid Port Widths - Different Widths for src/dst")
    for i in indices(src.lane) do :
      match(null-modem, cap-src-dst, cap-dst-src) :
        (nm:True|False, x:False, y:False) :
          val dst-r = if nm : reverse-lane(dst) else : dst
          topo-net(src.lane[i].TX, dst-r.lane[i].TX)
          topo-net(dst-r.lane[i].RX, src.lane[i].RX)
        (nm:True, csd:Instantiable, cds:Instantiable) :
          inst bl-cap-xy : dp-coupler(csd)
          require tx1 : dual-pair from bl-cap-xy
          inst bl-cap-yx : dp-coupler(cds)
          require tx2 : dual-pair from bl-cap-yx
          topo-net(src.lane[i].TX, tx1.A)
          topo-net(dst.lane[i].TX, tx2.A)
          topo-net(tx1.B, dst.lane[i].RX)
          topo-net(tx2.B, src.lane[i].RX)
        (nm:True|False, csd:Instantiable, y:False) :
          val dst-r = if nm : reverse-lane(dst) else : dst
          inst bl-cap-xy : dp-coupler(csd)
          require tx1 : dual-pair from bl-cap-xy
          topo-net(src.lane[i].TX, tx1.A)
          topo-net(tx1.B, dst-r.lane[i].TX)
          topo-net(dst-r.lane[i].RX, src.lane[i].RX)
        (nm:True|False, x:False, cds:Instantiable) :
          val src-r = if nm : reverse-lane(src) else : src
          inst bl-cap-yx : dp-coupler(cds)
          require tx2 : dual-pair from bl-cap-yx
          topo-net(dst.lane[i].TX, tx2.A)
          topo-net(tx2.B, src-r.lane[i].TX)
          topo-net(src-r.lane[i].RX, dst.lane[i].RX)
        (x, y, z) :
          throw $ Exception("Invalid Configuration - null-modem and/or blocking caps conflict")
      
      if null-modem :
        constrain-ch(sw, ml, src.lane[i].TX, dst.lane[i].RX)
        constrain-ch(sw, ml, dst.lane[i].TX, src.lane[i].RX)
      else :
        constrain-ch(sw, ml, src.lane[i].TX, dst.lane[i].TX)
        constrain-ch(sw, ml, src.lane[i].RX, dst.lane[i].RX)

doc: \<DOC>
@brief Curated values for skew and loss of 10GBASE-KR Channel
This is a helper function that returns the bounds on the intra-pair
skew timing and maximum loss as expected by the particular standard targeted by
the user.The values returned are a toleranced value with upper/lower limits for the
intra-pair skew and the maximum loss as a double representing dB. Some defaults in the
table are derived from the reference listed below.
https://www.ieee802.org/3/ba/public/jul08/balasubramanian_01_0708.pdf


Calculating the intra-pair skew distance to time correspondence depends on the material.
see @http://pdf.cloud.opensystemsmedia.com/advancedtca-systems.com/Simclar.Feb08.pdf
Table 3 where the intra-pair skew is set to 0.0625e-12 and the inter-pair skew
is set to 0.625e-12. This corresponds roughly to 0.01mm skew intra-pair and 
0.100mm skew inter-pair (or channel).
<DOC>

public defn ethernet-10G-KR-get-skew-loss-vals () -> [Toleranced, Toleranced, Double]:
    [0.0 +/- 0.0625e-12, 0.0 +/- 0.625e-12, 15.0]

doc: \<DOC>
@brief Differential impedance specified by the 10GBASE-KR standard
This is a helper function that returns the expected differential
trace impedance for the specified generation of the 10GBASE-KR standard.

@returns Upper/lower limits for the impedance.
<DOC>

public defn ethernet-10G-KR-get-trace-impedance () -> Toleranced :
  100.0 +/- (10 %)  ;   2.5 GT/s

doc: \<DOC>
@brief Apply the differential routing structure to a 10GBASE-KR bundle.
The function applies the provided DifferentialRoutingStructure
to all of the differential pairs in the start and endpoints. Note that both start and end points
need to be connected to physical component pins either directly or via pin assignment.
@param x This is expected to be a port of `Bundle` type `ethernet-10G-KR`
@param y This is expected to be a port of `Bundle` type `ethernet-10G-KR`
<DOC>

public defn ethernet-10G-KR-apply-routing-structure (rs:DifferentialRoutingStructure, x:JITXObject, y:JITXObject) :
  inside pcb-module :
    for i in indices(x.tx) do :
      diff-structure(rs, x.tx[i] => y.rx[i])
    for i in indices(y.tx) do :
      diff-structure(rs, y.tx[i] => x.rx[i])
