#use-added-syntax(jitx)
defpackage jsl/landpatterns/BGA/package:
  import core
  import math
  import jitx
  import jitx/commands

  import jsl/design/settings
  import jsl/geometry/basics
  import jsl/geometry/box
  import jsl/geometry/LineRectangle
  import jsl/errors
  import jsl/ensure

  import jsl/landpatterns/framework
  import jsl/landpatterns/BGA/pads
  import jsl/landpatterns/BGA/planner
  import jsl/landpatterns/grid-planner

doc: \<DOC>
@title Ball Grid Array Package
@desc The BGA package use a 2-D grid of rows (letters) and
columns (integers). The grid is typically delineated in row-major order.
@member num-leads Total number of leads for the BGA Grid
@member lead-diam BGA Ball Lead Diameter in mm
@member package-body Component body physical representation.
@member pad-planner Pad Planner for the BGA package
@member lead-numbering Lead Numbering Scheme for the BGA Package
@member density-level Density Level for the Generated Package

@snippet A simple BGA package
```stanza
  ; NSMD
  val rows = 3
  val cols = 3
  val grid = Grid-Numbering(rows, cols)
  val pitch = 0.5

  val planner = Full-Matrix-Planner(
    pad-config = PadConfig-D(
      copper-D-adj = ipc-bga-copper(
        NonSolderMaskDefined,
        density-level = DensityLevelC
        ),
      mask-D-adj = 0.0,
    ),
    rows = rows
    columns = cols
    pitch = pitch
  )

  val body = PackageBody(
    width = 2.0 +/- 0.1,
    length = 2.0 +/- 0.1,
    height = 0.71 +/- [0.06, 0.0]
  )

  val pkg = BGA(
    num-leads = 9,
    lead-diam = 0.3,
    package-body = body,
    lead-numbering = grid,
    pad-planner = planner,
    density-level = DensityLevelB
  )
```
<DOC>
public defstruct BGA <: Package :
  doc: \<DOC>
  @title num-leads
  @desc Total number of leads for the BGA Grid
  <DOC>
  num-leads:Int with: (
    ensure => ensure-positive!,
    as-method => true
  )
  doc: \<DOC>
  @title lead-diam
  @desc BGA Ball Lead Diameter in mm
  <DOC>
  lead-diam:Double with: (
    ensure => ensure-positive!,
  )

  doc: \<DOC>
  @title package-body
  @desc Package Body for the BGA.
  <DOC>
  package-body:PackageBody with: (as-method => true)

  doc: \<DOC>
  @title pad-planner
  @desc The planner determines which pads will be created in the
  grid. See {@link PadPlanner} and {@link GridPlanner} for more info.
  This interface will define the pitch (distance between balls) and
  the number of rows/columns and how they are organized.
  <DOC>
  pad-planner:PadPlanner with: (as-method => true)

  doc: \<DOC>
  @title lead-numbering
  @desc The lead numbering scheme determines the order of the leads in the grid.
  <DOC>
  lead-numbering:Numbering with: (as-method => true)

  doc: \<DOC>
  @title density-level
  @desc The density level determines the amount of space between the balls.
  <DOC>
  density-level:DensityLevel with: (as-method => true)
with:
  hashable => true
  printer => true
  constructor => #BGA

doc: \<DOC>
@title BGA Package Constructor
@desc The function constructs a Full Matrix BGA by default
using the passed arguments. For more control over
the pads and numbering, use the other constructor
variant.

@param num-leads Total number of lead placements assuming
all leads are present.
@param rows Number of rows of ball leads (Y dimension)
@param columns Number of columns of ball leads (X dimension)
@param lead-diam Size of the BGA ball lead.
@param pitch Ball Spacing
@param package-body Component body physical representation.
@param density-level Density Level for the Generated Package

@snippet An alternate way to define a simple BGA package
```stanza
  ; NSMD
  val rows = 3
  val cols = 3
  val pitch = 0.5
  val body = PackageBody(
    width = 2.0 +/- 0.1,
    length = 2.0 +/- 0.1,
    height = 0.71 +/- [0.06, 0.0]
  )

  val pkg = BGA(
    num-leads = 9,
    rows = rows,
    columns = cols,
    lead-diam = 0.3,
    pitch = pitch,
    package-body = body,
    density-level = DensityLevelB
  )
```
<DOC>
public defn BGA (
  --
  num-leads:Int,
  rows:Int,
  columns:Int,
  lead-diam:Double,
  pitch:Double|Dims,
  package-body:PackageBody,
  density-level:DensityLevel = DENSITY-LEVEL
) -> BGA :
  val pad-planner:BGA-PadPlanner = Full-Matrix-Planner(
    rows = rows,
    columns = columns,
    pitch = pitch
    ),
  val lead-numbering:Numbering = Grid-Numbering(rows, columns)
  #BGA(
    num-leads, lead-diam,
    package-body,
    pad-planner,
    lead-numbering,
    density-level
  )

doc: \<DOC>
@title BGA Package Constructor
@desc This function constructs a BGA package with the passed arguments.
@param num-leads Total number of leads for the BGA Grid
@param lead-diam BGA Ball Lead Diameter in mm
@param package-body Component body physical representation.
@param pad-planner Pad Planner for the BGA package
@param lead-numbering Lead Numbering Scheme for the BGA Package
@param density-level Density Level for the Generated Package

@snippet A simple BGA package
```stanza
  ; NSMD
  val rows = 3
  val cols = 3
  val pitch = 0.5

  val body = PackageBody(
    width = 2.0 +/- 0.1,
    length = 2.0 +/- 0.1,
    height = 0.71 +/- [0.06, 0.0]
  )
  val grid = Grid-Numbering(rows, cols)
  val planner = Full-Matrix-Planner(
    rows = rows,
    columns = cols,
    pitch = pitch
  )

  val pkg = BGA(
    num-leads = 9,
    lead-diam = 0.3,
    package-body = body,
    pad-planner = planner,
    lead-numbering = grid,
    density-level = DensityLevelB
  )
```
<DOC>
public defn BGA (
  --
  num-leads:Int,
  lead-diam:Double,
  package-body:PackageBody,
  pad-planner:BGA-PadPlanner,
  lead-numbering:Numbering = Grid-Numbering(rows(pad-planner), columns(pad-planner))
  density-level:DensityLevel = DENSITY-LEVEL
) -> BGA :
  #BGA(
    num-leads,
    lead-diam,
    package-body,
    pad-planner,
    lead-numbering,
    density-level
  )

doc: \<DOC>
@title Get BGA Planner
@desc This function returns the planner for the BGA package.
@param bga BGA Package
<DOC>
public defn get-bga-planner (bga:BGA) -> BGA-PadPlanner:
  pad-planner(bga) as BGA-PadPlanner

doc: \<DOC>
@title BGA Name
@desc This function returns the name of the BGA package.
@param bga BGA Package
<DOC>
public defmethod name (bga:BGA) -> String:
  defn to-deci (v:Double) -> String:
    val v* = to-int( v * 100.0 )
    to-string("%_" % [v*])

  val grid-p = get-bga-planner(bga)

  val pitchStr = match(pitch(grid-p)):
    (p:Double): to-deci(p)
    (pa:Dims):
      val px = to-deci $ x(pa)
      val py = to-deci $ y(pa)
      to-string("%_X%_" % [px, py])

  val ballGrid = to-string("%_X%_" % [columns(grid-p), rows(grid-p)])

  val b = package-body(bga)

  to-string("BGA%_N%_P%__%_X%_X%_" % [
    num-leads(bga),
    pitchStr,
    ballGrid,
    to-deci $ typ $ width(b),
    to-deci $ typ $ length(b),
    to-deci $ typ $ height(b),
  ])

doc: \<DOC>
@title BGA Court Yard Excess
@desc This function returns the amount of excess space around the BGA package based on the density level.
@param bga BGA Package
<DOC>
public defmethod courtyard-excess (pkg:BGA) -> Double :
  ; From IPC 7351B Table 3-17
  switch(density-level(pkg)):
    DensityLevelA: 2.0
    DensityLevelB: 1.0
    DensityLevelC: 0.5

doc: \<DOC>
@title Build Vpads
@desc This function builds the virtual pads for the BGA package.
@param pkg BGA Package
@param vp Virtual Land Pattern
<DOC>
public defn build-vpads (
  pkg:BGA,
  vp:VirtualLP
  ):
  ; For the BGA - we size the pad according to the
  ;  ball diameter and allow the `PadConfig` object to
  ;  drive the pad sizing.
  val pad-size = Dims(lead-diam(pkg), lead-diam(pkg))
  ; Generate the grid
  val planner = get-bga-planner(pkg)
  val pad-seq = pad-grid-smt(
    pad-size = pad-size,
    planner = planner,
    lead-grid = planner,
    num-scheme = lead-numbering(pkg)
  )

  append-all(vp, pad-seq)

doc: \<DOC>
@title Build Pads
@desc This function builds the pads for the BGA package using a virtual land pattern.
@param pkg BGA Package
@param vp Virtual Land Pattern
<DOC>
public defmethod build-pads (
  pkg:BGA,
  vp:VirtualLP,
  ) -> False :
  build-vpads(pkg, vp)

doc: \<DOC>
@title Compute Overall Outline
@desc This function computes the overall outline for the BGA package.
@param vp Virtual Land Pattern
@param body Package Body
@param density-level Density Level
@param line-width Silkscreen Line Width
@param mask-clearance Mask Clearance
<DOC>
public defn compute-overall-outline (
  vp:VirtualLP,
  body:PackageBody,
  density-level:DensityLevel
  --
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  ) -> Shape:

  val pkg-outline = bounds $ envelope(body, density-level = density-level)
  val lp-pads = get-pads(vp)
  val pad-outline* = bounds(lp-pads, layer-spec = SolderMask(Top))
  val pad-outline = fatten(mask-clearance + (line-width / 2.0), pad-outline*)
  val overall = union(pkg-outline, pad-outline)
  LineRectangle(overall, line-width = line-width)

doc: \<DOC>
@title Build BGA Pad Outline
@desc This function builds the outline for the BGA package.
@param vp Virtual Land Pattern
@param body Package Body
@param density-level Density Level
<DOC>
public defn build-outline (
  vp:VirtualLP,
  body:PackageBody,
  density-level:DensityLevel
  ) -> False:
  val outline = compute-overall-outline(vp, body, density-level)
  add-artwork(vp, Silkscreen("outline", Top), outline, class = "outline")

doc: \<DOC>
@title Build BGA Pin 1 Marker
@desc This function builds the pin 1 marker for the BGA package.
@param vp Virtual Land Pattern
@param pin-1-id Pin 1 ID
@param side Side (Top, Right, Bottom, Left)
@param line-width Silkscreen Line Width
@param mask-clearance SolderMask Clearance
<DOC>
public defn build-pin-1-marker (
  vp:VirtualLP
  --
  pin-1-id:Int|Ref = 1,
  side:Side = Top
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  ):
  val outline = get-silkscreen-outline!(vp)
  val o-sh = shape(outline)

  val pin-1-pos = center $ pose $ get-pad-by-ref!(vp, pin-1-id)

  val o-box = bounds $ o-sh
  val closest = compute-closest-corner(pin-1-pos, o-box)

  val corner = compute-corner(closest)
  val rot = corner-to-rotation(corner)

  val x-offset = (1.5 * line-width) + mask-clearance
  val y-offset = line-width
  val marker-shape = Circle((- x-offset), (- y-offset), line-width)
  val marker-pose = loc(closest, rot)
  val marker = marker-pose * marker-shape

  add-artwork(
    vp, Silkscreen("pin-1-marker", side),
    marker,
    name = "pin-1-dot",
    class = "pin-1-marker"
    )

doc: \<DOC>
@title Build BGA Silkscreen Artwork
@desc This function builds the silkscreen artwork for the BGA package.
@param pkg BGA Package
@param vp Virtual Land Pattern
<DOC>
public defmethod build-silkscreen (
  pkg:BGA,
  vp:VirtualLP,
  ):
  val pin-1-id = match(get-pad-by-ref(vp, IndexRef(Ref("A"), 1))) :
    (p:One<VirtualPad>) : pad-id(value(p))
    (_) : pad-id(get-first-pad(vp))
  build-outline(vp, package-body(pkg), density-level(pkg))
  build-pin-1-marker(vp, pin-1-id = pin-1-id)
  build-outline-pin-1-triangle(vp, pin-1-id = pin-1-id)
  add-reference-designator(vp)
